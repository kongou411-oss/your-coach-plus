<!DOCTYPE html>
<!--
  履歴グラフ v2.2.0
  更新日: 2025-10-22
  変更内容:
  - 運動カテゴリの「1RM」「5RM」「10RM」を「RM」1つに統合
  - RM選択時に専用調整パネルを表示（回数選択・種目選択の2段階）
  - ユーザーが実際に記録したRM回数と種目のみを動的に表示
  - 種目別・回数別のRM推移をグラフで確認可能に
-->
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>履歴グラフ v2.0.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- 目標ライン・メモ機能 -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1"></script>
    <!-- カスタム期間選択 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/ja.js"></script>
    <style>
        /* スクロールバーを完全非表示 */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        *::-webkit-scrollbar {
            display: none; /* Chrome/Safari/Opera */
        }

        .tab-button {
            transition: all 0.3s ease;
            position: relative;
        }
        .tab-button.active {
            font-weight: 600;
        }
        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: currentColor;
        }
        .sub-tab-button {
            transition: all 0.2s ease;
        }
        .sub-tab-button.active {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .chart-container {
            animation: fadeIn 0.4s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .day-box {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
            font-weight: 600;
            font-size: 0.75rem;
        }
        .day-box.done {
            background-color: #22c55e;
            color: white;
        }
        .day-box.not-done {
            background-color: #e5e7eb;
            color: #6b7280;
        }
        .range-control {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-top: 1rem;
        }
        .period-button {
            transition: all 0.2s ease;
            position: relative;
            padding: 0.5rem 1rem;
            background: transparent;
            border: none;
            color: #6b7280;
            font-weight: 500;
        }
        .period-button.active {
            color: #7c3aed;
            font-weight: 600;
        }
        .period-button.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #7c3aed;
        }
        .period-button:hover {
            color: #7c3aed;
            background: rgba(124, 58, 237, 0.05);
        }
        .comparison-enabled .chart-section {
            border: 2px solid #3b82f6;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.show {
            display: flex;
        }
        .modal-content {
            background: white;
            border-radius: 1rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease-out;
        }
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .ai-analyzing {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .ai-analyzing .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .sync-icon {
            transition: transform 0.3s ease;
        }
        .sync-icon.syncing {
            animation: rotate 1s ease-in-out;
        }
        @keyframes rotate {
            to { transform: rotate(360deg); }
        }
        .info-icon {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .info-icon:hover {
            transform: scale(1.1);
            color: #3b82f6;
        }
        .tooltip {
            display: none;
            position: absolute;
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            max-width: 400px;
            animation: fadeIn 0.2s ease-out;
        }
        .tooltip.show {
            display: block;
        }
        .help-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        .help-modal.show {
            display: flex;
        }
        .help-content {
            background: white;
            border-radius: 1rem;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease-out;
        }
        .floating-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 320px;
            max-height: calc(100vh - 100px);
            background: white;
            border-radius: 1rem;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            z-index: 1500;
            overflow-y: auto;
            animation: slideInRight 0.3s ease-out;
        }
        .floating-panel.hidden {
            display: none;
        }
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        .stats-inline {
            display: flex;
            justify-content: space-around;
            gap: 0.5rem;
            padding: 0.75rem;
            background: linear-gradient(to right, #f3f4f6, #e5e7eb);
            border-radius: 0.5rem;
            font-size: 0.875rem;
            margin-top: 1rem;
        }
        .stats-inline .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }
        .stats-inline .stat-value {
            font-size: 1.125rem;
            font-weight: bold;
        }
        .stats-inline .stat-value .unit {
            font-size: 0.75rem;
            font-weight: normal;
            opacity: 0.7;
        }
        .stats-inline .stat-label {
            font-size: 0.625rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        .compact-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .compact-buttons {
            display: flex;
            gap: 0.5rem;
        }
        .compact-buttons button {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- 履歴バナー（フルワイド） -->
    <div class="bg-gradient-to-r from-purple-500 to-indigo-600 shadow-md p-3 mb-4">
        <div class="flex items-center gap-2 text-white">
            <i data-lucide="trending-up" class="w-5 h-5"></i>
            <span class="text-lg font-bold">履歴</span>
        </div>
    </div>

    <div class="max-w-6xl mx-auto px-4">
        <!-- メインコンテナ -->
        <div class="bg-white rounded-lg shadow-lg overflow-hidden">
            <!-- 大カテゴリタブ -->
            <div class="flex border-b bg-gray-50">
                <button type="button"
                    class="tab-button flex-1 py-3 px-2 text-center transition text-gray-600 relative"
                    onclick="selectMainCategory('nutrition', event)">
                    <div class="flex flex-col items-center justify-center gap-1">
                        <i data-lucide="utensils" class="w-5 h-5"></i>
                        <div class="text-xs font-semibold whitespace-nowrap">
                            食事
                        </div>
                    </div>
                </button>
                <button type="button"
                    class="tab-button flex-1 py-3 px-2 text-center transition text-gray-600 relative"
                    onclick="selectMainCategory('training', event)">
                    <div class="flex flex-col items-center justify-center gap-1">
                        <i data-lucide="dumbbell" class="w-5 h-5"></i>
                        <div class="text-xs font-semibold whitespace-nowrap">
                            運動
                        </div>
                    </div>
                </button>
                <button type="button"
                    class="tab-button flex-1 py-3 px-2 text-center transition text-gray-600 relative"
                    onclick="selectMainCategory('condition', event)">
                    <div class="flex flex-col items-center justify-center gap-1">
                        <i data-lucide="heart-pulse" class="w-5 h-5"></i>
                        <div class="text-xs font-semibold whitespace-nowrap">
                            コンディション
                        </div>
                    </div>
                </button>
                <button type="button"
                    class="tab-button flex-1 py-3 px-2 text-center transition active text-purple-600 bg-white border-b-0 relative"
                    onclick="selectMainCategory('performance', event)">
                    <div class="flex flex-col items-center justify-center gap-1">
                        <i data-lucide="trending-up" class="w-5 h-5"></i>
                        <div class="text-xs font-semibold whitespace-nowrap">
                            パフォーマンス
                        </div>
                    </div>
                </button>
                <button type="button"
                    class="tab-button flex-1 py-3 px-2 text-center transition text-gray-600 relative"
                    onclick="selectMainCategory('insights', event)">
                    <div class="flex flex-col items-center justify-center gap-1">
                        <i data-lucide="lightbulb" class="w-5 h-5"></i>
                        <div class="text-xs font-semibold whitespace-nowrap">
                            閃き
                        </div>
                    </div>
                </button>
            </div>

            <!-- 小カテゴリタブ（食事） -->
            <div id="nutrition-subtabs" class="sub-tabs border-b bg-green-50 hidden">
                <div class="flex overflow-x-auto px-2 py-1 gap-1">
                <button type="button" class="sub-tab-button active px-2 py-1 bg-white text-green-700 rounded text-xs font-semibold border border-green-500" onclick="selectSubCategory('nutrition', 'calories')">
                    摂取カロリー
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'protein')">
                    タンパク質
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'fat')">
                    脂質
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'carbs')">
                    炭水化物
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'sugar')">
                    糖質
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'fiber')">
                    食物繊維
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'vitamin_score')">
                    ビタミン
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'mineral_score')">
                    ミネラル
                </button>
                </div>
            </div>

            <!-- 小カテゴリタブ（運動） -->
            <div id="training-subtabs" class="sub-tabs border-b bg-orange-50 hidden">
                <div class="flex overflow-x-auto px-2 py-1 gap-1">
                <button type="button" class="sub-tab-button active px-2 py-1 bg-white text-orange-700 rounded text-xs font-semibold border border-orange-500" onclick="selectSubCategory('training', 'total_time')">
                    総時間
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('training', 'total_exercises')">
                    総種目数
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('training', 'total_weight')">
                    総重量
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('training', 'rm')">
                    RM
                </button>
                </div>
            </div>

            <!-- 小カテゴリタブ（コンディション） -->
            <div id="condition-subtabs" class="sub-tabs border-b bg-red-50 hidden">
                <div class="flex overflow-x-auto px-2 py-1 gap-1">
                <button type="button" class="sub-tab-button active px-2 py-1 bg-white text-red-700 rounded text-xs font-semibold border border-red-500" onclick="selectSubCategory('condition', 'sleep_duration')">
                    睡眠時間
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('condition', 'sleep_quality')">
                    睡眠の質
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('condition', 'appetite')">
                    食欲
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('condition', 'gut_health')">
                    腸内環境
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('condition', 'focus')">
                    集中力
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('condition', 'stress')">
                    ストレス
                </button>
                </div>
            </div>

            <!-- 小カテゴリタブ（パフォーマンス） -->
            <div id="performance-subtabs" class="sub-tabs border-b bg-purple-50">
                <div class="flex overflow-x-auto px-2 py-1 gap-1">
                <button type="button" class="sub-tab-button active px-2 py-1 bg-white text-purple-700 rounded text-xs font-semibold border border-purple-500" onclick="selectSubCategory('performance', 'lbm')">
                    LBM
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('performance', 'directive')">
                    指示書達成率
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('performance', 'overall')">
                    総合分析
                </button>
                </div>
            </div>

            <!-- 閃きコンテンツ -->
            <div id="insights-content" class="p-6 hidden">
                <div class="mb-6">
                    <h2 class="text-2xl font-bold text-gray-800 flex items-center gap-2">
                        <i data-lucide="lightbulb" class="w-7 h-7 text-yellow-500"></i>
                        閃きメモ一覧
                    </h2>
                    <p class="text-sm text-gray-600 mt-2">全期間の閃きメモを表示します</p>
                </div>
                <div id="insights-list" class="space-y-3">
                    <!-- JavaScriptで動的に生成 -->
                </div>
            </div>

            <!-- 詳細グラフ表示エリア -->
            <div id="graph-area" class="p-6">
                <!-- グラフ1（メイン） -->
                <div id="chart-1" class="chart-section mb-6">
                    <!-- コンパクトヘッダー -->
                    <div class="mb-3">
                        <div>
                            <h3 id="chart-title-1" class="text-2xl font-bold text-gray-800">💪 LBM - 除脂肪体重</h3>
                            <p id="chart-period-1" class="text-sm text-gray-500 mt-1">過去7日間の推移</p>
                        </div>
                        <div class="flex gap-2 mt-2">
                            <button type="button" onclick="analyzeWithGemini()" class="px-3 py-2 bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white rounded-lg flex items-center gap-2 text-sm font-semibold shadow-sm transition">
                                <i data-lucide="sparkles" class="w-4 h-4"></i>
                                <span>AI分析</span>
                            </button>
                            <button type="button" onclick="toggleSettingsPanel(1)" class="px-3 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg flex items-center gap-2 text-sm font-semibold transition">
                                <i data-lucide="settings" class="w-4 h-4"></i>
                                <span>設定</span>
                            </button>
                        </div>
                    </div>

                    <!-- RM専用調整パネル -->
                    <div id="rm-control-panel" class="mb-4 p-3 bg-orange-50 rounded-lg border border-orange-200 hidden">
                        <div class="mb-2">
                            <div class="text-xs font-semibold text-orange-900 mb-1">回数を選択</div>
                            <div id="rm-reps-buttons" class="flex flex-wrap gap-1">
                                <!-- 動的に生成 -->
                            </div>
                        </div>
                        <div>
                            <div class="text-xs font-semibold text-orange-900 mb-1">種目を選択</div>
                            <div id="rm-exercise-buttons" class="flex flex-wrap gap-1">
                                <!-- 動的に生成 -->
                            </div>
                        </div>
                    </div>

                    <!-- 期間選択（タブ式UI） -->
                    <div class="mb-4 border-b border-gray-200">
                        <div class="flex overflow-x-auto">
                            <button type="button" class="period-button active text-sm" onclick="selectPeriod(1, 7, event)">7日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 14, event)">14日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 30, event)">30日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 60, event)">60日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 90, event)">90日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 180, event)">180日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 365, event)">1年</button>
                        </div>
                    </div>

                    <div style="height: 350px; position: relative;">
                        <canvas id="main-chart-1"></canvas>
                    </div>

                    <!-- 選択されたデータポイントの詳細とナビゲーション -->
                    <div id="selected-point-1" class="mt-3 p-3 bg-white rounded-lg border-2 border-purple-300 shadow-sm">
                        <div class="flex items-center justify-between">
                            <button type="button" onclick="navigateDataPoint(1, -1)" class="p-2 hover:bg-gray-100 rounded-full transition">
                                <i data-lucide="chevron-left" class="w-5 h-5 text-gray-700"></i>
                            </button>
                            <div class="text-center flex-1">
                                <div id="selected-date-1" class="text-sm font-semibold text-gray-800 mb-1"></div>
                                <div id="selected-value-1" class="text-2xl font-bold text-purple-600"></div>
                            </div>
                            <button type="button" onclick="navigateDataPoint(1, 1)" class="p-2 hover:bg-gray-100 rounded-full transition">
                                <i data-lucide="chevron-right" class="w-5 h-5 text-gray-700"></i>
                            </button>
                        </div>
                        <!-- ツールチップ表示/非表示切り替えボタン -->
                        <div class="mt-2 pt-2 border-t border-gray-200">
                            <button type="button" id="tooltip-toggle-1" onclick="toggleTooltip(1)" class="w-full px-3 py-1.5 text-xs font-semibold bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition">
                                <i data-lucide="info" class="w-3 h-3 inline-block mr-1"></i>
                                ツールチップを表示
                            </button>
                        </div>
                    </div>

                    <!-- コンパクトな統計情報（1行） -->
                    <div class="stats-inline">
                        <div class="stat-item">
                            <div class="stat-value text-blue-600" id="stat-avg-1">62.0kg</div>
                            <div class="stat-label">平均<span id="stat-avg-unit-1" class="hidden"></span></div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value text-green-600" id="stat-max-1">62.5kg</div>
                            <div class="stat-label">最高<span id="stat-max-unit-1" class="hidden"></span></div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value text-orange-600" id="stat-min-1">61.0kg</div>
                            <div class="stat-label">最低<span id="stat-min-unit-1" class="hidden"></span></div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value text-purple-600" id="chart-value-1">62.5kg</div>
                            <div class="stat-label">現在<span id="chart-unit-1" class="hidden"></span></div>
                        </div>
                    </div>

                    <!-- 詳細統計情報（標準偏差・トレンド） -->
                    <div class="mt-3 grid grid-cols-2 gap-2">
                        <div class="p-3 bg-gray-50 rounded-lg">
                            <div class="text-xs text-gray-600 mb-1">標準偏差</div>
                            <div class="text-lg font-bold text-gray-800" id="stat-stddev-1">0.5kg</div>
                        </div>
                        <div class="p-3 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200">
                            <div class="text-xs text-gray-600 mb-1">トレンド</div>
                            <div class="flex items-center gap-2">
                                <span class="text-2xl" id="stat-trend-icon-1">→</span>
                                <div>
                                    <div class="text-sm font-bold" id="stat-trend-label-1">横ばい</div>
                                    <div class="text-xs text-gray-600" id="stat-trend-value-1">+0.0kg (0.0%)</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- カテゴリ別範囲表示 -->
                    <div class="mt-3 p-2 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200">
                        <div class="flex items-center justify-between text-xs">
                            <span class="text-gray-600">全期間（50年）の範囲:</span>
                            <span class="font-semibold text-gray-800">
                                <span class="text-orange-600" id="category-min-1">60.0</span>
                                <span class="text-gray-400 mx-1">～</span>
                                <span class="text-green-600" id="category-max-1">63.0</span>
                                <span id="category-unit-1" class="text-gray-500 ml-1">kg</span>
                            </span>
                        </div>
                    </div>

                    <!-- 旧統計情報コンテナ（非表示用・互換性維持） -->
                    <div id="stats-container-1" class="hidden"></div>
                </div>

                <!-- グラフ2（比較用） -->
                <div id="chart-2" class="chart-section hidden">
                    <div class="border-t-2 border-dashed border-gray-300 pt-6 mt-6">
                        <!-- コンパクトヘッダー -->
                        <div class="compact-header">
                            <div>
                                <h3 id="chart-title-2" class="text-2xl font-bold text-gray-800">💪 LBM - 除脂肪体重 - 比較</h3>
                                <p id="chart-period-2" class="text-sm text-gray-500 mt-1">過去30日間の推移</p>
                            </div>
                        </div>

                        <!-- 期間選択（モバイル対応・画面幅に収まる） -->
                        <div class="mb-4">
                            <div class="grid grid-cols-4 gap-1.5">
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 7, event)">7日</button>
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 14, event)">14日</button>
                                <button type="button" class="period-button active px-2 py-1.5 rounded text-xs font-semibold bg-blue-600 text-white shadow-sm transition" onclick="selectPeriod(2, 30, event)">30日</button>
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 60, event)">60日</button>
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 90, event)">90日</button>
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 180, event)">180日</button>
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 365, event)">1年</button>
                            </div>
                        </div>

                        <!-- カテゴリ別範囲表示 -->
                        <div class="mb-3 p-2 bg-gradient-to-r from-blue-50 to-cyan-50 rounded-lg border border-blue-200">
                            <div class="flex items-center justify-between text-xs">
                                <span class="text-gray-600">全期間（50年）の範囲:</span>
                                <span class="font-semibold text-gray-800">
                                    <span class="text-orange-600" id="category-min-2">60.0</span>
                                    <span class="text-gray-400 mx-1">～</span>
                                    <span class="text-green-600" id="category-max-2">63.0</span>
                                    <span id="category-unit-2" class="text-gray-500 ml-1">kg</span>
                                </span>
                            </div>
                        </div>

                        <div style="height: 350px; position: relative;">
                            <canvas id="main-chart-2"></canvas>
                        </div>

                        <!-- コンパクトな統計情報（1行） -->
                        <div class="stats-inline">
                            <div class="stat-item">
                                <div class="stat-value text-blue-600" id="stat-avg-2">61.5kg</div>
                                <div class="stat-label">平均<span id="stat-avg-unit-2" class="hidden"></span></div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value text-green-600" id="stat-max-2">62.5kg</div>
                                <div class="stat-label">最高<span id="stat-max-unit-2" class="hidden"></span></div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value text-orange-600" id="stat-min-2">60.0kg</div>
                                <div class="stat-label">最低<span id="stat-min-unit-2" class="hidden"></span></div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value text-purple-600" id="chart-value-2">62.5kg</div>
                                <div class="stat-label">現在<span id="chart-unit-2" class="hidden"></span></div>
                            </div>
                        </div>

                        <!-- 選択されたデータポイントの詳細とナビゲーション -->
                        <div id="selected-point-2" class="mt-3 p-3 bg-white rounded-lg border-2 border-blue-300 shadow-sm hidden">
                            <div class="flex items-center justify-between">
                                <button type="button" onclick="navigateDataPoint(2, -1)" class="p-2 hover:bg-gray-100 rounded-full transition">
                                    <i data-lucide="chevron-left" class="w-5 h-5 text-gray-700"></i>
                                </button>
                                <div class="text-center flex-1">
                                    <div id="selected-date-2" class="text-sm font-semibold text-gray-800 mb-1"></div>
                                    <div id="selected-value-2" class="text-2xl font-bold text-blue-600"></div>
                                </div>
                                <button type="button" onclick="navigateDataPoint(2, 1)" class="p-2 hover:bg-gray-100 rounded-full transition">
                                    <i data-lucide="chevron-right" class="w-5 h-5 text-gray-700"></i>
                                </button>
                            </div>
                        </div>

                        <!-- 旧統計情報コンテナ（非表示用・互換性維持） -->
                        <div id="stats-container-2" class="hidden"></div>
                    </div>
                </div>
            </div>
        </div>


        <!-- ヘルプモーダル -->
        <div id="help-modal" class="help-modal">
            <div class="help-content">
                <div class="sticky top-0 bg-gradient-to-r from-blue-600 to-cyan-600 text-white p-4 rounded-t-lg">
                    <div class="flex justify-between items-center">
                        <div class="flex items-center gap-2">
                            <i data-lucide="help-circle" class="w-5 h-5"></i>
                            <h3 class="text-lg font-bold">履歴グラフの使い方</h3>
                        </div>
                        <button type="button" onclick="closeHelpModal()" class="p-1 hover:bg-white/20 rounded">
                            <i data-lucide="x" class="w-5 h-5"></i>
                        </button>
                    </div>
                </div>
                <div class="p-6">
                    <div class="space-y-6">
                        <!-- 基本操作 -->
                        <div>
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="mouse-pointer-click" class="w-5 h-5 text-blue-600"></i>
                                基本操作
                            </h4>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600 font-bold">1.</span>
                                    <span><strong>カテゴリタブ</strong>: 食事・運動・コンディション・パフォーマンスを切り替え</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600 font-bold">2.</span>
                                    <span><strong>サブカテゴリタブ</strong>: 各カテゴリ内の詳細指標を選択</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600 font-bold">3.</span>
                                    <span><strong>期間ボタン</strong>: 7日間/14日間/30日間/90日間から表示期間を選択</span>
                                </li>
                            </ul>
                        </div>

                        <!-- 比較モード -->
                        <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="columns-2" class="w-5 h-5 text-blue-600"></i>
                                比較モード
                            </h4>
                            <p class="text-sm text-gray-700 mb-3">
                                2つのグラフを同時に表示し、異なる期間を比較できます。
                            </p>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600">•</span>
                                    <span>例: 上のグラフで「7日間」、下のグラフで「30日間」を選択して短期と長期を比較</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600">•</span>
                                    <span>上のグラフで選択した期間は、下のグラフで選択できません（重複防止）</span>
                                </li>
                            </ul>
                        </div>

                        <!-- Y軸連動 -->
                        <div class="bg-purple-50 p-4 rounded-lg border border-purple-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="refresh-cw" class="w-5 h-5 text-purple-600"></i>
                                Y軸連動機能
                            </h4>
                            <p class="text-sm text-gray-700 mb-3">
                                上のグラフのY軸範囲を変更すると、下のグラフも自動で同じ範囲に調整されます。
                            </p>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>ONの場合</strong>: 上下のグラフで同じスケールを使用（比較しやすい）</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>OFFの場合</strong>: 上下のグラフで独立したスケールを使用</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span>チェックボックスをクリックでON/OFF切り替え可能</span>
                                </li>
                            </ul>
                        </div>

                        <!-- Y軸範囲調整 -->
                        <div>
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="sliders-horizontal" class="w-5 h-5 text-green-600"></i>
                                Y軸範囲の調整
                            </h4>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">•</span>
                                    <span><strong>デフォルト</strong>: 全期間（90日間）の最低値～最高値を基準に自動設定</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">•</span>
                                    <span><strong>手動調整</strong>: 「最小値」「最大値」の入力欄に数値を入力して表示範囲を変更</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">•</span>
                                    <span><strong>初期値に戻す</strong>: ボタンをクリックでデフォルトの範囲に戻す</span>
                                </li>
                            </ul>
                        </div>

                        <!-- AI分析 -->
                        <div class="bg-gradient-to-r from-purple-50 to-blue-50 p-4 rounded-lg border border-purple-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="sparkles" class="w-5 h-5 text-purple-600"></i>
                                AI分析機能
                            </h4>
                            <p class="text-sm text-gray-700 mb-3">
                                Gemini AIがグラフデータを分析し、トレンド評価・改善提案を生成します。
                            </p>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>トレンド分析</strong>: 増加/減少/横ばいを判定し理由を説明</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>目標達成予測</strong>: 現在のペースで目標達成までの日数を予測</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>改善提案</strong>: 具体的なアクション（食事/運動/休養）を3つ提示</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>注意点</strong>: データから気をつけるべきポイントを抽出</span>
                                </li>
                            </ul>
                        </div>

                        <!-- 統計情報 -->
                        <div>
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="bar-chart-3" class="w-5 h-5 text-orange-600"></i>
                                統計情報の見方
                            </h4>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600">•</span>
                                    <span><strong>平均</strong>: 選択期間内の平均値</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">•</span>
                                    <span><strong>最高</strong>: 選択期間内の最高値</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-orange-600">•</span>
                                    <span><strong>最低</strong>: 選択期間内の最低値</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>指示書達成状況</strong>: 達成率（%）、完了日数、未完了日数を表示</span>
                                </li>
                            </ul>
                        </div>

                        <!-- データ保存（スクリーンショット推奨） -->
                        <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="camera" class="w-5 h-5 text-green-600"></i>
                                データ保存方法
                            </h4>
                            <p class="text-sm text-gray-700 mb-3">
                                グラフをスクリーンショットで保存することを推奨します：
                            </p>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">📸</span>
                                    <span><strong>Windows</strong>: Win + Shift + S（画面の一部を選択）</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">📸</span>
                                    <span><strong>Mac</strong>: Cmd + Shift + 4（画面の一部を選択）</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">📸</span>
                                    <span><strong>ブラウザ</strong>: 右クリック → 「ページのスクリーンショットを撮る」（Firefox）</span>
                                </li>
                            </ul>
                        </div>

                        <!-- 新機能（移動平均・重ね合わせ） -->
                        <div class="bg-gradient-to-r from-orange-50 to-yellow-50 p-4 rounded-lg border border-orange-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="sparkles" class="w-5 h-5 text-orange-600"></i>
                                新機能
                            </h4>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2 bg-white p-2 rounded">
                                    <span class="text-orange-600 font-bold">NEW</span>
                                    <div>
                                        <strong>移動平均線</strong>
                                        <p class="text-xs text-gray-600 mt-1">一定期間の平均値を線で表示し、ノイズを除去してトレンドを明確に把握できます。3日/5日/7日/14日/30日から選択可能。</p>
                                    </div>
                                </li>
                                <li class="flex items-start gap-2 bg-white p-2 rounded">
                                    <span class="text-orange-600 font-bold">NEW</span>
                                    <div>
                                        <strong>複数指標の重ね合わせ</strong>
                                        <p class="text-xs text-gray-600 mt-1">最大3つの指標を1つのグラフに表示し、相関関係を分析できます。例: LBMと総合スコアの関係を確認。</p>
                                    </div>
                                </li>
                                <li class="flex items-start gap-2 bg-white p-2 rounded">
                                    <span class="text-green-600 font-bold">強化</span>
                                    <div>
                                        <strong>目標ライン表示</strong>
                                        <p class="text-xs text-gray-600 mt-1">各指標に目標値を設定すると、グラフに緑色の点線で表示されます。達成度が一目瞭然。</p>
                                    </div>
                                </li>
                                <li class="flex items-start gap-2 bg-white p-2 rounded">
                                    <span class="text-green-600 font-bold">強化</span>
                                    <div>
                                        <strong>メモ機能</strong>
                                        <p class="text-xs text-gray-600 mt-1">グラフ上のポイントをクリックしてメモを追加。チートデイ、体調不良などを記録し、データとの相関を確認できます。</p>
                                    </div>
                                </li>
                            </ul>
                        </div>

                        <!-- ヒント -->
                        <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="lightbulb" class="w-5 h-5 text-yellow-600"></i>
                                活用ヒント
                            </h4>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>短期（7日間）で細かい変化を確認し、長期（30-90日間）で全体的なトレンドを把握しましょう</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>比較モードで短期と長期を並べて表示すると、一時的な変動と本当のトレンドを区別できます</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>Y軸範囲を調整することで、小さな変化も大きく表示でき、微細なトレンドを発見できます</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>移動平均線（7日）を表示すると、日々の変動に惑わされず、本当のトレンドが見えてきます</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>複数指標を重ね合わせて、因果関係を発見しましょう（例: 体重とカロリーの関係）</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>AI分析は定期的に実行し、客観的なフィードバックを受けることで改善につなげましょう</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>グラフにメモ（📝）を追加して、特別な日（チートデイ、風邪など）を記録できます</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ツールチップ -->
        <div id="tooltip" class="tooltip"></div>

        <!-- フローティング設定パネル -->
        <div id="settings-panel" class="floating-panel hidden">
            <div class="sticky top-0 bg-gradient-to-r from-gray-700 to-gray-600 text-white p-4 rounded-t-xl">
                <div class="flex justify-between items-center">
                    <div class="flex items-center gap-2">
                        <i data-lucide="settings" class="w-5 h-5"></i>
                        <h3 class="text-lg font-bold">グラフ設定</h3>
                    </div>
                    <button type="button" onclick="closeSettingsPanel()" class="p-1 hover:bg-white/20 rounded">
                        <i data-lucide="x" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>

            <div class="p-4 space-y-6">
                <!-- アクションボタン -->
                <div class="grid grid-cols-2 gap-2">
                    <button type="button" onclick="openGoalSettingModal(); closeSettingsPanel();" class="flex items-center justify-center gap-2 px-4 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600 transition font-semibold text-sm">
                        <i data-lucide="target" class="w-4 h-4"></i>
                        目標設定
                    </button>
                    <button type="button" onclick="openHelpModal(); closeSettingsPanel();" class="flex items-center justify-center gap-2 px-4 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition font-semibold text-sm">
                        <i data-lucide="help-circle" class="w-4 h-4"></i>
                        使い方
                    </button>
                </div>

                <!-- カスタム期間設定 -->
                <div>
                    <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="calendar" class="w-4 h-4 text-indigo-600"></i>
                        カスタム期間
                    </h4>
                    <div class="space-y-2">
                        <div>
                            <label class="text-xs text-gray-600 block mb-1">開始日</label>
                            <input type="text" id="custom-start-panel" placeholder="開始日を選択" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                        </div>
                        <div>
                            <label class="text-xs text-gray-600 block mb-1">終了日</label>
                            <input type="text" id="custom-end-panel" placeholder="終了日を選択" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                        </div>
                        <button type="button" onclick="applyCustomPeriodFromPanel()" class="w-full px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition font-semibold text-sm">
                            適用
                        </button>
                    </div>
                </div>

                <!-- Y軸範囲設定 -->
                <div>
                    <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="sliders-horizontal" class="w-4 h-4 text-green-600"></i>
                        Y軸範囲
                    </h4>
                    <div class="space-y-2">
                        <div>
                            <label class="text-xs text-gray-600 block mb-1">最小値</label>
                            <input type="number" id="axis-min-panel" step="0.1" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent" onchange="updateAxisRangeFromPanel()">
                        </div>
                        <div>
                            <label class="text-xs text-gray-600 block mb-1">最大値</label>
                            <input type="number" id="axis-max-panel" step="0.1" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent" onchange="updateAxisRangeFromPanel()">
                        </div>
                        <button type="button" onclick="resetAxisRangeFromPanel()" class="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition font-semibold text-sm">
                            初期値に戻す
                        </button>
                    </div>
                </div>

                <!-- 表示オプション -->
                <div>
                    <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="eye" class="w-4 h-4 text-purple-600"></i>
                        表示オプション
                    </h4>
                    <div class="space-y-3">
                        <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                            <div class="flex items-center gap-2">
                                <i data-lucide="columns-2" class="w-4 h-4 text-blue-600"></i>
                                <label for="comparison-mode-panel" class="text-sm font-semibold text-gray-700">比較モード</label>
                            </div>
                            <input type="checkbox" id="comparison-mode-panel" class="w-4 h-4" onchange="toggleComparisonMode()">
                        </div>
                        <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                            <div class="flex items-center gap-2">
                                <i data-lucide="refresh-cw" class="w-4 h-4 text-purple-600"></i>
                                <label for="sync-axis-panel" class="text-sm font-semibold text-gray-700">Y軸連動</label>
                            </div>
                            <input type="checkbox" id="sync-axis-panel" class="w-4 h-4" checked onchange="toggleAxisSync()">
                        </div>
                        <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                            <div class="flex items-center gap-2">
                                <i data-lucide="trending-up" class="w-4 h-4 text-orange-600"></i>
                                <label for="moving-average-panel" class="text-sm font-semibold text-gray-700">移動平均線</label>
                            </div>
                            <input type="checkbox" id="moving-average-panel" class="w-4 h-4" onchange="toggleMovingAverage(1)">
                        </div>
                        <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                            <div class="flex items-center gap-2">
                                <i data-lucide="arrow-right" class="w-4 h-4 text-green-600"></i>
                                <label for="prediction-panel" class="text-sm font-semibold text-gray-700">予測線（7日先）</label>
                            </div>
                            <input type="checkbox" id="prediction-panel" class="w-4 h-4" onchange="togglePrediction(1)">
                        </div>
                    </div>
                </div>

                <!-- 移動平均期間 -->
                <div>
                    <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="calendar" class="w-4 h-4 text-indigo-600"></i>
                        移動平均期間
                    </h4>
                    <div class="space-y-2">
                        <select id="ma-period-panel" onchange="changeMovingAveragePeriod(1, this.value)" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                            <option value="3">3日</option>
                            <option value="5">5日</option>
                            <option value="7" selected>7日</option>
                            <option value="14">14日</option>
                            <option value="30">30日</option>
                        </select>
                    </div>
                </div>

                <!-- 下グラフのカテゴリ選択 -->
                <div>
                    <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="bar-chart-2" class="w-4 h-4 text-blue-600"></i>
                        下グラフのカテゴリ
                    </h4>
                    <div class="space-y-2">
                        <select id="chart2-category-panel" onchange="changeChart2Category(this.value)" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <option value="lbm" selected>💪 LBM - 除脂肪体重</option>
                            <option value="directive">📋 指示書達成状況</option>
                            <option value="overall">🎯 総合分析スコア</option>
                        </select>
                        <p class="text-xs text-gray-500">比較モードON時、上グラフと異なる指標を表示できます</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 目標設定モーダル -->
        <div id="goal-setting-modal" class="modal">
            <div class="modal-content">
                <div class="sticky top-0 bg-gradient-to-r from-green-600 to-teal-600 text-white p-4 rounded-t-lg">
                    <div class="flex justify-between items-center">
                        <div class="flex items-center gap-2">
                            <i data-lucide="target" class="w-5 h-5"></i>
                            <h3 class="text-lg font-bold">目標設定</h3>
                        </div>
                        <button type="button" onclick="closeGoalSettingModal()" class="p-1 hover:bg-white/20 rounded">
                            <i data-lucide="x" class="w-5 h-5"></i>
                        </button>
                    </div>
                </div>
                <div class="p-6">
                    <div class="space-y-4">
                        <!-- 指標選択 -->
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">目標を設定する指標</label>
                            <select id="goal-metric" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent">
                                <option value="lbm">💪 LBM - 除脂肪体重</option>
                                <option value="overall">🎯 総合分析スコア</option>
                            </select>
                        </div>

                        <!-- 目標値 -->
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">目標値</label>
                            <div class="flex items-center gap-2">
                                <input type="number" id="goal-value" step="0.1" placeholder="例: 65.0" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent">
                                <span id="goal-unit" class="text-gray-600 font-semibold">kg</span>
                            </div>
                        </div>

                        <!-- 達成予定日 -->
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">達成予定日（任意）</label>
                            <input type="date" id="goal-date" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent">
                        </div>

                        <!-- グラフに表示するか -->
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="goal-show-line" checked class="w-4 h-4">
                            <label for="goal-show-line" class="text-sm font-semibold text-gray-700">グラフに目標ラインを表示</label>
                        </div>

                        <!-- 現在の目標 -->
                        <div id="current-goal-info" class="bg-blue-50 p-4 rounded-lg border border-blue-200 hidden">
                            <h4 class="text-sm font-bold text-blue-700 mb-2">現在の目標</h4>
                            <div id="current-goal-text" class="text-sm text-gray-700"></div>
                        </div>

                        <!-- ボタン -->
                        <div class="flex gap-3">
                            <button type="button" onclick="saveGoal()" class="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition flex items-center justify-center gap-2 font-semibold">
                                <i data-lucide="check" class="w-4 h-4"></i>
                                目標を保存
                            </button>
                            <button type="button" onclick="clearGoal()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition font-semibold">
                                クリア
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- ドリルダウンモーダル -->
    <div id="drilldown-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden" onclick="closeDrillDownModal()">
        <div class="bg-white rounded-lg shadow-2xl w-11/12 max-w-2xl max-h-[90vh] overflow-y-auto" onclick="event.stopPropagation()">
            <!-- モーダルヘッダー -->
            <div class="sticky top-0 bg-gradient-to-r from-purple-600 to-blue-600 text-white p-4 rounded-t-lg flex items-center justify-between z-10">
                <div class="flex items-center gap-3">
                    <i data-lucide="calendar" class="w-6 h-6"></i>
                    <div>
                        <h3 class="text-xl font-bold" id="drilldown-title">詳細情報</h3>
                        <p class="text-sm opacity-90" id="drilldown-subtitle">日付と値</p>
                    </div>
                </div>
                <button type="button" onclick="closeDrillDownModal()" class="p-2 hover:bg-white hover:bg-opacity-20 rounded-full transition">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>

            <!-- モーダルコンテンツ -->
            <div class="p-6">
                <!-- メトリクス情報 -->
                <div class="bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg p-4 mb-4 border border-purple-200">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-sm text-gray-600 mb-1">指標</p>
                            <p class="text-2xl font-bold text-purple-700" id="drilldown-metric"></p>
                        </div>
                        <div class="text-right">
                            <p class="text-sm text-gray-600 mb-1">値</p>
                            <p class="text-3xl font-bold text-blue-700" id="drilldown-value"></p>
                        </div>
                    </div>
                </div>

                <!-- メモセクション -->
                <div class="bg-gray-50 rounded-lg p-4 mb-4">
                    <h4 class="font-semibold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="message-square" class="w-4 h-4 text-orange-600"></i>
                        メモ
                    </h4>
                    <div id="drilldown-memo-display" class="mb-3 hidden">
                        <div class="bg-white p-3 rounded border border-gray-200">
                            <p class="text-sm text-gray-700" id="drilldown-memo-text"></p>
                        </div>
                    </div>
                    <div id="drilldown-memo-empty" class="text-sm text-gray-500 italic mb-3">
                        このデータポイントにはメモがありません
                    </div>
                    <button type="button"
                        onclick="toggleMemoEdit()"
                        class="text-sm px-3 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition flex items-center gap-2">
                        <i data-lucide="edit" class="w-4 h-4"></i>
                        <span id="memo-edit-button-text">メモを追加</span>
                    </button>
                    <div id="drilldown-memo-edit" class="mt-3 hidden">
                        <textarea
                            id="drilldown-memo-input"
                            rows="3"
                            placeholder="メモを入力してください（例: チートデイ、体調不良など）"
                            class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-orange-500"></textarea>
                        <div class="flex gap-2 mt-2">
                            <button type="button"
                                onclick="saveMemo()"
                                class="flex-1 px-3 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition text-sm font-semibold">
                                保存
                            </button>
                            <button type="button"
                                onclick="deleteMemo()"
                                class="px-3 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition text-sm font-semibold">
                                削除
                            </button>
                            <button type="button"
                                onclick="toggleMemoEdit()"
                                class="px-3 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition text-sm font-semibold">
                                キャンセル
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 関連データ（将来の拡張用） -->
                <div class="bg-blue-50 rounded-lg p-4">
                    <h4 class="font-semibold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="info" class="w-4 h-4 text-blue-600"></i>
                        この日の情報
                    </h4>
                    <p class="text-sm text-gray-600">
                        より詳細な情報（食事、トレーニングなど）は、メインアプリの「履歴」タブから確認できます。
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Lucideアイコン初期化
        lucide.createIcons();

        let currentMainCategory = 'performance';
        let currentSubCategory = 'lbm';
        let comparisonMode = false;
        let axisSync = true; // Y軸連動ON/OFF
        let charts = { 1: null, 2: null };
        let currentPeriods = { 1: 7, 2: 30 };
        let currentAxisRanges = { 1: { min: null, max: null }, 2: { min: null, max: null } };
        let globalMinMax = { min: 0, max: 100 }; // 全期間の最低値・最大値
        let currentData = { 1: [], 2: [] };
        let goals = {}; // 目標データ（LocalStorageから読み込み）
        let annotations = {}; // アノテーション（メモ）データ
        let showMovingAverage = { 1: false, 2: false }; // 移動平均線表示
        let selectedDataIndex = { 1: null, 2: null }; // 選択されたデータポイントのインデックス
        let movingAveragePeriod = { 1: 7, 2: 7 }; // 移動平均の期間
        let showPrediction = { 1: false, 2: false }; // 予測線表示
        let chart2Category = 'lbm'; // Chart2の表示カテゴリ

        // ドリルダウンモーダル用の変数
        let currentDrillDownData = {
            chartNum: null,
            index: null,
            label: null,
            value: null,
            metric: null,
            annotationKey: null
        };

        // クロスヘア用の変数
        let crosshairPosition = { x: null, y: null };
        let showCrosshair = false;

        // 閃きメモデータを保存する変数（日付 -> メモのマップ）
        let dailyNotes = {};

        // Gemini API設定（デモ用 - 実際はconfig.jsから取得）
        const GEMINI_API_KEY = 'YOUR_API_KEY_HERE';
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent';

        // 指標の日本語名とメタ情報
        const metricInfo = {
            // パフォーマンス
            lbm: { name: 'LBM - 除脂肪体重', unit: 'kg', category: 'performance' },
            directive: { name: '指示書達成状況', unit: '', isBinary: true, category: 'performance' },
            overall: { name: '総合分析スコア', unit: '点', category: 'performance' },

            // 食事
            calories: { name: '摂取カロリー', unit: 'kcal', category: 'nutrition' },
            protein: { name: 'タンパク質', unit: 'g', category: 'nutrition' },
            fat: { name: '脂質', unit: 'g', category: 'nutrition' },
            carbs: { name: '炭水化物', unit: 'g', category: 'nutrition' },
            sugar: { name: '糖質', unit: 'g', category: 'nutrition' },
            fiber: { name: '食物繊維', unit: 'g', category: 'nutrition' },
            vitamin_score: { name: 'ビタミン達成率', unit: '%', category: 'nutrition' },
            mineral_score: { name: 'ミネラル達成率', unit: '%', category: 'nutrition' },

            // 運動
            total_time: { name: '総時間', unit: '分', category: 'training', icon: '⏱️' },
            total_exercises: { name: '総種目数', unit: '種目', category: 'training', icon: '🏋️' },
            total_weight: { name: '総重量', unit: 'kg', category: 'training', icon: '💪' },

            // コンディション
            sleep_duration: { name: '睡眠時間', unit: '時間', category: 'condition' },
            sleep_quality: { name: '睡眠の質', unit: '点', category: 'condition' },
            appetite: { name: '食欲', unit: '点', category: 'condition' },
            gut_health: { name: '腸内環境', unit: '点', category: 'condition' },
            focus: { name: '集中力', unit: '点', category: 'condition' },
            stress: { name: 'ストレス', unit: '点', category: 'condition' }
        };

        // 実際のデータを読み込む関数
        async function loadRealData() {
            const userId = window.currentUser?.uid || 'demo_user';
            const allData = {
                // パフォーマンス
                lbm: [],
                directive: [],
                overall: [],
                // 食事
                calories: [],
                protein: [],
                fat: [],
                carbs: [],
                sugar: [],
                fiber: [],
                vitamin_score: [],
                mineral_score: [],
                // 運動
                total_time: [],
                total_exercises: [],
                total_weight: [],
                rm: {}, // 回数×種目別のRM記録
                // コンディション
                sleep_duration: [],
                sleep_quality: [],
                appetite: [],
                gut_health: [],
                focus: [],
                stress: []
            };

            // 全期間のデータを取得（過去50年分 = 約18,250日）
            for (let i = 18249; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                const dateStr = date.toISOString().split('T')[0];

                let record = null;
                if (typeof DataService !== 'undefined') {
                    record = await DataService.getDailyRecord(userId, dateStr);
                }

                if (record) {
                    // 食事データ - mealsから集計
                    const meals = record.meals || [];
                    let totalCalories = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0, totalSugar = 0, totalFiber = 0;
                    meals.forEach(meal => {
                        totalCalories += meal.calories || 0;
                        // meal.itemsから詳細な栄養素を集計
                        (meal.items || []).forEach(item => {
                            totalProtein += item.protein || 0;
                            totalFat += item.fat || 0;
                            totalCarbs += item.carbs || 0;
                            totalSugar += item.sugar || 0;
                            totalFiber += item.fiber || 0;
                        });
                    });
                    allData.calories.push(totalCalories);
                    allData.protein.push(totalProtein);
                    allData.fat.push(totalFat);
                    allData.carbs.push(totalCarbs);
                    allData.sugar.push(totalSugar);
                    allData.fiber.push(totalFiber);

                    // ビタミン・ミネラル達成率（仮計算 - 実装に応じて調整）
                    allData.vitamin_score.push(record.vitaminScore || 0);
                    allData.mineral_score.push(record.mineralScore || 0);

                    // 運動データ - workoutsから集計
                    const workouts = record.workouts || [];
                    let totalTime = 0, totalExercises = workouts.length, totalWeight = 0;
                    const rmData = {}; // 回数×種目別のRMデータ

                    workouts.forEach(workout => {
                        totalTime += workout.duration || 0;
                        const exerciseName = workout.name || 'unknown';

                        (workout.sets || []).forEach(set => {
                            const weight = set.weight || 0;
                            const reps = set.reps || 0;
                            totalWeight += weight * reps;

                            // 回数×種目別にRM記録を保存
                            if (reps > 0 && weight > 0) {
                                const key = `${reps}_${exerciseName}`;
                                rmData[key] = Math.max(rmData[key] || 0, weight);
                            }
                        });
                    });
                    allData.total_time.push(totalTime);
                    allData.total_exercises.push(totalExercises);
                    allData.total_weight.push(totalWeight);

                    // RM記録を保存（すべての回数×種目の組み合わせ）
                    for (const key in rmData) {
                        if (!allData.rm) allData.rm = {};
                        if (!allData.rm[key]) allData.rm[key] = [];
                        allData.rm[key].push(rmData[key]);
                    }
                    // この日に記録がないRM種目には0を追加
                    if (allData.rm) {
                        for (const key in allData.rm) {
                            if (!rmData[key]) {
                                allData.rm[key].push(0);
                            }
                        }
                    }

                    // コンディションデータ - conditionsから取得
                    const conditions = record.conditions || {};
                    allData.sleep_duration.push(conditions.sleepHours || 0);
                    allData.sleep_quality.push(conditions.sleepQuality || 0);
                    allData.appetite.push(conditions.appetite || 0);
                    allData.gut_health.push(conditions.digestion || 0);
                    allData.focus.push(conditions.focus || 0);
                    allData.stress.push(conditions.stress || 0);

                    // パフォーマンスデータ
                    const weight = conditions.weight || 0;
                    const bodyFat = conditions.bodyFatPercentage || 0;
                    const lbm = weight > 0 && bodyFat > 0 ? weight * (1 - bodyFat / 100) : 0;
                    allData.lbm.push(lbm);

                    allData.directive.push(record.directiveCompleted ? 1 : 0);
                    allData.overall.push(record.overallScore || 0);

                    // 閃きメモを保存
                    if (record.notes && record.notes.trim()) {
                        dailyNotes[dateStr] = record.notes.trim();
                    }
                } else {
                    // データがない場合は0を追加
                    Object.keys(allData).forEach(key => {
                        if (key === 'rm') {
                            // rmは特殊処理（オブジェクト型）
                            for (const rmKey in allData.rm) {
                                allData.rm[rmKey].push(0);
                            }
                        } else if (Array.isArray(allData[key])) {
                            allData[key].push(0);
                        }
                    });
                }
            }

            return allData;
        }

        // グローバルデータ（実データで上書きされる）
        let allData = {
            // パフォーマンス
            lbm: [],
            directive: [],
            overall: [],
            // 食事
            calories: [],
            protein: [],
            fat: [],
            carbs: [],
            sugar: [],
            fiber: [],
            vitamin_score: [],
            mineral_score: [],
            // 運動
            total_time: [],
            total_exercises: [],
            total_weight: [],
            rm: {}, // 回数×種目別のRM記録（動的に追加）
            // コンディション
            sleep_duration: [],
            sleep_quality: [],
            appetite: [],
            gut_health: [],
            focus: [],
            stress: []
        };

        // 全期間の最低値・最大値を計算
        function calculateGlobalMinMax(metric) {
            const data = allData[metric];
            const info = metricInfo[metric];

            // データまたはメトリック情報がない場合はデフォルト値を返す
            if (!data || !info) {
                console.warn(`No data or metric info for: ${metric}`);
                return { min: 0, max: 10 };
            }

            // 配列チェック
            if (!Array.isArray(data)) {
                console.warn(`Data for ${metric} is not an array`);
                return { min: 0, max: 10 };
            }

            if (data.length === 0) {
                return { min: 0, max: 10 };
            }

            // 指示書（バイナリデータ）は0-1固定
            if (info.isBinary) {
                return { min: 0, max: 1 };
            }

            // 有効な数値のみをフィルタ
            const validData = data.filter(v => typeof v === 'number' && !isNaN(v) && v > 0);

            if (validData.length === 0) {
                return { min: 0, max: 10 };
            }

            const min = Math.min(...validData);
            const max = Math.max(...validData);
            const range = max - min;

            // マージンを大きめに設定（20%）して、数値が見切れないようにする
            const margin = Math.max(range * 0.2, 0.5); // 最低でも0.5のマージン

            return {
                min: Math.floor((min - margin) * 10) / 10,
                max: Math.ceil((max + margin) * 10) / 10
            };
        }

        // 指定期間のデータを取得
        function generateData(days) {
            const result = {};
            // すべての指標のデータを返す
            for (const key in allData) {
                if (key === 'rm') {
                    // rmは特殊処理（オブジェクト型）
                    result[key] = allData[key];
                } else if (Array.isArray(allData[key])) {
                    result[key] = allData[key].slice(-days);
                }
            }
            return result;
        }

        // 指定期間のデータを取得
        function getDataForPeriod(category, period) {
            if (!allData[category]) {
                return null;
            }
            return allData[category].slice(-period);
        }

        // ラベル生成
        function generateLabels(days) {
            if (days <= 7) {
                // 7日以内: 数字のみ（単位は表示時に追加）
                const labels = Array.from({ length: days }, (_, i) => `${days - i}`);
                return labels;
            } else if (days <= 30) {
                // 30日以内: 数字のみ（単位は表示時に追加）
                const labels = Array.from({ length: days }, (_, i) => `${days - i}`);
                return labels;
            } else {
                // 30日以上: 数字のみ（単位は表示時に追加）
                const labels = Array.from({ length: days }, (_, i) => `${days - i}`);
                return labels;
            }
        }

        // 移動平均を計算
        function calculateMovingAverage(data, period) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    result.push(null); // 最初の数日は計算できない
                } else {
                    const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                    result.push(sum / period);
                }
            }
            return result;
        }

        // 線形回帰で予測線を計算
        function calculatePrediction(data, futureDays = 7) {
            const validData = data.filter(v => v > 0);
            if (validData.length < 3) return [];

            // 線形回帰の計算
            const n = validData.length;
            const indices = Array.from({ length: n }, (_, i) => i);
            const sumX = indices.reduce((a, b) => a + b, 0);
            const sumY = validData.reduce((a, b) => a + b, 0);
            const sumXY = indices.reduce((sum, x, i) => sum + x * validData[i], 0);
            const sumX2 = indices.reduce((sum, x) => sum + x * x, 0);

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            // 予測値を計算
            const predictions = [];
            for (let i = 0; i < data.length + futureDays; i++) {
                predictions.push(slope * i + intercept);
            }

            return predictions;
        }

        // 移動平均線の表示切替
        function toggleMovingAverage(chartNum) {
            showMovingAverage[chartNum] = !showMovingAverage[chartNum];
            updateChart(chartNum);
        }

        // 移動平均の期間を変更
        function changeMovingAveragePeriod(chartNum, period) {
            movingAveragePeriod[chartNum] = parseInt(period);
            if (showMovingAverage[chartNum]) {
                updateChart(chartNum);
            }
        }

        // 予測線の表示切替
        function togglePrediction(chartNum) {
            showPrediction[chartNum] = !showPrediction[chartNum];
            updateChart(chartNum);
        }

        // Chart2のカテゴリを変更
        function changeChart2Category(category) {
            chart2Category = category;
            currentSubCategory = category;
            updateChart(2);
        }

        // Y軸連動のON/OFF切替
        function toggleAxisSync() {
            // パネルまたはメイン画面のチェックボックスから状態を取得
            const syncAxisPanelElement = document.getElementById('sync-axis-panel');
            const syncAxisElement = document.getElementById('sync-axis');

            // パネルの要素があればそちらを使用、なければメインの要素を使用
            const checkboxElement = syncAxisPanelElement || syncAxisElement;
            if (!checkboxElement) {
                console.warn('Y軸連動要素が見つかりません');
                return;
            }

            axisSync = checkboxElement.checked;

            // 両方のチェックボックスを同期
            if (syncAxisPanelElement) syncAxisPanelElement.checked = axisSync;
            if (syncAxisElement) syncAxisElement.checked = axisSync;

            const icon = document.querySelector('.sync-icon');

            if (axisSync) {
                // ONになったら、グラフ1の値をグラフ2に反映
                if (icon) {
                    icon.classList.add('syncing');
                    setTimeout(() => icon.classList.remove('syncing'), 1000);
                }

                if (comparisonMode && currentAxisRanges[1].min !== null) {
                    const axisMin2Element = document.getElementById('axis-min-2');
                    const axisMax2Element = document.getElementById('axis-max-2');

                    currentAxisRanges[2] = { ...currentAxisRanges[1] };
                    if (axisMin2Element) axisMin2Element.value = currentAxisRanges[1].min;
                    if (axisMax2Element) axisMax2Element.value = currentAxisRanges[1].max;
                    updateChart(2);
                }
            }

            lucide.createIcons();
        }

        // Gemini分析（親ウィンドウへメッセージ送信）
        // ローカル傾向調査（現在表示中の期間を使用）
        function showLocalTrendAnalysis() {
            const metric = metricInfo[currentSubCategory];
            const period = currentPeriods[1]; // 現在表示中の期間
            const data = currentData[1]; // 現在表示中のデータ

            if (!data || data.length === 0) {
                alert(`データがありません`);
                return;
            }

            // データの統計情報を計算
            const avg = (data.reduce((a, b) => a + b, 0) / data.length).toFixed(1);
            const max = Math.max(...data).toFixed(1);
            const min = Math.min(...data).toFixed(1);
            const trend = (data[data.length - 1] - data[0]).toFixed(1);
            const trendPercent = ((trend / data[0]) * 100).toFixed(1);
            const stdDev = calculateStdDev(data).toFixed(1);

            // トレンド判定
            let trendLabel = '横ばい';
            let trendIcon = '→';
            let trendColor = 'text-gray-600';
            if (Math.abs(parseFloat(trendPercent)) < 5) {
                trendLabel = '横ばい';
                trendIcon = '→';
                trendColor = 'text-gray-600';
            } else if (parseFloat(trend) > 0) {
                trendLabel = '増加傾向';
                trendIcon = '↑';
                trendColor = 'text-green-600';
            } else {
                trendLabel = '減少傾向';
                trendIcon = '↓';
                trendColor = 'text-red-600';
            }

            // モーダル表示
            const periodLabel = period === 365 ? '1年間' : `${period}日間`;
            const modalHTML = `
                <div class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4" onclick="this.remove()">
                    <div class="bg-white rounded-2xl w-full max-w-md p-6" onclick="event.stopPropagation()">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-bold flex items-center gap-2">
                                <i data-lucide="bar-chart-2" class="w-5 h-5 text-blue-600"></i>
                                傾向調査：${metric.name}
                            </h3>
                            <button onclick="this.closest('.fixed').remove()" class="p-2 hover:bg-gray-100 rounded-full">
                                <i data-lucide="x" class="w-5 h-5"></i>
                            </button>
                        </div>
                        <div class="space-y-4">
                            <div class="p-3 bg-blue-50 rounded-lg border border-blue-200">
                                <div class="text-sm font-semibold text-blue-900 mb-1">期間</div>
                                <div class="text-lg font-bold text-blue-700">過去${periodLabel}</div>
                            </div>
                            <div class="grid grid-cols-2 gap-3">
                                <div class="p-3 bg-gray-50 rounded-lg">
                                    <div class="text-xs text-gray-600 mb-1">平均値</div>
                                    <div class="text-lg font-bold">${avg}${metric.unit}</div>
                                </div>
                                <div class="p-3 bg-gray-50 rounded-lg">
                                    <div class="text-xs text-gray-600 mb-1">標準偏差</div>
                                    <div class="text-lg font-bold">${stdDev}${metric.unit}</div>
                                </div>
                                <div class="p-3 bg-green-50 rounded-lg border border-green-200">
                                    <div class="text-xs text-green-700 mb-1">最高値</div>
                                    <div class="text-lg font-bold text-green-800">${max}${metric.unit}</div>
                                </div>
                                <div class="p-3 bg-red-50 rounded-lg border border-red-200">
                                    <div class="text-xs text-red-700 mb-1">最低値</div>
                                    <div class="text-lg font-bold text-red-800">${min}${metric.unit}</div>
                                </div>
                            </div>
                            <div class="p-4 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200">
                                <div class="text-sm font-semibold text-purple-900 mb-2">トレンド</div>
                                <div class="flex items-center gap-3">
                                    <span class="text-3xl ${trendColor}">${trendIcon}</span>
                                    <div>
                                        <div class="text-lg font-bold ${trendColor}">${trendLabel}</div>
                                        <div class="text-sm text-gray-600">
                                            ${trend > 0 ? '+' : ''}${trend}${metric.unit} (${trendPercent}%)
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            lucide.createIcons();
        }

        // 標準偏差計算
        function calculateStdDev(values) {
            const avg = values.reduce((a, b) => a + b, 0) / values.length;
            const squareDiffs = values.map(value => Math.pow(value - avg, 2));
            const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
            return Math.sqrt(avgSquareDiff);
        }

        async function analyzeWithGemini() {
            console.log('[AI分析] ボタンクリック');
            console.log('currentSubCategory:', currentSubCategory);
            console.log('currentMainCategory:', currentMainCategory);

            // 現在のカテゴリとデータを取得
            const metric = metricInfo[currentSubCategory];
            const data1 = currentData[1];
            const period1 = currentPeriods[1];

            console.log('data1:', data1);
            console.log('data1 length:', data1 ? data1.length : 'undefined');

            // データの存在確認
            if (!data1 || data1.length === 0) {
                console.error('[AI分析] データが空です');
                alert('分析するデータがありません。記録を追加してから再度お試しください。');
                return;
            }

            // データの統計情報を計算
            const avg = (data1.reduce((a, b) => a + b, 0) / data1.length).toFixed(1);
            const max = Math.max(...data1).toFixed(1);
            const min = Math.min(...data1).toFixed(1);
            const trend = (data1[data1.length - 1] - data1[0]).toFixed(1);
            const trendPercent = data1[0] !== 0 ? ((trend / data1[0]) * 100).toFixed(1) : '0.0';

            console.log('[AI分析] 統計情報:', { avg, max, min, trend, trendPercent });

            // 親ウィンドウ（React）にメッセージを送信
            console.log('[AI分析] postMessage送信');
            window.parent.postMessage({
                type: 'REQUEST_AI_ANALYSIS',
                category: currentMainCategory,
                subCategory: currentSubCategory,
                metricInfo: metric,
                data: data1,
                period: period1,
                stats: {
                    avg: avg,
                    max: max,
                    min: min,
                    trend: trend,
                    trendPercent: trendPercent
                }
            }, '*');
        }

        // ヘルプモーダル
        function openHelpModal() {
            document.getElementById('help-modal').classList.add('show');
            lucide.createIcons();
        }

        function closeHelpModal() {
            document.getElementById('help-modal').classList.remove('show');
        }

        // ツールチップ
        const tooltipContent = {
            comparison: `
                <div class="text-sm">
                    <div class="font-bold text-blue-600 mb-2">比較モードとは？</div>
                    <p class="mb-2">2つのグラフを同時に表示し、異なる期間のデータを比較できます。</p>
                    <div class="font-semibold mb-1">使い方:</div>
                    <ul class="text-xs space-y-1 pl-4">
                        <li>• チェックをONにすると下にグラフが追加表示</li>
                        <li>• 上下で異なる期間を選択可能（例: 7日 vs 30日）</li>
                        <li>• 短期と長期のトレンド比較に最適</li>
                    </ul>
                </div>
            `,
            sync: `
                <div class="text-sm">
                    <div class="font-bold text-purple-600 mb-2">Y軸連動とは？</div>
                    <p class="mb-2">上のグラフのY軸範囲を変更すると、下のグラフも自動で同じ範囲に調整される機能です。</p>
                    <div class="font-semibold mb-1">メリット:</div>
                    <ul class="text-xs space-y-1 pl-4">
                        <li>• 同じスケールで比較できる</li>
                        <li>• 数値の大小を直感的に比較</li>
                        <li>• ワンクリックでON/OFF切替可能</li>
                    </ul>
                </div>
            `
        };

        let tooltipTimeout;
        function showTooltip(event, type) {
            clearTimeout(tooltipTimeout);
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = tooltipContent[type];
            tooltip.classList.add('show');

            // 位置調整
            const rect = event.target.getBoundingClientRect();
            tooltip.style.position = 'fixed';
            tooltip.style.left = rect.left + 'px';
            tooltip.style.top = (rect.bottom + 10) + 'px';
        }

        function hideTooltip() {
            tooltipTimeout = setTimeout(() => {
                document.getElementById('tooltip').classList.remove('show');
            }, 200);
        }

        // 比較モード切り替え
        function toggleComparisonMode() {
            // パネルまたはメイン画面のチェックボックスから状態を取得
            const comparisonModePanelElement = document.getElementById('comparison-mode-panel');
            const comparisonModeElement = document.getElementById('comparison-mode');
            const chart2Element = document.getElementById('chart-2');

            if (!chart2Element) {
                console.warn('Chart 2要素が見つかりません');
                return;
            }

            // パネルの要素があればそちらを使用、なければメインの要素を使用
            const checkboxElement = comparisonModePanelElement || comparisonModeElement;
            if (!checkboxElement) {
                console.warn('比較モード要素が見つかりません');
                return;
            }

            comparisonMode = checkboxElement.checked;

            // 両方のチェックボックスを同期
            if (comparisonModePanelElement) comparisonModePanelElement.checked = comparisonMode;
            if (comparisonModeElement) comparisonModeElement.checked = comparisonMode;

            chart2Element.classList.toggle('hidden', !comparisonMode);

            if (comparisonMode) {
                // 比較モードON時、Y軸連動がONなら同じ範囲を適用
                if (axisSync && currentAxisRanges[1].min !== null) {
                    const axisMin2Element = document.getElementById('axis-min-2');
                    const axisMax2Element = document.getElementById('axis-max-2');

                    currentAxisRanges[2] = { ...currentAxisRanges[1] };
                    if (axisMin2Element) axisMin2Element.value = currentAxisRanges[1].min;
                    if (axisMax2Element) axisMax2Element.value = currentAxisRanges[1].max;
                }
                updateChart(2);
                updateChart2PeriodButtons();
            }
        }

        // 大カテゴリ選択（デモ用 - 実際には各カテゴリのコンテンツを表示）
        function selectMainCategory(category, event) {
            currentMainCategory = category;

            // カテゴリごとの色設定（アプリと完全一致）
            const categoryColors = {
                nutrition: 'text-green-600',      // 食事: 緑
                training: 'text-orange-600',      // 運動: オレンジ
                condition: 'text-red-600',        // コンディション: 赤
                performance: 'text-purple-600',   // パフォーマンス: 紫
                insights: 'text-yellow-600'       // 閃き: 黄色
            };

            // タブのアクティブ状態を更新
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active', 'text-green-600', 'text-orange-600', 'text-red-600', 'text-purple-600', 'text-yellow-600', 'bg-white', 'border-b-0');
                btn.classList.add('text-gray-600');
            });

            const colorClass = categoryColors[category] || 'text-purple-600';
            // イベントが渡されている場合はevent.currentTargetを使用、それ以外は該当するボタンを検索
            const targetButton = event ? event.currentTarget : document.querySelector(`.tab-button[onclick*="${category}"]`);
            if (targetButton) {
                targetButton.classList.add('active', colorClass, 'bg-white', 'border-b-0');
                targetButton.classList.remove('text-gray-600');
            }

            // すべてのサブタブを非表示
            document.querySelectorAll('.sub-tabs').forEach(tab => {
                tab.classList.add('hidden');
            });

            // 閃きカテゴリの場合は特別処理
            if (category === 'insights') {
                // グラフエリアを非表示
                document.getElementById('graph-area').classList.add('hidden');
                // 閃きコンテンツを表示
                document.getElementById('insights-content').classList.remove('hidden');
                // 閃きメモリストを生成
                renderInsightsList();
            } else {
                // グラフエリアを表示
                document.getElementById('graph-area').classList.remove('hidden');
                // 閃きコンテンツを非表示
                document.getElementById('insights-content').classList.add('hidden');

                // 選択されたカテゴリのサブタブを表示
                const subtabs = document.getElementById(`${category}-subtabs`);
                if (subtabs) {
                    subtabs.classList.remove('hidden');
                }

                // 各カテゴリの最初の指標を選択
                const firstMetrics = {
                    nutrition: 'calories',
                    training: 'total_time',
                    condition: 'sleep_duration',
                    performance: 'lbm'
                };

                // 最初のサブカテゴリを選択
                if (firstMetrics[category]) {
                    selectSubCategory(category, firstMetrics[category]);
                }
            }

            // アイコンを再描画
            lucide.createIcons();
        }

        // 閃きメモリストを描画する関数
        function renderInsightsList() {
            const listContainer = document.getElementById('insights-list');
            listContainer.innerHTML = '';

            // dailyNotesを日付順にソート（新しい順）
            const sortedNotes = Object.entries(dailyNotes).sort((a, b) => {
                return new Date(b[0]) - new Date(a[0]);
            });

            if (sortedNotes.length === 0) {
                listContainer.innerHTML = `
                    <div class="text-center py-12">
                        <i data-lucide="lightbulb-off" class="w-16 h-16 text-gray-300 mx-auto mb-4"></i>
                        <p class="text-gray-500">閃きメモはまだありません</p>
                    </div>
                `;
                lucide.createIcons();
                return;
            }

            sortedNotes.forEach(([dateStr, note]) => {
                const date = new Date(dateStr);
                const dateDisplay = `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`;
                const dayOfWeek = ['日', '月', '火', '水', '木', '金', '土'][date.getDay()];

                const noteCard = document.createElement('div');
                noteCard.className = 'bg-yellow-50 border-l-4 border-yellow-500 rounded-lg p-4 hover:shadow-md transition';
                noteCard.innerHTML = `
                    <div class="flex items-start gap-3">
                        <i data-lucide="lightbulb" class="w-5 h-5 text-yellow-600 flex-shrink-0 mt-1"></i>
                        <div class="flex-1">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-sm font-bold text-gray-800">${dateDisplay} (${dayOfWeek})</span>
                            </div>
                            <p class="text-sm text-gray-700 whitespace-pre-wrap">${note}</p>
                        </div>
                    </div>
                `;
                listContainer.appendChild(noteCard);
            });

            lucide.createIcons();
        }

        // 期間選択
        function selectPeriod(chartNum, days) {
            currentPeriods[chartNum] = days;

            const container = chartNum === 1 ? document.getElementById('chart-1') : document.getElementById('chart-2');

            if (chartNum === 1) {
                // グラフ1: タブ式スタイル（透明背景＋アンダーライン）
                container.querySelectorAll('.period-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                if (event && event.currentTarget) {
                    event.currentTarget.classList.add('active');
                }
            } else {
                // グラフ2: ボタン式スタイル（背景色付き）
                container.querySelectorAll('.period-button').forEach(btn => {
                    btn.classList.remove('active', 'bg-purple-600', 'bg-blue-600', 'text-white', 'shadow-sm');
                    btn.classList.add('bg-white', 'text-gray-700', 'border', 'border-gray-300');
                });
                if (event && event.currentTarget) {
                    event.currentTarget.classList.add('active', 'bg-blue-600', 'text-white', 'shadow-sm');
                    event.currentTarget.classList.remove('bg-white', 'text-gray-700', 'border', 'border-gray-300');
                }
            }

            updateChart(chartNum);

            // グラフ1の期間が変更された場合、グラフ2の期間ボタンを更新
            if (chartNum === 1 && comparisonMode) {
                updateChart2PeriodButtons();
            }
        }

        // 期間範囲選択（今週、先週、今月、先月）
        function selectPeriodRange(chartNum, rangeType) {
            const today = new Date();
            let startDate, endDate, days;

            switch(rangeType) {
                case 'thisWeek':
                    // 今週（月曜日～日曜日）
                    const dayOfWeek = today.getDay();
                    const diffToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // 月曜を週の開始とする
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - diffToMonday);
                    endDate = today;
                    days = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
                    break;

                case 'lastWeek':
                    // 先週（先週の月曜日～日曜日）
                    const lastWeekEnd = new Date(today);
                    const daysToLastSunday = today.getDay() === 0 ? 0 : today.getDay();
                    lastWeekEnd.setDate(today.getDate() - daysToLastSunday);
                    startDate = new Date(lastWeekEnd);
                    startDate.setDate(lastWeekEnd.getDate() - 6);
                    days = 7;
                    break;

                case 'thisMonth':
                    // 今月（1日～今日）
                    startDate = new Date(today.getFullYear(), today.getMonth(), 1);
                    endDate = today;
                    days = today.getDate();
                    break;

                case 'lastMonth':
                    // 先月（先月の1日～末日）
                    const lastMonthDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    const lastMonthEnd = new Date(today.getFullYear(), today.getMonth(), 0);
                    days = lastMonthEnd.getDate();
                    break;
            }

            currentPeriods[chartNum] = days;

            // タブのアクティブ状態を更新（モバイル対応スタイル）
            const container = chartNum === 1 ? document.getElementById('chart-1') : document.getElementById('chart-2');
            const bgColor = chartNum === 1 ? 'bg-purple-600' : 'bg-blue-600';

            container.querySelectorAll('.period-button').forEach(btn => {
                btn.classList.remove('active', 'bg-purple-600', 'bg-blue-600', 'text-white', 'shadow-sm');
                btn.classList.add('bg-white', 'text-gray-700', 'border', 'border-gray-300');
            });
            if (event && event.currentTarget) {
                event.currentTarget.classList.add('active', bgColor, 'text-white', 'shadow-sm');
                event.currentTarget.classList.remove('bg-white', 'text-gray-700', 'border', 'border-gray-300');
            }

            updateChart(chartNum);

            // グラフ1の期間が変更された場合、グラフ2の期間ボタンを更新
            if (chartNum === 1 && comparisonMode) {
                updateChart2PeriodButtons();
            }
        }

        // グラフ2の期間ボタンを更新（グラフ1と同じ期間を無効化）
        function updateChart2PeriodButtons() {
            const chart2Container = document.getElementById('chart-2');
            const buttons = chart2Container.querySelectorAll('.period-button');

            buttons.forEach(btn => {
                const btnText = btn.textContent;
                const days = parseInt(btnText);

                if (days === currentPeriods[1]) {
                    btn.disabled = true;
                    btn.classList.add('opacity-50', 'cursor-not-allowed');
                    btn.onclick = null;
                } else {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50', 'cursor-not-allowed');
                    // onclick を復元
                    const dayValue = btnText === '7日間' ? 7 : btnText === '14日間' ? 14 : btnText === '30日間' ? 30 : 90;
                    btn.onclick = () => selectPeriod(2, dayValue);
                }
            });
        }

        // Y軸レンジをリセット
        function resetAxisRange(chartNum) {
            const axisMinElement = document.getElementById(`axis-min-${chartNum}`);
            const axisMaxElement = document.getElementById(`axis-max-${chartNum}`);

            if (axisMinElement && axisMaxElement) {
                axisMinElement.value = globalMinMax.min;
                axisMaxElement.value = globalMinMax.max;
                updateAxisRange(chartNum);
            }
        }

        // Y軸レンジを更新
        function updateAxisRange(chartNum) {
            const axisMinElement = document.getElementById(`axis-min-${chartNum}`);
            const axisMaxElement = document.getElementById(`axis-max-${chartNum}`);

            if (!axisMinElement || !axisMaxElement) {
                console.warn(`Y軸レンジ要素が見つかりません: chart ${chartNum}`);
                return;
            }

            const min = parseFloat(axisMinElement.value);
            const max = parseFloat(axisMaxElement.value);

            if (!isNaN(min) && !isNaN(max) && min < max) {
                currentAxisRanges[chartNum] = { min, max };

                // グラフを更新
                if (charts[chartNum]) {
                    charts[chartNum].options.scales.y.min = min;
                    charts[chartNum].options.scales.y.max = max;
                    charts[chartNum].update();
                }

                // Y軸連動がONで、グラフ1の変更なら、グラフ2も同期
                if (axisSync && chartNum === 1 && comparisonMode) {
                    const axisMin2Element = document.getElementById('axis-min-2');
                    const axisMax2Element = document.getElementById('axis-max-2');

                    currentAxisRanges[2] = { min, max };
                    if (axisMin2Element) axisMin2Element.value = min;
                    if (axisMax2Element) axisMax2Element.value = max;

                    if (charts[2]) {
                        charts[2].options.scales.y.min = min;
                        charts[2].options.scales.y.max = max;
                        charts[2].update();
                    }

                    // 同期アニメーション
                    const icon = document.querySelector('.sync-icon');
                    if (icon) {
                        icon.classList.add('syncing');
                        setTimeout(() => icon.classList.remove('syncing'), 1000);
                    }
                    lucide.createIcons();
                }
            }
        }

        // グラフ更新
        function updateChart(chartNum) {
            const days = currentPeriods[chartNum];

            // Chart2で比較モードの場合は、chart2Categoryを使用
            const categoryToUse = (chartNum === 2 && comparisonMode) ? chart2Category : currentSubCategory;

            const data = generateData(days)[categoryToUse];
            const labels = generateLabels(days);
            const metric = metricInfo[categoryToUse];

            // メトリック情報がない場合は処理を中断
            if (!metric) {
                console.error(`Metric info not found for: ${categoryToUse}`);
                return;
            }

            // データを保存
            currentData[chartNum] = data;

            // タイトル更新
            document.getElementById(`chart-title-${chartNum}`).textContent = `${metric.name}${chartNum === 2 ? ' - 比較' : ''}`;
            document.getElementById(`chart-period-${chartNum}`).textContent = `過去${days}日間の推移`;

            // カテゴリ別の最低値・最高値を計算して表示（全期間90日）
            const categoryMinElement = document.getElementById(`category-min-${chartNum}`);
            const categoryMaxElement = document.getElementById(`category-max-${chartNum}`);
            const categoryUnitElement = document.getElementById(`category-unit-${chartNum}`);

            if (categoryMinElement && categoryMaxElement && categoryUnitElement) {
                const fullData = generateData(90)[categoryToUse];
                const validFullData = fullData.filter(v => typeof v === 'number' && !isNaN(v) && v > 0);

                if (validFullData.length > 0) {
                    const categoryMin = Math.min(...validFullData);
                    const categoryMax = Math.max(...validFullData);

                    // Format numbers with comma separators (e.g., "2,264.10")
                    const formatNumber = (num) => {
                        return num.toFixed(1).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    };

                    categoryMinElement.textContent = formatNumber(categoryMin);
                    categoryMaxElement.textContent = formatNumber(categoryMax) + metric.unit;
                    categoryUnitElement.textContent = ''; // Hide separate unit, it's now in max value
                } else {
                    categoryMinElement.textContent = '-';
                    categoryMaxElement.textContent = '-';
                    categoryUnitElement.textContent = '';
                }
            }

            // 値の表示（バイナリの場合は完了/未完了）
            const currentValue = data[data.length - 1];
            if (metric.isBinary) {
                const valueText = (typeof currentValue === 'number' && currentValue === 1) ? '✓ 完了' : '✗ 未完了';
                document.getElementById(`chart-value-${chartNum}`).textContent = valueText;
                document.getElementById(`chart-unit-${chartNum}`).textContent = '';
            } else {
                const valueText = (typeof currentValue === 'number' && !isNaN(currentValue))
                    ? `${currentValue.toFixed(1)}${metric.unit}`
                    : '-';
                document.getElementById(`chart-value-${chartNum}`).textContent = valueText;
                document.getElementById(`chart-unit-${chartNum}`).textContent = '';
            }

            // 統計計算
            if (metric.isBinary) {
                // バイナリデータ（指示書）の場合は完了率を表示
                const completionRate = ((data.reduce((a, b) => a + b, 0) / data.length) * 100).toFixed(0);
                document.getElementById(`stat-avg-${chartNum}`).textContent = `${completionRate}%`;
                document.getElementById(`stat-avg-unit-${chartNum}`).textContent = '';
                document.getElementById(`stat-max-${chartNum}`).textContent = `${data.filter(v => v === 1).length}日`;
                document.getElementById(`stat-max-unit-${chartNum}`).textContent = '';
                document.getElementById(`stat-min-${chartNum}`).textContent = `${data.filter(v => v === 0).length}日`;
                document.getElementById(`stat-min-unit-${chartNum}`).textContent = '';
            } else {
                const avg = (data.reduce((a, b) => a + b, 0) / data.length).toFixed(1);
                const max = Math.max(...data).toFixed(1);
                const min = Math.min(...data).toFixed(1);

                const avgText = `${avg}${metric.unit}`;
                const maxText = `${max}${metric.unit}`;
                const minText = `${min}${metric.unit}`;

                console.log(`Chart ${chartNum} stats:`, { avgText, maxText, minText, metric: metric.name });

                document.getElementById(`stat-avg-${chartNum}`).textContent = avgText;
                document.getElementById(`stat-max-${chartNum}`).textContent = maxText;
                document.getElementById(`stat-min-${chartNum}`).textContent = minText;
                document.getElementById(`stat-avg-unit-${chartNum}`).textContent = '';
                document.getElementById(`stat-max-unit-${chartNum}`).textContent = '';
                document.getElementById(`stat-min-unit-${chartNum}`).textContent = '';

                // 標準偏差を計算
                const stdDev = calculateStdDev(data).toFixed(1);
                const stddevElement = document.getElementById(`stat-stddev-${chartNum}`);
                if (stddevElement) {
                    stddevElement.textContent = `${stdDev}${metric.unit}`;
                }

                // トレンドを計算
                const trend = (data[data.length - 1] - data[0]).toFixed(1);
                const trendPercent = ((trend / data[0]) * 100).toFixed(1);

                let trendLabel = '横ばい';
                let trendIcon = '→';
                let trendColor = 'text-gray-600';
                if (Math.abs(parseFloat(trendPercent)) < 5) {
                    trendLabel = '横ばい';
                    trendIcon = '→';
                    trendColor = 'text-gray-600';
                } else if (parseFloat(trend) > 0) {
                    trendLabel = '増加傾向';
                    trendIcon = '↑';
                    trendColor = 'text-green-600';
                } else {
                    trendLabel = '減少傾向';
                    trendIcon = '↓';
                    trendColor = 'text-red-600';
                }

                const trendIconElement = document.getElementById(`stat-trend-icon-${chartNum}`);
                const trendLabelElement = document.getElementById(`stat-trend-label-${chartNum}`);
                const trendValueElement = document.getElementById(`stat-trend-value-${chartNum}`);

                if (trendIconElement) {
                    trendIconElement.textContent = trendIcon;
                    trendIconElement.className = `text-2xl ${trendColor}`;
                }
                if (trendLabelElement) {
                    trendLabelElement.textContent = trendLabel;
                    trendLabelElement.className = `text-sm font-bold ${trendColor}`;
                }
                if (trendValueElement) {
                    trendValueElement.textContent = `${trend > 0 ? '+' : ''}${trend}${metric.unit} (${trendPercent}%)`;
                }
            }

            // Y軸レンジ設定（データに基づいて自動調整）
            // Chart2で異なるカテゴリを使用する場合は、そのカテゴリのglobalMinMaxを計算
            const currentGlobalMinMax = (chartNum === 2 && comparisonMode && categoryToUse !== currentSubCategory)
                ? calculateGlobalMinMax(categoryToUse)
                : globalMinMax;

            // Y軸を選択期間のデータに基づいて自動調整
            // 現在表示しているデータの範囲を取得
            const validData = data.filter(v => v !== null && v !== undefined && !isNaN(v));
            if (validData.length > 0 && !metric.isBinary) {
                const dataMin = Math.min(...validData);
                const dataMax = Math.max(...validData);
                const dataRange = dataMax - dataMin;

                // 適切なマージンを設定（データ範囲の15%、最低0.5）
                const margin = Math.max(dataRange * 0.15, 0.5);

                currentAxisRanges[chartNum] = {
                    min: Math.floor((dataMin - margin) * 10) / 10,
                    max: Math.ceil((dataMax + margin) * 10) / 10
                };
            } else if (metric.isBinary) {
                // バイナリデータの場合は固定範囲
                currentAxisRanges[chartNum] = { min: -0.2, max: 1.2 };
            } else {
                // データがない場合は全期間の範囲を使用
                currentAxisRanges[chartNum] = { ...currentGlobalMinMax };
            }

            // 軸入力フィールドが存在する場合のみ値を設定
            const axisMinElement = document.getElementById(`axis-min-${chartNum}`);
            const axisMaxElement = document.getElementById(`axis-max-${chartNum}`);
            if (axisMinElement) axisMinElement.value = currentAxisRanges[chartNum].min;
            if (axisMaxElement) axisMaxElement.value = currentAxisRanges[chartNum].max;

            // グラフ描画
            if (charts[chartNum]) charts[chartNum].destroy();

            const chartType = metric.isBinary ? 'bar' : 'line';

            // 目標ラインとメモマーカーのアノテーション設定
            const chartAnnotations = {};

            // 目標ライン
            const goal = goals[categoryToUse];
            if (goal && goal.showLine && !metric.isBinary) {
                chartAnnotations.goalLine = {
                    type: 'line',
                    yMin: goal.value,
                    yMax: goal.value,
                    borderColor: 'rgb(34, 197, 94)', // green-500
                    borderWidth: 2,
                    borderDash: [6, 6],
                    label: {
                        display: true,
                        content: `目標: ${goal.value}${metric.unit}`,
                        position: 'end',
                        backgroundColor: 'rgba(34, 197, 94, 0.8)',
                        color: 'white',
                        font: {
                            size: 11,
                            weight: 'bold'
                        },
                        padding: 4
                    }
                };
            }

            // メモマーカー
            const markers = getAnnotationMarkers(chartNum, categoryToUse);
            Object.assign(chartAnnotations, markers);

            // データセットの配列を構築
            const datasets = [{
                label: metric.name,
                data: data,
                borderColor: chartNum === 1 ? 'rgb(168, 85, 247)' : 'rgb(59, 130, 246)',
                backgroundColor: chartNum === 1 ? 'rgba(168, 85, 247, 0.6)' : 'rgba(59, 130, 246, 0.6)',
                fill: !metric.isBinary,
                tension: 0.4,
                yAxisID: 'y'
            }];

            // 移動平均線を追加
            if (showMovingAverage[chartNum] && !metric.isBinary) {
                const maData = calculateMovingAverage(data, movingAveragePeriod[chartNum]);
                datasets.push({
                    label: `${metric.name}（${movingAveragePeriod[chartNum]}日移動平均）`,
                    data: maData,
                    borderColor: chartNum === 1 ? 'rgb(251, 146, 60)' : 'rgb(14, 165, 233)',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    tension: 0.4,
                    pointRadius: 0,
                    yAxisID: 'y'
                });
            }

            // 予測線を追加
            if (showPrediction[chartNum] && !metric.isBinary && data.length >= 3) {
                const predictionData = calculatePrediction(data, 7);
                const predictionLabels = [...labels];
                for (let i = 1; i <= 7; i++) {
                    predictionLabels.push(`+${i}日`);
                }

                datasets.push({
                    label: `${metric.name}（予測）`,
                    data: predictionData,
                    borderColor: 'rgb(34, 197, 94)',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    borderDash: [10, 5],
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'y'
                });

                // ラベルを更新
                labels = predictionLabels;
            }

            // クロスヘアプラグイン
            const crosshairPlugin = {
                id: 'crosshair',
                afterDatasetsDraw: (chart) => {
                    if (chart.crosshair && chart.crosshair.draw) {
                        const ctx = chart.ctx;
                        const x = chart.crosshair.x;
                        const y = chart.crosshair.y;
                        const chartArea = chart.chartArea;

                        ctx.save();
                        ctx.strokeStyle = 'rgba(147, 51, 234, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]);

                        // 縦線
                        ctx.beginPath();
                        ctx.moveTo(x, chartArea.top);
                        ctx.lineTo(x, chartArea.bottom);
                        ctx.stroke();

                        // 横線
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, y);
                        ctx.lineTo(chartArea.right, y);
                        ctx.stroke();

                        ctx.restore();
                    }
                }
            };

            // 固定ツールチッププラグイン（カスタムツールチップとリード線を描画）
            const fixedTooltipPlugin = {
                id: 'fixedTooltip',
                afterDraw: (chart) => {
                    // ツールチップが有効で、選択されたポイントがある場合
                    if (tooltipEnabled[chartNum] && lastClickedIndex[chartNum] !== null) {
                        const ctx = chart.ctx;
                        const meta = chart.getDatasetMeta(0);
                        const dataPoint = meta.data[lastClickedIndex[chartNum]];

                        if (!dataPoint) return;

                        // データポイントの座標
                        const pointX = dataPoint.x;
                        const pointY = dataPoint.y;
                        const chartArea = chart.chartArea;

                        // カスタムツールチップの位置（全期間セクションとグラフの間の拡張スペース）
                        const tooltipWidth = 200;
                        const tooltipHeight = 55;
                        const tooltipX = (chartArea.left + chartArea.right) / 2;
                        const tooltipY = chartArea.top - 65; // グラフにかぶらないように更に上に配置

                        // データポイントに強調円を描画
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(pointX, pointY, 6, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(147, 51, 234, 0.3)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(147, 51, 234, 1)';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // リード線を描画
                        ctx.beginPath();
                        ctx.moveTo(pointX, pointY);
                        ctx.lineTo(tooltipX, tooltipY + tooltipHeight);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = 'rgba(147, 51, 234, 0.8)';
                        ctx.setLineDash([5, 3]);
                        ctx.stroke();

                        // カスタムツールチップを描画
                        ctx.setLineDash([]);

                        // 影を追加
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                        ctx.shadowBlur = 8;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 2;

                        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                        ctx.strokeStyle = 'rgba(147, 51, 234, 1)';
                        ctx.lineWidth = 2;

                        // 角丸矩形
                        const radius = 8;
                        ctx.beginPath();
                        ctx.moveTo(tooltipX - tooltipWidth/2 + radius, tooltipY);
                        ctx.lineTo(tooltipX + tooltipWidth/2 - radius, tooltipY);
                        ctx.quadraticCurveTo(tooltipX + tooltipWidth/2, tooltipY, tooltipX + tooltipWidth/2, tooltipY + radius);
                        ctx.lineTo(tooltipX + tooltipWidth/2, tooltipY + tooltipHeight - radius);
                        ctx.quadraticCurveTo(tooltipX + tooltipWidth/2, tooltipY + tooltipHeight, tooltipX + tooltipWidth/2 - radius, tooltipY + tooltipHeight);
                        ctx.lineTo(tooltipX - tooltipWidth/2 + radius, tooltipY + tooltipHeight);
                        ctx.quadraticCurveTo(tooltipX - tooltipWidth/2, tooltipY + tooltipHeight, tooltipX - tooltipWidth/2, tooltipY + tooltipHeight - radius);
                        ctx.lineTo(tooltipX - tooltipWidth/2, tooltipY + radius);
                        ctx.quadraticCurveTo(tooltipX - tooltipWidth/2, tooltipY, tooltipX - tooltipWidth/2 + radius, tooltipY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        // 影をリセット
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;

                        // ツールチップのテキストを描画
                        const value = chart.data.datasets[0].data[lastClickedIndex[chartNum]];
                        const label = chart.data.labels[lastClickedIndex[chartNum]];
                        const categoryToUse = chartNum === 1 ? currentSubCategory : chart2Category;
                        const unit = metricInfo[categoryToUse]?.unit || '';

                        // 日付情報
                        const today = new Date();
                        const totalDays = chart.data.labels.length;
                        const daysAgo = totalDays - lastClickedIndex[chartNum];
                        const targetDate = new Date(today);
                        targetDate.setDate(today.getDate() - daysAgo);
                        const dateStr = `${targetDate.getMonth() + 1}/${targetDate.getDate()}`;
                        let dateLabel;
                        if (daysAgo === 0) dateLabel = `${dateStr} (今日)`;
                        else if (daysAgo === 1) dateLabel = `${dateStr} (1日前)`;
                        else dateLabel = `${dateStr} (${daysAgo}日前)`;

                        // 値のフォーマット
                        let displayValue;
                        if (typeof value === 'number') {
                            displayValue = value % 1 === 0 ? value.toString() : value.toFixed(1);
                        } else {
                            displayValue = value || '-';
                        }

                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '11px sans-serif';
                        ctx.fillText(dateLabel, tooltipX, tooltipY + 15);
                        ctx.font = 'bold 18px sans-serif';
                        ctx.fillStyle = '#7c3aed';
                        ctx.fillText(`${displayValue}${unit}`, tooltipX, tooltipY + 35);

                        ctx.restore();
                    }
                }
            };

            const chartConfig = {
                type: chartType,
                data: {
                    labels: labels,
                    datasets: datasets
                },
                plugins: [crosshairPlugin, fixedTooltipPlugin],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, activeElements) => {
                        if (activeElements.length > 0) {
                            const datasetIndex = activeElements[0].datasetIndex;
                            const index = activeElements[0].index;

                            // メインデータセットの場合、選択パネルを表示し、ツールチップを有効化
                            if (datasetIndex === 0 && index < data.length) {
                                // 最後にクリックした位置を記録（selectDataPointより先に）
                                lastClickedChart = chartNum;
                                lastClickedIndex[chartNum] = index;

                                // ツールチップが無効な場合、自動的に有効化
                                if (!tooltipEnabled[chartNum]) {
                                    toggleTooltip(chartNum);
                                }

                                // 選択パネルを更新
                                selectDataPoint(chartNum, index);
                            }
                        } else {
                            // グラフ外をクリックした場合、ツールチップを無効化
                            if (tooltipEnabled[chartNum] && lastClickedChart === chartNum) {
                                toggleTooltip(chartNum);
                                lastClickedChart = null;
                                lastClickedIndex[chartNum] = null;
                            }
                        }
                    },
                    layout: {
                        padding: {
                            left: 10,
                            right: 20,
                            top: 90,  // 上部のパディングを拡大してツールチップ用のスペースを確保
                            bottom: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: datasets.length > 1,
                            position: 'top',
                            labels: {
                                boxWidth: 12,
                                font: { size: 10 },
                                padding: 8
                            }
                        },
                        tooltip: {
                            enabled: false
                        },
                        annotation: {
                            annotations: chartAnnotations
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    onHover: (event, activeElements, chart) => {
                        // マウスホバー時にクロスヘアを表示
                        const canvasPosition = Chart.helpers.getRelativePosition(event, chart);

                        if (canvasPosition.x >= chart.chartArea.left &&
                            canvasPosition.x <= chart.chartArea.right &&
                            canvasPosition.y >= chart.chartArea.top &&
                            canvasPosition.y <= chart.chartArea.bottom) {

                            chart.crosshair = {
                                x: canvasPosition.x,
                                y: canvasPosition.y,
                                draw: true
                            };
                        } else {
                            chart.crosshair = { draw: false };
                        }

                        chart.draw();
                    },
                    scales: (() => {
                        const scales = {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                beginAtZero: false,
                                min: currentAxisRanges[chartNum].min,
                                max: currentAxisRanges[chartNum].max,
                                ticks: metric.isBinary ? {
                                    stepSize: 1,
                                    callback: function(value) {
                                        return value === 1 ? '完了' : value === 0 ? '未完了' : '';
                                    }
                                } : {
                                    padding: 10,
                                    font: {
                                        size: 11
                                    }
                                },
                                grid: {
                                    drawBorder: true,
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            x: {
                                ticks: {
                                    padding: 5,
                                    font: {
                                        size: 10
                                    },
                                    autoSkip: false,
                                    maxRotation: 0,
                                    callback: function(value, index, ticks) {
                                        const label = this.getLabelForValue(value);
                                        const totalDays = ticks.length;

                                        // 必ず7ポイントに限定して均等に配分
                                        const maxLabels = 7;
                                        const step = Math.floor((totalDays - 1) / (maxLabels - 1));

                                        // 表示するインデックスを計算
                                        let shouldDisplay = false;

                                        if (totalDays <= maxLabels) {
                                            // データが7個以下の場合はすべて表示
                                            shouldDisplay = true;
                                        } else {
                                            // 最初と最後は必ず表示
                                            if (index === 0 || index === totalDays - 1) {
                                                shouldDisplay = true;
                                            } else {
                                                // 均等に配分された位置に表示
                                                for (let i = 1; i < maxLabels - 1; i++) {
                                                    if (index === i * step) {
                                                        shouldDisplay = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        if (!shouldDisplay) {
                                            return '';
                                        }

                                        // 最後のラベル（右端）にのみ「日前」を追加
                                        if (index === totalDays - 1) {
                                            return label + '日前';
                                        }

                                        return label;
                                    }
                                },
                                grid: {
                                    display: false
                                }
                            }
                        };

                        return scales;
                    })()
                }
            };

            charts[chartNum] = new Chart(document.getElementById(`main-chart-${chartNum}`), chartConfig);
        }

        // RM用の変数
        let currentRMReps = null;
        let currentRMExercise = null;

        // 小カテゴリ選択
        function selectSubCategory(category, subCategory) {
            currentSubCategory = subCategory;

            // RM選択時は調整パネルを表示
            const rmPanel = document.getElementById('rm-control-panel');
            if (subCategory === 'rm') {
                if (rmPanel) {
                    rmPanel.classList.remove('hidden');
                    initializeRMPanel();
                }
                return; // パネル表示のみで、グラフは表示しない
            } else {
                if (rmPanel) rmPanel.classList.add('hidden');
                currentRMReps = null;
                currentRMExercise = null;
            }

            // 全期間の最低値・最大値を再計算
            globalMinMax = calculateGlobalMinMax(subCategory);

            // Y軸レンジをリセット
            currentAxisRanges = { 1: { min: null, max: null }, 2: { min: null, max: null } };

            // カテゴリ別の色設定（アプリと完全一致）
            const categoryColors = {
                nutrition: { border: 'border-green-500', text: 'text-green-700' },   // 食事: 緑
                training: { border: 'border-orange-500', text: 'text-orange-700' },  // 運動: オレンジ
                condition: { border: 'border-red-500', text: 'text-red-700' },       // コンディション: 赤
                performance: { border: 'border-purple-500', text: 'text-purple-700' }// パフォーマンス: 紫
            };

            const colors = categoryColors[category] || categoryColors.performance;

            // 現在のカテゴリのサブタブボタンのみを更新
            const subtabContainer = document.getElementById(`${category}-subtabs`);
            if (subtabContainer) {
                subtabContainer.querySelectorAll('.sub-tab-button').forEach(btn => {
                    btn.classList.remove('active', 'border-orange-500', 'text-orange-700', 'border-green-500', 'text-green-700', 'border-red-500', 'text-red-700', 'border-purple-500', 'text-purple-700');
                    btn.classList.add('border-transparent', 'text-gray-700');
                });

                if (event && event.currentTarget) {
                    event.currentTarget.classList.add('active', colors.border, colors.text);
                    event.currentTarget.classList.remove('border-transparent', 'text-gray-700');
                }
            }

            updateChart(1);
            if (comparisonMode) {
                updateChart(2);
            }
        }

        // RMパネルの初期化
        function initializeRMPanel() {
            if (!allData.rm || Object.keys(allData.rm).length === 0) {
                document.getElementById('rm-reps-buttons').innerHTML = '<span class="text-xs text-gray-500">RM記録がありません</span>';
                document.getElementById('rm-exercise-buttons').innerHTML = '';
                return;
            }

            // 利用可能な回数を抽出
            const repsSet = new Set();
            Object.keys(allData.rm).forEach(key => {
                const [reps, exercise] = key.split('_');
                repsSet.add(parseInt(reps));
            });
            const repsList = Array.from(repsSet).sort((a, b) => a - b);

            // 回数ボタンを生成
            const repsContainer = document.getElementById('rm-reps-buttons');
            repsContainer.innerHTML = repsList.map((reps, index) =>
                `<button type="button"
                    class="px-2 py-1 text-xs font-semibold rounded border ${index === 0 ? 'bg-orange-600 text-white border-orange-600' : 'bg-white text-gray-700 border-gray-300 hover:border-orange-400'}"
                    onclick="selectRMReps(${reps})">
                    ${reps}RM
                </button>`
            ).join('');

            // 最初の回数を自動選択
            if (repsList.length > 0) {
                selectRMReps(repsList[0]);
            }
        }

        // RM回数を選択
        function selectRMReps(reps) {
            currentRMReps = reps;

            // ボタンのアクティブ状態を更新
            document.querySelectorAll('#rm-reps-buttons button').forEach(btn => {
                btn.classList.remove('bg-orange-600', 'text-white', 'border-orange-600');
                btn.classList.add('bg-white', 'text-gray-700', 'border-gray-300');
            });
            event.currentTarget.classList.add('bg-orange-600', 'text-white', 'border-orange-600');
            event.currentTarget.classList.remove('bg-white', 'text-gray-700', 'border-gray-300');

            // この回数で利用可能な種目を抽出
            const exercises = [];
            Object.keys(allData.rm).forEach(key => {
                const [keyReps, exercise] = key.split('_');
                if (parseInt(keyReps) === reps) {
                    exercises.push(exercise);
                }
            });

            // 種目ボタンを生成
            const exerciseContainer = document.getElementById('rm-exercise-buttons');
            exerciseContainer.innerHTML = exercises.map((exercise, index) =>
                `<button type="button"
                    class="px-2 py-1 text-xs font-semibold rounded border ${index === 0 ? 'bg-orange-600 text-white border-orange-600' : 'bg-white text-gray-700 border-gray-300 hover:border-orange-400'}"
                    onclick="selectRMExercise('${exercise}')">
                    ${exercise}
                </button>`
            ).join('');

            // 最初の種目を自動選択
            if (exercises.length > 0) {
                currentRMExercise = exercises[0];
                updateRMChart();
            }
        }

        // RM種目を選択
        function selectRMExercise(exercise) {
            currentRMExercise = exercise;

            // ボタンのアクティブ状態を更新
            document.querySelectorAll('#rm-exercise-buttons button').forEach(btn => {
                btn.classList.remove('bg-orange-600', 'text-white', 'border-orange-600');
                btn.classList.add('bg-white', 'text-gray-700', 'border-gray-300');
            });
            event.currentTarget.classList.add('bg-orange-600', 'text-white', 'border-orange-600');
            event.currentTarget.classList.remove('bg-white', 'text-gray-700', 'border-gray-300');

            updateRMChart();
        }

        // RMグラフを更新
        function updateRMChart() {
            const key = `${currentRMReps}_${currentRMExercise}`;
            currentSubCategory = `rm_${key}`;

            // metricInfoに動的に追加
            if (!metricInfo[currentSubCategory]) {
                metricInfo[currentSubCategory] = {
                    name: `${currentRMExercise} ${currentRMReps}RM`,
                    unit: 'kg',
                    icon: '💪',
                    isBinary: false
                };
            }

            // allDataにマッピング
            if (!allData[currentSubCategory]) {
                allData[currentSubCategory] = allData.rm[key] || [];
            }

            globalMinMax = calculateGlobalMinMax(currentSubCategory);
            currentAxisRanges = { 1: { min: null, max: null }, 2: { min: null, max: null } };

            updateChart(1);
            if (comparisonMode) {
                updateChart(2);
            }
        }

        // 目標データの読み込み
        function loadGoals() {
            try {
                const stored = localStorage.getItem('fitness_goals');
                if (stored) {
                    goals = JSON.parse(stored);
                }
            } catch (error) {
                console.error('目標データの読み込みエラー:', error);
                goals = {};
            }
        }

        // 目標データの保存
        function saveGoalsToStorage() {
            try {
                localStorage.setItem('fitness_goals', JSON.stringify(goals));
            } catch (error) {
                console.error('目標データの保存エラー:', error);
            }
        }

        // 目標設定モーダルを開く
        function openGoalSettingModal() {
            const modal = document.getElementById('goal-setting-modal');
            const metricSelect = document.getElementById('goal-metric');

            // 現在の指標を選択状態にする
            metricSelect.value = currentSubCategory;
            updateGoalUnit();

            // 既存の目標をロード
            loadCurrentGoal();

            modal.classList.add('show');
            lucide.createIcons();
        }

        function closeGoalSettingModal() {
            document.getElementById('goal-setting-modal').classList.remove('show');
        }

        // 指標に応じて単位を更新
        document.getElementById('goal-metric')?.addEventListener('change', updateGoalUnit);

        function updateGoalUnit() {
            const metricSelect = document.getElementById('goal-metric');
            const selectedMetric = metricSelect.value;
            const metric = metricInfo[selectedMetric];
            document.getElementById('goal-unit').textContent = metric.unit;
            loadCurrentGoal();
        }

        // 現在の目標を表示
        function loadCurrentGoal() {
            const metricSelect = document.getElementById('goal-metric');
            const selectedMetric = metricSelect.value;
            const goal = goals[selectedMetric];
            const infoDiv = document.getElementById('current-goal-info');
            const textDiv = document.getElementById('current-goal-text');

            if (goal) {
                const metric = metricInfo[selectedMetric];
                let text = `目標値: ${goal.value}${metric.unit}`;
                if (goal.date) {
                    text += `<br>達成予定日: ${goal.date}`;
                }
                text += `<br>グラフ表示: ${goal.showLine ? 'ON' : 'OFF'}`;

                textDiv.innerHTML = text;
                infoDiv.classList.remove('hidden');

                // フォームに値を設定
                document.getElementById('goal-value').value = goal.value;
                document.getElementById('goal-date').value = goal.date || '';
                document.getElementById('goal-show-line').checked = goal.showLine;
            } else {
                infoDiv.classList.add('hidden');
                // フォームをクリア
                document.getElementById('goal-value').value = '';
                document.getElementById('goal-date').value = '';
                document.getElementById('goal-show-line').checked = true;
            }
        }

        // 目標を保存
        function saveGoal() {
            const metricSelect = document.getElementById('goal-metric');
            const selectedMetric = metricSelect.value;
            const value = parseFloat(document.getElementById('goal-value').value);
            const date = document.getElementById('goal-date').value;
            const showLine = document.getElementById('goal-show-line').checked;

            if (isNaN(value) || value <= 0) {
                alert('有効な目標値を入力してください');
                return;
            }

            // 目標を保存
            goals[selectedMetric] = {
                value: value,
                date: date || null,
                showLine: showLine,
                createdAt: new Date().toISOString()
            };

            saveGoalsToStorage();

            // グラフを更新（目標ラインを表示）
            updateChart(1);
            if (comparisonMode) {
                updateChart(2);
            }

            alert('目標を保存しました！');
            closeGoalSettingModal();
        }

        // 目標をクリア
        function clearGoal() {
            const metricSelect = document.getElementById('goal-metric');
            const selectedMetric = metricSelect.value;

            if (goals[selectedMetric]) {
                if (confirm('この指標の目標をクリアしますか？')) {
                    delete goals[selectedMetric];
                    saveGoalsToStorage();
                    loadCurrentGoal();

                    // グラフを更新
                    updateChart(1);
                    if (comparisonMode) {
                        updateChart(2);
                    }

                    alert('目標をクリアしました');
                }
            } else {
                alert('設定された目標がありません');
            }
        }

        // アノテーション（メモ）機能
        function loadAnnotations() {
            try {
                const stored = localStorage.getItem('fitness_annotations');
                if (stored) {
                    annotations = JSON.parse(stored);
                }
            } catch (error) {
                console.error('アノテーションの読み込みエラー:', error);
                annotations = {};
            }
        }

        function saveAnnotations() {
            try {
                localStorage.setItem('fitness_annotations', JSON.stringify(annotations));
            } catch (error) {
                console.error('アノテーションの保存エラー:', error);
            }
        }

        // グラフのクリックイベントでメモを追加
        function addAnnotationOnClick(chartNum, event) {
            const chart = charts[chartNum];
            if (!chart) return;

            const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true);

            if (points.length > 0) {
                const point = points[0];
                const dataIndex = point.index;
                const label = chart.data.labels[dataIndex];
                const metric = metricInfo[currentSubCategory];

                // メモを入力
                const note = prompt(`${label}のメモを入力してください:\n（例: 風邪で休養、チートデイ、体調良好）`);

                if (note && note.trim() !== '') {
                    const key = `${currentSubCategory}_${label}`;
                    annotations[key] = {
                        date: label,
                        note: note.trim(),
                        metric: currentSubCategory,
                        createdAt: new Date().toISOString()
                    };

                    saveAnnotations();
                    updateChart(chartNum);
                    alert('メモを保存しました！');
                }
            }
        }

        // アノテーションマーカーをグラフに追加
        function getAnnotationMarkers(chartNum, category) {
            const labels = charts[chartNum]?.data.labels || [];
            const markers = {};

            labels.forEach((label, index) => {
                const key = `${category}_${label}`;
                if (annotations[key]) {
                    markers[`note_${index}`] = {
                        type: 'point',
                        xValue: index,
                        yValue: currentData[chartNum][index],
                        backgroundColor: 'rgba(255, 193, 7, 0.8)', // amber-400
                        borderColor: 'rgb(245, 158, 11)',
                        borderWidth: 2,
                        radius: 8,
                        label: {
                            display: true,
                            content: '📝',
                            position: 'top',
                            font: {
                                size: 14
                            }
                        }
                    };
                }
            });

            return markers;
        }

        // グラフホバー時にメモを表示
        function showAnnotationTooltip(chartNum, tooltipItems) {
            if (!tooltipItems || tooltipItems.length === 0) return;

            const index = tooltipItems[0].dataIndex;
            const label = charts[chartNum].data.labels[index];
            const key = `${currentSubCategory}_${label}`;

            if (annotations[key]) {
                return [
                    tooltipItems[0].formattedValue,
                    '',
                    `📝 メモ: ${annotations[key].note}`
                ];
            }

            return tooltipItems[0].formattedValue;
        }

        // フローティング設定パネル
        let currentPanelChart = 1; // どのグラフの設定を開いているか

        function toggleSettingsPanel(chartNum) {
            const panel = document.getElementById('settings-panel');
            const isHidden = panel.classList.contains('hidden');

            if (isHidden) {
                currentPanelChart = chartNum;
                openSettingsPanel();
            } else {
                closeSettingsPanel();
            }
        }

        function openSettingsPanel() {
            const panel = document.getElementById('settings-panel');
            panel.classList.remove('hidden');

            // パネルの状態を現在のグラフ設定に同期
            syncPanelToCurrentSettings();

            // Flatpickrを初期化（パネル用）
            initPanelFlatpickr();

            lucide.createIcons();
        }

        function closeSettingsPanel() {
            document.getElementById('settings-panel').classList.add('hidden');
        }

        function syncPanelToCurrentSettings() {
            // Y軸範囲を同期
            const axisMinPanel = document.getElementById('axis-min-panel');
            const axisMaxPanel = document.getElementById('axis-max-panel');
            const comparisonModePanel = document.getElementById('comparison-mode-panel');
            const syncAxisPanel = document.getElementById('sync-axis-panel');

            if (axisMinPanel) axisMinPanel.value = currentAxisRanges[currentPanelChart].min || '';
            if (axisMaxPanel) axisMaxPanel.value = currentAxisRanges[currentPanelChart].max || '';

            // 比較モードとY軸連動を同期
            if (comparisonModePanel) comparisonModePanel.checked = comparisonMode;
            if (syncAxisPanel) syncAxisPanel.checked = axisSync;

            // Chart2カテゴリドロップダウンを更新
            updateChart2CategoryDropdown();
        }

        function updateChart2CategoryDropdown() {
            const select = document.getElementById('chart2-category-panel');
            if (!select) return;

            // 現在選択されている値を保存
            const currentValue = chart2Category;

            // すべてのオプションをクリア
            select.innerHTML = '';

            // カテゴリ別にグループ化してオプションを追加
            const categories = {
                'パフォーマンス': ['lbm', 'directive', 'overall'],
                '食事': ['calories', 'protein', 'carbs', 'fat', 'water'],
                '運動': ['workout_duration', 'workout_volume', 'steps', 'cardio'],
                'コンディション': ['weight', 'body_fat', 'sleep', 'mood', 'energy']
            };

            for (const [categoryName, metrics] of Object.entries(categories)) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = categoryName;

                for (const metric of metrics) {
                    if (metricInfo[metric]) {
                        const option = document.createElement('option');
                        option.value = metric;
                        option.textContent = `${metricInfo[metric].icon} ${metricInfo[metric].name}`;
                        if (metric === currentValue) {
                            option.selected = true;
                        }
                        optgroup.appendChild(option);
                    }
                }

                select.appendChild(optgroup);
            }
        }

        function initPanelFlatpickr() {
            if (!flatpickrInstances['panel']) {
                flatpickrInstances['panel'] = {
                    start: flatpickr('#custom-start-panel', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today',
                        onChange: function(selectedDates) {
                            if (flatpickrInstances['panel']?.end) {
                                flatpickrInstances['panel'].end.set('minDate', selectedDates[0]);
                            }
                        }
                    }),
                    end: flatpickr('#custom-end-panel', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today'
                    })
                };
            }
        }

        function applyCustomPeriodFromPanel() {
            const startDate = document.getElementById('custom-start-panel').value;
            const endDate = document.getElementById('custom-end-panel').value;

            if (!startDate || !endDate) {
                alert('開始日と終了日を選択してください');
                return;
            }

            const start = new Date(startDate);
            const end = new Date(endDate);

            if (start > end) {
                alert('開始日は終了日より前である必要があります');
                return;
            }

            const days = Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;

            if (days > 90) {
                alert('最大90日間まで選択できます');
                return;
            }

            currentPeriods[currentPanelChart] = days;

            // 期間ボタンの選択状態をリセット
            const container = currentPanelChart === 1 ? document.getElementById('chart-1') : document.getElementById('chart-2');
            container.querySelectorAll('.period-button').forEach(btn => {
                btn.classList.remove('active');
                btn.classList.remove('border-purple-500', 'border-blue-500', 'font-semibold');
                btn.classList.add('border-gray-300');
            });

            updateChart(currentPanelChart);
            alert(`カスタム期間（${days}日間）を適用しました`);
        }

        function updateAxisRangeFromPanel() {
            const min = parseFloat(document.getElementById('axis-min-panel').value);
            const max = parseFloat(document.getElementById('axis-max-panel').value);

            if (!isNaN(min) && !isNaN(max) && min < max) {
                currentAxisRanges[currentPanelChart] = { min, max };

                // グラフを更新
                if (charts[currentPanelChart]) {
                    charts[currentPanelChart].options.scales.y.min = min;
                    charts[currentPanelChart].options.scales.y.max = max;
                    charts[currentPanelChart].update();
                }

                // Y軸連動がONで、グラフ1の変更なら、グラフ2も同期
                if (axisSync && currentPanelChart === 1 && comparisonMode) {
                    currentAxisRanges[2] = { min, max };
                    if (charts[2]) {
                        charts[2].options.scales.y.min = min;
                        charts[2].options.scales.y.max = max;
                        charts[2].update();
                    }
                }
            }
        }

        function resetAxisRangeFromPanel() {
            document.getElementById('axis-min-panel').value = globalMinMax.min;
            document.getElementById('axis-max-panel').value = globalMinMax.max;
            updateAxisRangeFromPanel();
        }

        // カスタム期間選択機能
        let flatpickrInstances = {};

        function initFlatpickr() {
            // Flatpickrを日本語に設定
            if (typeof flatpickr !== 'undefined') {
                flatpickr.localize(flatpickr.l10ns.ja);
            }

            // Chart 1のFlatpickr初期化
            if (!flatpickrInstances[1]) {
                flatpickrInstances[1] = {
                    start: flatpickr('#custom-start-1', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today',
                        onChange: function(selectedDates) {
                            if (flatpickrInstances[1]?.end) {
                                flatpickrInstances[1].end.set('minDate', selectedDates[0]);
                            }
                        }
                    }),
                    end: flatpickr('#custom-end-1', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today'
                    })
                };
            }

            // Chart 2のFlatpickr初期化
            if (!flatpickrInstances[2]) {
                flatpickrInstances[2] = {
                    start: flatpickr('#custom-start-2', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today',
                        onChange: function(selectedDates) {
                            if (flatpickrInstances[2]?.end) {
                                flatpickrInstances[2].end.set('minDate', selectedDates[0]);
                            }
                        }
                    }),
                    end: flatpickr('#custom-end-2', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today'
                    })
                };
            }
        }

        function toggleCustomPeriod(chartNum) {
            const customPeriodDiv = document.getElementById(`custom-period-${chartNum}`);
            customPeriodDiv.classList.toggle('hidden');

            // 初回表示時にFlatpickrを初期化
            if (!customPeriodDiv.classList.contains('hidden')) {
                initFlatpickr();
            }

            lucide.createIcons();
        }

        function applyCustomPeriod(chartNum) {
            const startDate = document.getElementById(`custom-start-${chartNum}`).value;
            const endDate = document.getElementById(`custom-end-${chartNum}`).value;

            if (!startDate || !endDate) {
                alert('開始日と終了日を選択してください');
                return;
            }

            const start = new Date(startDate);
            const end = new Date(endDate);

            if (start > end) {
                alert('開始日は終了日より前である必要があります');
                return;
            }

            // 日数を計算
            const days = Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;

            if (days > 90) {
                alert('最大90日間まで選択できます');
                return;
            }

            // カスタム期間を適用
            currentPeriods[chartNum] = days;

            // 期間ボタンの選択状態をリセット
            const container = chartNum === 1 ? document.getElementById('chart-1') : document.getElementById('chart-2');
            container.querySelectorAll('.period-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // カスタム期間のUIを閉じる
            document.getElementById(`custom-period-${chartNum}`).classList.add('hidden');

            // グラフを更新
            updateChart(chartNum);

            alert(`カスタム期間（${days}日間）を適用しました`);
        }

        // ===== ドリルダウンモーダル機能 =====

        function showDrillDownModal(chartNum, index, label, value, metric) {
            // Chart2で比較モードの場合は、chart2Categoryを使用
            const categoryToUse = (chartNum === 2 && comparisonMode) ? chart2Category : currentSubCategory;

            // データを保存
            const annotationKey = `${categoryToUse}_${label}`;
            currentDrillDownData = {
                chartNum,
                index,
                label,
                value,
                metric,
                annotationKey
            };

            // ラベルから実際の日付を計算
            const daysAgo = parseInt(label.replace(/[^\d]/g, '')) || 0;
            const today = new Date();
            const targetDate = new Date(today);
            targetDate.setDate(today.getDate() - daysAgo);

            // 日付をフォーマット (10/15形式 と YYYY-MM-DD形式)
            const dateString = `${targetDate.getMonth() + 1}/${targetDate.getDate()}`;
            const daysAgoString = daysAgo === 0 ? '今日' : `${daysAgo}日前`;
            const dateKey = targetDate.toISOString().split('T')[0]; // YYYY-MM-DD形式

            // モーダルの内容を更新
            document.getElementById('drilldown-title').textContent = `${dateString} (${daysAgoString})`;
            document.getElementById('drilldown-subtitle').textContent = `${metric.name}のデータ`;
            document.getElementById('drilldown-metric').textContent = metric.name;

            // 値の表示（バイナリデータの場合は完了/未完了に変換）
            if (metric.isBinary) {
                document.getElementById('drilldown-value').textContent = value === 1 ? '✅ 完了' : '❌ 未完了';
            } else {
                document.getElementById('drilldown-value').textContent = `${value.toFixed(1)} ${metric.unit}`;
            }

            // メモの表示
            if (annotations[annotationKey]) {
                document.getElementById('drilldown-memo-text').textContent = annotations[annotationKey].note;
                document.getElementById('drilldown-memo-display').classList.remove('hidden');
                document.getElementById('drilldown-memo-empty').classList.add('hidden');
                document.getElementById('memo-edit-button-text').textContent = 'メモを編集';
            } else {
                document.getElementById('drilldown-memo-display').classList.add('hidden');
                document.getElementById('drilldown-memo-empty').classList.remove('hidden');
                document.getElementById('memo-edit-button-text').textContent = 'メモを追加';
            }

            // 編集UIをリセット
            document.getElementById('drilldown-memo-edit').classList.add('hidden');
            document.getElementById('drilldown-memo-input').value = annotations[annotationKey]?.note || '';

            // モーダルを表示
            const modal = document.getElementById('drilldown-modal');
            modal.classList.remove('hidden');

            // アイコンを再描画
            lucide.createIcons();
        }

        function closeDrillDownModal() {
            const modal = document.getElementById('drilldown-modal');
            modal.classList.add('hidden');

            // 編集UIをリセット
            document.getElementById('drilldown-memo-edit').classList.add('hidden');
        }

        function toggleMemoEdit() {
            const editDiv = document.getElementById('drilldown-memo-edit');
            editDiv.classList.toggle('hidden');

            // アイコンを再描画
            lucide.createIcons();
        }

        function saveMemo() {
            const noteText = document.getElementById('drilldown-memo-input').value.trim();

            if (!noteText) {
                alert('メモを入力してください');
                return;
            }

            // アノテーションを保存
            annotations[currentDrillDownData.annotationKey] = {
                note: noteText,
                value: currentDrillDownData.value,
                metric: currentDrillDownData.metric.name
            };

            // LocalStorageに保存
            localStorage.setItem('history_v10_annotations', JSON.stringify(annotations));

            // UIを更新
            document.getElementById('drilldown-memo-text').textContent = noteText;
            document.getElementById('drilldown-memo-display').classList.remove('hidden');
            document.getElementById('drilldown-memo-empty').classList.add('hidden');
            document.getElementById('memo-edit-button-text').textContent = 'メモを編集';
            document.getElementById('drilldown-memo-edit').classList.add('hidden');

            // グラフを更新（ツールチップにメモが表示されるように）
            updateChart(currentDrillDownData.chartNum);

            alert('メモを保存しました');
        }

        function deleteMemo() {
            if (!confirm('このメモを削除してもよろしいですか?')) {
                return;
            }

            // アノテーションを削除
            delete annotations[currentDrillDownData.annotationKey];

            // LocalStorageを更新
            localStorage.setItem('history_v10_annotations', JSON.stringify(annotations));

            // UIを更新
            document.getElementById('drilldown-memo-display').classList.add('hidden');
            document.getElementById('drilldown-memo-empty').classList.remove('hidden');
            document.getElementById('memo-edit-button-text').textContent = 'メモを追加';
            document.getElementById('drilldown-memo-edit').classList.add('hidden');
            document.getElementById('drilldown-memo-input').value = '';

            // グラフを更新
            updateChart(currentDrillDownData.chartNum);

            alert('メモを削除しました');
        }

        // 初期表示
        async function init() {
            loadGoals(); // 目標データを読み込み
            loadAnnotations(); // メモデータを読み込み

            // 実データの読み込みを試行
            if (typeof DataService !== 'undefined') {
                try {
                    allData = await loadRealData();
                    console.log('Real data loaded successfully');
                } catch (error) {
                    console.error('Failed to load real data:', error);
                }
            } else {
                console.warn('DataService is not available');
            }

            globalMinMax = calculateGlobalMinMax('lbm');
            updateChart(1);

            // 初期表示で一番右（最新）のデータポイントを選択
            setTimeout(() => {
                const chart = charts[1];
                if (chart && chart.data.labels.length > 0) {
                    const lastIndex = chart.data.labels.length - 1;
                    selectDataPoint(1, lastIndex);
                }
            }, 100);
        }

        // データポイント選択機能
        function selectDataPoint(chartNum, index) {
            const chart = charts[chartNum];
            if (!chart || index < 0 || index >= chart.data.labels.length) return;

            selectedDataIndex[chartNum] = index;
            const categoryToUse = chartNum === 1 ? currentSubCategory : chart2Category;
            const unit = metricInfo[categoryToUse]?.unit || '';
            const value = chart.data.datasets[0].data[index];

            // 日付情報を取得
            const today = new Date();
            const totalDays = chart.data.labels.length;
            const daysAgo = totalDays - index;
            const targetDate = new Date(today);
            targetDate.setDate(today.getDate() - daysAgo);
            const dateStr = `${targetDate.getMonth() + 1}/${targetDate.getDate()}`;

            let dateLabel;
            if (daysAgo === 0) {
                dateLabel = `${dateStr} (今日)`;
            } else if (daysAgo === 1) {
                dateLabel = `${dateStr} (1日前)`;
            } else {
                dateLabel = `${dateStr} (${daysAgo}日前)`;
            }

            // 値のフォーマット
            let displayValue;
            if (typeof value === 'number') {
                displayValue = value % 1 === 0 ? value.toString() : value.toFixed(1);
            } else {
                displayValue = value || '-';
            }

            // UIを更新
            document.getElementById(`selected-date-${chartNum}`).textContent = dateLabel;
            document.getElementById(`selected-value-${chartNum}`).innerHTML =
                `${displayValue}<span class="text-lg opacity-70 ml-1">${unit}</span>`;
            document.getElementById(`selected-point-${chartNum}`).classList.remove('hidden');

            // ツールチップを表示
            if (tooltipEnabled[chartNum]) {
                const meta = chart.getDatasetMeta(0);
                if (meta.data[index]) {
                    const element = meta.data[index];
                    chart.tooltip.setActiveElements([
                        {datasetIndex: 0, index: index}
                    ], {x: element.x, y: element.y});

                    // グラフを再描画してリード線を更新
                    requestAnimationFrame(() => {
                        chart.draw();
                    });
                }
            }

            // アイコンを再描画
            lucide.createIcons();
        }

        // データポイントナビゲーション
        function navigateDataPoint(chartNum, direction) {
            const chart = charts[chartNum];
            if (!chart) return;

            const currentIndex = selectedDataIndex[chartNum];
            if (currentIndex === null) return;

            const newIndex = currentIndex + direction;
            if (newIndex >= 0 && newIndex < chart.data.labels.length) {
                selectDataPoint(chartNum, newIndex);

                // 最後にクリックした位置を更新（ツールチップ表示用）
                lastClickedIndex[chartNum] = newIndex;
                lastClickedChart = chartNum;
            }
        }

        // ツールチップの表示/非表示を切り替え
        let tooltipEnabled = { 1: false, 2: false };
        let lastClickedChart = null;
        let lastClickedIndex = { 1: null, 2: null };

        function toggleTooltip(chartNum) {
            const chart = charts[chartNum];
            if (!chart) return;

            // 状態を切り替え
            tooltipEnabled[chartNum] = !tooltipEnabled[chartNum];

            // Chart.jsのツールチップ設定を更新
            chart.options.plugins.tooltip.enabled = tooltipEnabled[chartNum];

            // ツールチップを有効化した場合、最後にクリックした位置に表示
            if (tooltipEnabled[chartNum] && lastClickedIndex[chartNum] !== null) {
                const meta = chart.getDatasetMeta(0);
                if (meta.data[lastClickedIndex[chartNum]]) {
                    const element = meta.data[lastClickedIndex[chartNum]];
                    chart.tooltip.setActiveElements([
                        {datasetIndex: 0, index: lastClickedIndex[chartNum]}
                    ], {x: element.x, y: element.y});
                }
            }

            // グラフを再描画
            requestAnimationFrame(() => {
                chart.draw();
            });

            // ボタンのテキストとスタイルを更新
            const button = document.getElementById(`tooltip-toggle-${chartNum}`);
            if (tooltipEnabled[chartNum]) {
                button.innerHTML = '<i data-lucide="eye-off" class="w-3 h-3 inline-block mr-1"></i>ツールチップを非表示';
                button.classList.remove('bg-gray-100', 'text-gray-700');
                button.classList.add('bg-purple-600', 'text-white');
            } else {
                button.innerHTML = '<i data-lucide="info" class="w-3 h-3 inline-block mr-1"></i>ツールチップを表示';
                button.classList.remove('bg-purple-600', 'text-white');
                button.classList.add('bg-gray-100', 'text-gray-700');
            }

            // アイコンを再描画
            lucide.createIcons();
        }

        init();
    </script>
</body>
</html>

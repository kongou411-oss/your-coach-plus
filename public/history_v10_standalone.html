<!DOCTYPE html>
<!--
  履歴グラフ v2.2.0
  更新日: 2025-10-22
  変更内容:
  - 運動カテゴリの「1RM」「5RM」「10RM」を「RM」1つに統合
  - RM選択時に専用調整パネルを表示（回数選択・種目選択の2段階）
  - ユーザーが実際に記録したRM回数と種目のみを動的に表示
  - 種目別・回数別のRM推移をグラフで確認可能に
-->
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>履歴グラフ v2.0.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-functions-compat.js"></script>

    <!-- App Services -->
    <script src="/config.js"></script>
    <script src="/utils.js"></script>
    <script src="/services.js"></script>
    <!-- 目標ライン・メモ機能 -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1"></script>
    <!-- カスタム期間選択 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/ja.js"></script>
    <style>
        /* スクロールバーを完全非表示 */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        *::-webkit-scrollbar {
            display: none; /* Chrome/Safari/Opera */
        }

        .tab-button {
            transition: all 0.3s ease;
            position: relative;
        }
        .tab-button.active {
            font-weight: 600;
        }
        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: currentColor;
        }
        .sub-tab-button {
            transition: all 0.2s ease;
        }
        .sub-tab-button.active {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .chart-container {
            animation: fadeIn 0.4s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .day-box {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
            font-weight: 600;
            font-size: 0.75rem;
        }
        .day-box.done {
            background-color: #22c55e;
            color: white;
        }
        .day-box.not-done {
            background-color: #e5e7eb;
            color: #6b7280;
        }
        .range-control {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-top: 1rem;
        }
        .period-button {
            transition: all 0.2s ease;
            position: relative;
            padding: 0.5rem 1rem;
            background: transparent;
            border: none;
            color: #6b7280;
            font-weight: 500;
        }
        .period-button.active {
            color: #7c3aed;
            font-weight: 600;
        }
        .period-button.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #7c3aed;
        }
        .period-button:hover {
            color: #7c3aed;
            background: rgba(124, 58, 237, 0.05);
        }
        .comparison-enabled .chart-section {
            border: 2px solid #3b82f6;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.show {
            display: flex;
        }
        .modal-content {
            background: white;
            border-radius: 1rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease-out;
        }
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .ai-analyzing {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .ai-analyzing .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .sync-icon {
            transition: transform 0.3s ease;
        }
        .sync-icon.syncing {
            animation: rotate 1s ease-in-out;
        }
        @keyframes rotate {
            to { transform: rotate(360deg); }
        }
        .info-icon {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .info-icon:hover {
            transform: scale(1.1);
            color: #3b82f6;
        }
        .tooltip {
            display: none;
            position: absolute;
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            max-width: 400px;
            animation: fadeIn 0.2s ease-out;
        }
        .tooltip.show {
            display: block;
        }
        .help-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        .help-modal.show {
            display: flex;
        }
        .help-content {
            background: white;
            border-radius: 1rem;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease-out;
        }
        .floating-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 320px;
            max-height: calc(100vh - 100px);
            background: white;
            border-radius: 1rem;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            z-index: 1500;
            overflow-y: auto;
            animation: slideInRight 0.3s ease-out;
        }
        .floating-panel.hidden {
            display: none;
        }
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        .stats-inline {
            display: flex;
            justify-content: space-around;
            gap: 0.5rem;
            padding: 0.75rem;
            background: linear-gradient(to right, #f3f4f6, #e5e7eb);
            border-radius: 0.5rem;
            font-size: 0.875rem;
            margin-top: 1rem;
        }
        .stats-inline .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }
        .stats-inline .stat-value {
            font-size: 1.125rem;
            font-weight: bold;
        }
        .stats-inline .stat-value .unit {
            font-size: 0.75rem;
            font-weight: normal;
            opacity: 0.7;
        }
        .stats-inline .stat-label {
            font-size: 0.625rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        .compact-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .compact-buttons {
            display: flex;
            gap: 0.5rem;
        }
        .compact-buttons button {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- 履歴バナー（フルワイド） -->
    <div class="bg-gradient-to-r from-purple-500 to-indigo-600 shadow-md p-3 mb-4">
        <div class="flex items-center justify-between text-white">
            <div class="flex items-center gap-2">
                <i data-lucide="trending-up" class="w-5 h-5"></i>
                <span class="text-lg font-bold">履歴</span>
            </div>
            <button type="button" onclick="closeHistoryPage()" class="p-1 hover:bg-white/20 rounded transition">
                <i data-lucide="x" class="w-6 h-6"></i>
            </button>
        </div>
    </div>

    <div class="max-w-6xl mx-auto px-4">
        <!-- メインコンテナ -->
        <div class="bg-white rounded-lg shadow-lg overflow-hidden">
            <!-- 大カテゴリタブ -->
            <div class="flex border-b bg-gray-50">
                <button type="button"
                    class="tab-button flex-1 py-3 px-2 text-center transition text-green-600 relative"
                    data-category="nutrition"
                    onclick="selectMainCategory('nutrition', event)">
                    <div class="flex flex-col items-center justify-center gap-1">
                        <i data-lucide="utensils" class="w-5 h-5"></i>
                        <div class="text-xs font-semibold whitespace-nowrap">
                            食事
                        </div>
                    </div>
                </button>
                <button type="button"
                    class="tab-button flex-1 py-3 px-2 text-center transition text-orange-600 relative"
                    data-category="training"
                    onclick="selectMainCategory('training', event)">
                    <div class="flex flex-col items-center justify-center gap-1">
                        <i data-lucide="dumbbell" class="w-5 h-5"></i>
                        <div class="text-xs font-semibold whitespace-nowrap">
                            運動
                        </div>
                    </div>
                </button>
                <button type="button"
                    class="tab-button flex-1 py-3 px-2 text-center transition text-red-600 relative"
                    data-category="condition"
                    onclick="selectMainCategory('condition', event)">
                    <div class="flex flex-col items-center justify-center gap-1">
                        <i data-lucide="heart-pulse" class="w-5 h-5"></i>
                        <div class="text-xs font-semibold whitespace-nowrap">
                            コンディション
                        </div>
                    </div>
                </button>
                <button type="button"
                    class="tab-button flex-1 py-3 px-2 text-center transition active text-purple-600 bg-white border-b-0 relative"
                    data-category="performance"
                    onclick="selectMainCategory('performance', event)">
                    <div class="flex flex-col items-center justify-center gap-1">
                        <i data-lucide="trending-up" class="w-5 h-5"></i>
                        <div class="text-xs font-semibold whitespace-nowrap">
                            パフォーマンス
                        </div>
                    </div>
                </button>
                <button type="button"
                    class="tab-button flex-1 py-3 px-2 text-center transition text-yellow-600 relative"
                    data-category="insights"
                    onclick="selectMainCategory('insights', event)">
                    <div class="flex flex-col items-center justify-center gap-1">
                        <i data-lucide="lightbulb" class="w-5 h-5"></i>
                        <div class="text-xs font-semibold whitespace-nowrap">
                            閃き
                        </div>
                    </div>
                </button>
            </div>

            <!-- 小カテゴリタブ（食事） -->
            <div id="nutrition-subtabs" class="sub-tabs border-b bg-green-50 hidden">
                <div class="flex overflow-x-auto px-2 py-1 gap-1">
                <button type="button" class="sub-tab-button active px-2 py-1 bg-white text-green-700 rounded text-xs font-semibold border border-green-500" onclick="selectSubCategory('nutrition', 'nutrition_score')">
                    食事スコア
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'calories')">
                    摂取カロリー
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'protein')">
                    タンパク質
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'fat')">
                    脂質
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'carbs')">
                    炭水化物
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'sugar')">
                    糖質
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'fiber')">
                    食物繊維
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'vitamin_score')">
                    ビタミン
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('nutrition', 'mineral_score')">
                    ミネラル
                </button>
                </div>
            </div>

            <!-- 小カテゴリタブ（運動） -->
            <div id="training-subtabs" class="sub-tabs border-b bg-orange-50 hidden">
                <div class="flex overflow-x-auto px-2 py-1 gap-1">
                <button type="button" class="sub-tab-button active px-2 py-1 bg-white text-orange-700 rounded text-xs font-semibold border border-orange-500" onclick="selectSubCategory('training', 'training_score')">
                    運動スコア
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('training', 'total_time')">
                    総時間
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('training', 'total_exercises')">
                    総種目数
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('training', 'total_weight')">
                    総重量
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('training', 'rm')">
                    RM
                </button>
                </div>
            </div>

            <!-- 小カテゴリタブ（コンディション） -->
            <div id="condition-subtabs" class="sub-tabs border-b bg-red-50 hidden">
                <div class="flex overflow-x-auto px-2 py-1 gap-1">
                <button type="button" class="sub-tab-button active px-2 py-1 bg-white text-red-700 rounded text-xs font-semibold border border-red-500" onclick="selectSubCategory('condition', 'condition_score')">
                    コンディションスコア
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('condition', 'sleep_duration')">
                    睡眠時間
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('condition', 'sleep_quality')">
                    睡眠の質
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('condition', 'appetite')">
                    食欲
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('condition', 'gut_health')">
                    腸内環境
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('condition', 'focus')">
                    集中力
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('condition', 'stress')">
                    ストレス
                </button>
                </div>
            </div>

            <!-- 小カテゴリタブ（パフォーマンス） -->
            <div id="performance-subtabs" class="sub-tabs border-b bg-purple-50">
                <div class="flex overflow-x-auto px-2 py-1 gap-1">
                <button type="button" class="sub-tab-button active px-2 py-1 bg-white text-purple-700 rounded text-xs font-semibold border border-purple-500" onclick="selectSubCategory('performance', 'lbm')">
                    LBM
                </button>
                <button type="button" class="sub-tab-button px-2 py-1 bg-white text-gray-700 rounded text-xs font-semibold border border-transparent hover:border-gray-300" onclick="selectSubCategory('performance', 'directive')">
                    指示書達成率
                </button>
                </div>
            </div>

            <!-- 閃きコンテンツ -->
            <div id="insights-content" class="p-6 hidden">
                <div class="mb-6">
                    <div class="flex items-center justify-between">
                        <h2 class="text-2xl font-bold text-gray-800 flex items-center gap-2">
                            <i data-lucide="lightbulb" class="w-7 h-7 text-yellow-500"></i>
                            閃きメモ一覧
                        </h2>
                        <button
                            type="button"
                            onclick="refreshInsightsList()"
                            class="p-2 hover:bg-gray-100 rounded-full transition"
                            title="最新のデータに更新"
                            id="insights-refresh-button"
                        >
                            <i data-lucide="refresh-cw" class="w-5 h-5 text-gray-600"></i>
                        </button>
                    </div>
                    <p class="text-sm text-gray-600 mt-2">全期間の閃きメモを表示します</p>
                </div>
                <div id="insights-list" class="space-y-3">
                    <!-- JavaScriptで動的に生成 -->
                </div>
            </div>

            <!-- 詳細グラフ表示エリア -->
            <div id="graph-area" class="p-6">
                <!-- グラフ1（メイン） -->
                <div id="chart-1" class="chart-section mb-6">
                    <!-- コンパクトヘッダー -->
                    <div class="mb-3">
                        <div class="flex items-start justify-between">
                            <div>
                                <h3 id="chart-title-1" class="text-2xl font-bold text-gray-800">LBM - 除脂肪体重</h3>
                                <p id="chart-period-1" class="text-sm text-gray-500 mt-1">過去7日間の推移</p>
                            </div>
                            <button
                                type="button"
                                onclick="refreshChart(1)"
                                id="chart-refresh-button-1"
                                class="p-2 hover:bg-gray-100 rounded-full transition"
                                title="最新のデータに更新"
                            >
                                <i data-lucide="refresh-cw" class="w-5 h-5 text-gray-600"></i>
                            </button>
                        </div>
                        <div class="flex gap-2 mt-2 justify-end">
                            <!-- 個別分析ボタン（タブごとに変化） -->
                            <button type="button" id="tab-specific-analysis-btn" onclick="performTabSpecificAnalysis()" class="px-3 py-2 rounded-lg flex items-center gap-2 text-sm font-semibold shadow-sm transition">
                                <i id="tab-analysis-icon" data-lucide="utensils" class="w-4 h-4"></i>
                                <span id="tab-analysis-label">個別分析</span>
                            </button>
                            <!-- 全体分析ボタン（全タブ共通） -->
                            <button type="button" onclick="performHistoryAnalysis()" class="px-3 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg flex items-center gap-2 text-sm font-semibold shadow-sm transition">
                                <i data-lucide="bar-chart-3" class="w-4 h-4"></i>
                                <span>全体分析</span>
                            </button>
                            <!-- 設定ボタン（全タブ共通） -->
                            <button type="button" onclick="toggleSettingsPanel(1)" class="px-3 py-2 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded-lg flex items-center gap-2 text-sm font-semibold transition">
                                <i data-lucide="settings" class="w-4 h-4"></i>
                                <span>設定</span>
                            </button>
                        </div>
                    </div>

                    <!-- RM専用調整パネル -->
                    <div id="rm-control-panel" class="mb-4 p-3 bg-orange-50 rounded-lg border border-orange-200 hidden">
                        <div class="mb-2">
                            <div class="text-xs font-semibold text-orange-900 mb-1">回数を選択</div>
                            <div id="rm-reps-buttons" class="flex flex-wrap gap-1">
                                <!-- 動的に生成 -->
                            </div>
                        </div>
                        <div>
                            <button
                                type="button"
                                onclick="document.getElementById('rm-exercise-list').classList.toggle('hidden'); lucide.createIcons();"
                                class="w-full flex items-center justify-between text-xs font-semibold text-orange-900 mb-1 px-2 py-1 hover:bg-orange-100 rounded transition"
                            >
                                <span>種目を選択</span>
                                <i data-lucide="chevron-down" class="w-3 h-3"></i>
                            </button>
                            <div id="rm-exercise-list" class="hidden">
                                <div id="rm-exercise-buttons" class="flex flex-wrap gap-1 max-h-32 overflow-y-auto">
                                    <!-- 動的に生成 -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 期間選択（タブ式UI） -->
                    <div class="mb-4 border-b border-gray-200">
                        <div class="flex overflow-x-auto">
                            <button type="button" class="period-button active text-sm" onclick="selectPeriod(1, 7, event)">7日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 14, event)">14日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 30, event)">30日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 60, event)">60日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 90, event)">90日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 180, event)">180日</button>
                            <button type="button" class="period-button text-sm" onclick="selectPeriod(1, 365, event)">1年</button>
                        </div>
                    </div>

                    <div style="height: 350px; position: relative;">
                        <canvas id="main-chart-1"></canvas>
                    </div>

                    <!-- 選択されたデータポイントの詳細とナビゲーション -->
                    <div id="selected-point-1" class="mt-3 p-3 bg-white rounded-lg border-2 border-purple-300 shadow-sm">
                        <div class="flex items-center justify-between">
                            <button type="button" onclick="navigateDataPoint(1, -1)" class="p-2 hover:bg-gray-100 rounded-full transition">
                                <i data-lucide="chevron-left" class="w-5 h-5 text-gray-700"></i>
                            </button>
                            <div class="text-center flex-1">
                                <div id="selected-date-1" class="text-sm font-semibold text-gray-800 mb-1"></div>
                                <div id="selected-value-1" class="text-2xl font-bold text-purple-600"></div>
                            </div>
                            <button type="button" onclick="navigateDataPoint(1, 1)" class="p-2 hover:bg-gray-100 rounded-full transition">
                                <i data-lucide="chevron-right" class="w-5 h-5 text-gray-700"></i>
                            </button>
                        </div>
                        <!-- ツールチップ表示/非表示切り替えボタン -->
                        <div class="mt-2 pt-2 border-t border-gray-200">
                            <button type="button" id="tooltip-toggle-1" onclick="toggleTooltip(1)" class="w-full px-3 py-1.5 text-xs font-semibold bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition">
                                <i data-lucide="info" class="w-3 h-3 inline-block mr-1"></i>
                                ツールチップを表示
                            </button>
                        </div>
                    </div>

                    <!-- コンパクトな統計情報（1行） -->
                    <div class="stats-inline">
                        <div class="stat-item">
                            <div class="stat-value text-blue-600" id="stat-avg-1">62.0kg</div>
                            <div class="stat-label">平均<span id="stat-avg-unit-1" class="hidden"></span></div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value text-green-600" id="stat-max-1">62.5kg</div>
                            <div class="stat-label">最高<span id="stat-max-unit-1" class="hidden"></span></div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value text-orange-600" id="stat-min-1">61.0kg</div>
                            <div class="stat-label">最低<span id="stat-min-unit-1" class="hidden"></span></div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value text-purple-600" id="chart-value-1">62.5kg</div>
                            <div class="stat-label">現在<span id="chart-unit-1" class="hidden"></span></div>
                        </div>
                    </div>

                    <!-- 詳細統計情報（標準偏差・トレンド） -->
                    <div class="mt-3 grid grid-cols-2 gap-2">
                        <div class="p-3 bg-gray-50 rounded-lg">
                            <div class="text-xs text-gray-600 mb-1">標準偏差</div>
                            <div class="text-lg font-bold text-gray-800" id="stat-stddev-1">0.5kg</div>
                        </div>
                        <div class="p-3 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200">
                            <div class="text-xs text-gray-600 mb-1">トレンド</div>
                            <div class="flex items-center gap-2">
                                <span class="text-2xl" id="stat-trend-icon-1">→</span>
                                <div>
                                    <div class="text-sm font-bold" id="stat-trend-label-1">横ばい</div>
                                    <div class="text-xs text-gray-600" id="stat-trend-value-1">+0.0kg (0.0%)</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- カテゴリ別範囲表示 -->
                    <div class="mt-3 p-2 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200">
                        <div class="flex items-center justify-between text-xs">
                            <span class="text-gray-600">全期間（50年）の範囲:</span>
                            <span class="font-semibold text-gray-800">
                                <span class="text-orange-600" id="category-min-1">60.0</span>
                                <span class="text-gray-400 mx-1">～</span>
                                <span class="text-green-600" id="category-max-1">63.0</span>
                                <span id="category-unit-1" class="text-gray-500 ml-1">kg</span>
                            </span>
                        </div>
                    </div>

                    <!-- 旧統計情報コンテナ（非表示用・互換性維持） -->
                    <div id="stats-container-1" class="hidden"></div>
                </div>

                <!-- グラフ2（比較用） -->
                <div id="chart-2" class="chart-section hidden">
                    <div class="border-t-2 border-dashed border-gray-300 pt-6 mt-6">
                        <!-- コンパクトヘッダー -->
                        <div class="compact-header">
                            <div>
                                <h3 id="chart-title-2" class="text-2xl font-bold text-gray-800">LBM - 除脂肪体重 - 比較</h3>
                                <p id="chart-period-2" class="text-sm text-gray-500 mt-1">過去30日間の推移</p>
                            </div>
                        </div>

                        <!-- 期間選択（モバイル対応・画面幅に収まる） -->
                        <div class="mb-4">
                            <div class="grid grid-cols-4 gap-1.5">
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 7, event)">7日</button>
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 14, event)">14日</button>
                                <button type="button" class="period-button active px-2 py-1.5 rounded text-xs font-semibold bg-blue-600 text-white shadow-sm transition" onclick="selectPeriod(2, 30, event)">30日</button>
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 60, event)">60日</button>
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 90, event)">90日</button>
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 180, event)">180日</button>
                                <button type="button" class="period-button px-2 py-1.5 rounded text-xs font-semibold bg-white text-gray-700 border border-gray-300 transition" onclick="selectPeriod(2, 365, event)">1年</button>
                            </div>
                        </div>

                        <!-- カテゴリ別範囲表示 -->
                        <div class="mb-3 p-2 bg-gradient-to-r from-blue-50 to-cyan-50 rounded-lg border border-blue-200">
                            <div class="flex items-center justify-between text-xs">
                                <span class="text-gray-600">全期間（50年）の範囲:</span>
                                <span class="font-semibold text-gray-800">
                                    <span class="text-orange-600" id="category-min-2">60.0</span>
                                    <span class="text-gray-400 mx-1">～</span>
                                    <span class="text-green-600" id="category-max-2">63.0</span>
                                    <span id="category-unit-2" class="text-gray-500 ml-1">kg</span>
                                </span>
                            </div>
                        </div>

                        <div style="height: 350px; position: relative;">
                            <canvas id="main-chart-2"></canvas>
                        </div>

                        <!-- コンパクトな統計情報（1行） -->
                        <div class="stats-inline">
                            <div class="stat-item">
                                <div class="stat-value text-blue-600" id="stat-avg-2">61.5kg</div>
                                <div class="stat-label">平均<span id="stat-avg-unit-2" class="hidden"></span></div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value text-green-600" id="stat-max-2">62.5kg</div>
                                <div class="stat-label">最高<span id="stat-max-unit-2" class="hidden"></span></div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value text-orange-600" id="stat-min-2">60.0kg</div>
                                <div class="stat-label">最低<span id="stat-min-unit-2" class="hidden"></span></div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value text-purple-600" id="chart-value-2">62.5kg</div>
                                <div class="stat-label">現在<span id="chart-unit-2" class="hidden"></span></div>
                            </div>
                        </div>

                        <!-- 選択されたデータポイントの詳細とナビゲーション -->
                        <div id="selected-point-2" class="mt-3 p-3 bg-white rounded-lg border-2 border-blue-300 shadow-sm hidden">
                            <div class="flex items-center justify-between">
                                <button type="button" onclick="navigateDataPoint(2, -1)" class="p-2 hover:bg-gray-100 rounded-full transition">
                                    <i data-lucide="chevron-left" class="w-5 h-5 text-gray-700"></i>
                                </button>
                                <div class="text-center flex-1">
                                    <div id="selected-date-2" class="text-sm font-semibold text-gray-800 mb-1"></div>
                                    <div id="selected-value-2" class="text-2xl font-bold text-blue-600"></div>
                                </div>
                                <button type="button" onclick="navigateDataPoint(2, 1)" class="p-2 hover:bg-gray-100 rounded-full transition">
                                    <i data-lucide="chevron-right" class="w-5 h-5 text-gray-700"></i>
                                </button>
                            </div>
                        </div>

                        <!-- 旧統計情報コンテナ（非表示用・互換性維持） -->
                        <div id="stats-container-2" class="hidden"></div>
                    </div>
                </div>
            </div>
        </div>


        <!-- ヘルプモーダル -->
        <div id="help-modal" class="help-modal">
            <div class="help-content">
                <div class="sticky top-0 bg-gradient-to-r from-blue-600 to-cyan-600 text-white p-4 rounded-t-lg">
                    <div class="flex justify-between items-center">
                        <div class="flex items-center gap-2">
                            <i data-lucide="help-circle" class="w-5 h-5"></i>
                            <h3 class="text-lg font-bold">履歴グラフの使い方</h3>
                        </div>
                        <button type="button" onclick="closeHelpModal()" class="p-1 hover:bg-white/20 rounded">
                            <i data-lucide="x" class="w-5 h-5"></i>
                        </button>
                    </div>
                </div>
                <div class="p-6">
                    <div class="space-y-6">
                        <!-- 基本操作 -->
                        <div>
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="mouse-pointer-click" class="w-5 h-5 text-blue-600"></i>
                                基本操作
                            </h4>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600 font-bold">1.</span>
                                    <span><strong>カテゴリタブ</strong>: 食事・運動・コンディション・パフォーマンスを切り替え</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600 font-bold">2.</span>
                                    <span><strong>サブカテゴリタブ</strong>: 各カテゴリ内の詳細指標を選択</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600 font-bold">3.</span>
                                    <span><strong>期間ボタン</strong>: 7日間/14日間/30日間/90日間から表示期間を選択</span>
                                </li>
                            </ul>
                        </div>

                        <!-- 比較モード -->
                        <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="columns-2" class="w-5 h-5 text-blue-600"></i>
                                比較モード
                            </h4>
                            <p class="text-sm text-gray-700 mb-3">
                                2つのグラフを同時に表示し、異なる期間を比較できます。
                            </p>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600">•</span>
                                    <span>例: 上のグラフで「7日間」、下のグラフで「30日間」を選択して短期と長期を比較</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600">•</span>
                                    <span>上のグラフで選択した期間は、下のグラフで選択できません（重複防止）</span>
                                </li>
                            </ul>
                        </div>

                        <!-- Y軸連動 -->
                        <div class="bg-purple-50 p-4 rounded-lg border border-purple-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="refresh-cw" class="w-5 h-5 text-purple-600"></i>
                                Y軸連動機能
                            </h4>
                            <p class="text-sm text-gray-700 mb-3">
                                上のグラフのY軸範囲を変更すると、下のグラフも自動で同じ範囲に調整されます。
                            </p>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>ONの場合</strong>: 上下のグラフで同じスケールを使用（比較しやすい）</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>OFFの場合</strong>: 上下のグラフで独立したスケールを使用</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span>チェックボックスをクリックでON/OFF切り替え可能</span>
                                </li>
                            </ul>
                        </div>

                        <!-- Y軸範囲調整 -->
                        <div>
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="sliders-horizontal" class="w-5 h-5 text-green-600"></i>
                                Y軸範囲の調整
                            </h4>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">•</span>
                                    <span><strong>デフォルト</strong>: 全期間（90日間）の最低値～最高値を基準に自動設定</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">•</span>
                                    <span><strong>手動調整</strong>: 「最小値」「最大値」の入力欄に数値を入力して表示範囲を変更</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">•</span>
                                    <span><strong>初期値に戻す</strong>: ボタンをクリックでデフォルトの範囲に戻す</span>
                                </li>
                            </ul>
                        </div>

                        <!-- AI分析 -->
                        <div class="bg-gradient-to-r from-purple-50 to-blue-50 p-4 rounded-lg border border-purple-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="sparkles" class="w-5 h-5 text-purple-600"></i>
                                AI分析機能
                            </h4>
                            <p class="text-sm text-gray-700 mb-3">
                                Gemini AIがグラフデータを分析し、トレンド評価・改善提案を生成します。
                            </p>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>トレンド分析</strong>: 増加/減少/横ばいを判定し理由を説明</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>目標達成予測</strong>: 現在のペースで目標達成までの日数を予測</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>改善提案</strong>: 具体的なアクション（食事/運動/休養）を3つ提示</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>注意点</strong>: データから気をつけるべきポイントを抽出</span>
                                </li>
                            </ul>
                        </div>

                        <!-- 統計情報 -->
                        <div>
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="bar-chart-3" class="w-5 h-5 text-orange-600"></i>
                                統計情報の見方
                            </h4>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-blue-600">•</span>
                                    <span><strong>平均</strong>: 選択期間内の平均値</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">•</span>
                                    <span><strong>最高</strong>: 選択期間内の最高値</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-orange-600">•</span>
                                    <span><strong>最低</strong>: 選択期間内の最低値</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-purple-600">•</span>
                                    <span><strong>指示書達成状況</strong>: 達成率（%）、完了日数、未完了日数を表示</span>
                                </li>
                            </ul>
                        </div>

                        <!-- データ保存（スクリーンショット推奨） -->
                        <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="camera" class="w-5 h-5 text-green-600"></i>
                                データ保存方法
                            </h4>
                            <p class="text-sm text-gray-700 mb-3">
                                グラフをスクリーンショットで保存することを推奨します：
                            </p>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">📸</span>
                                    <span><strong>Windows</strong>: Win + Shift + S（画面の一部を選択）</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">📸</span>
                                    <span><strong>Mac</strong>: Cmd + Shift + 4（画面の一部を選択）</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-green-600">📸</span>
                                    <span><strong>ブラウザ</strong>: 右クリック → 「ページのスクリーンショットを撮る」（Firefox）</span>
                                </li>
                            </ul>
                        </div>

                        <!-- 新機能（移動平均・重ね合わせ） -->
                        <div class="bg-gradient-to-r from-orange-50 to-yellow-50 p-4 rounded-lg border border-orange-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="sparkles" class="w-5 h-5 text-orange-600"></i>
                                新機能
                            </h4>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2 bg-white p-2 rounded">
                                    <span class="text-orange-600 font-bold">NEW</span>
                                    <div>
                                        <strong>移動平均線</strong>
                                        <p class="text-xs text-gray-600 mt-1">一定期間の平均値を線で表示し、ノイズを除去してトレンドを明確に把握できます。3日/5日/7日/14日/30日から選択可能。</p>
                                    </div>
                                </li>
                                <li class="flex items-start gap-2 bg-white p-2 rounded">
                                    <span class="text-orange-600 font-bold">NEW</span>
                                    <div>
                                        <strong>複数指標の重ね合わせ</strong>
                                        <p class="text-xs text-gray-600 mt-1">最大3つの指標を1つのグラフに表示し、相関関係を分析できます。例: LBMと総合スコアの関係を確認。</p>
                                    </div>
                                </li>
                                <li class="flex items-start gap-2 bg-white p-2 rounded">
                                    <span class="text-green-600 font-bold">強化</span>
                                    <div>
                                        <strong>目標ライン表示</strong>
                                        <p class="text-xs text-gray-600 mt-1">各指標に目標値を設定すると、グラフに緑色の点線で表示されます。達成度が一目瞭然。</p>
                                    </div>
                                </li>
                                <li class="flex items-start gap-2 bg-white p-2 rounded">
                                    <span class="text-green-600 font-bold">強化</span>
                                    <div>
                                        <strong>メモ機能</strong>
                                        <p class="text-xs text-gray-600 mt-1">グラフ上のポイントをクリックしてメモを追加。チートデイ、体調不良などを記録し、データとの相関を確認できます。</p>
                                    </div>
                                </li>
                            </ul>
                        </div>

                        <!-- ヒント -->
                        <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-200">
                            <h4 class="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i data-lucide="lightbulb" class="w-5 h-5 text-yellow-600"></i>
                                活用ヒント
                            </h4>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>短期（7日間）で細かい変化を確認し、長期（30-90日間）で全体的なトレンドを把握しましょう</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>比較モードで短期と長期を並べて表示すると、一時的な変動と本当のトレンドを区別できます</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>Y軸範囲を調整することで、小さな変化も大きく表示でき、微細なトレンドを発見できます</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>移動平均線（7日）を表示すると、日々の変動に惑わされず、本当のトレンドが見えてきます</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>複数指標を重ね合わせて、因果関係を発見しましょう（例: 体重とカロリーの関係）</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>AI分析は定期的に実行し、客観的なフィードバックを受けることで改善につなげましょう</span>
                                </li>
                                <li class="flex items-start gap-2">
                                    <span class="text-yellow-600">💡</span>
                                    <span>グラフにメモ（📝）を追加して、特別な日（チートデイ、風邪など）を記録できます</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ツールチップ -->
        <div id="tooltip" class="tooltip"></div>

        <!-- フローティング設定パネル -->
        <div id="settings-panel" class="floating-panel hidden">
            <div class="sticky top-0 bg-gradient-to-r from-gray-700 to-gray-600 text-white p-4 rounded-t-xl">
                <div class="flex justify-between items-center">
                    <div class="flex items-center gap-2">
                        <i data-lucide="settings" class="w-5 h-5"></i>
                        <h3 class="text-lg font-bold">グラフ設定</h3>
                    </div>
                    <button type="button" onclick="closeSettingsPanel()" class="p-1 hover:bg-white/20 rounded">
                        <i data-lucide="x" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>

            <div class="p-4 space-y-6">
                <!-- アクションボタン -->
                <div class="grid grid-cols-2 gap-2">
                    <button type="button" onclick="openGoalSettingModal(); closeSettingsPanel();" class="flex items-center justify-center gap-2 px-4 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600 transition font-semibold text-sm">
                        <i data-lucide="target" class="w-4 h-4"></i>
                        目標設定
                    </button>
                    <button type="button" onclick="openHelpModal(); closeSettingsPanel();" class="flex items-center justify-center gap-2 px-4 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition font-semibold text-sm">
                        <i data-lucide="help-circle" class="w-4 h-4"></i>
                        使い方
                    </button>
                </div>

                <!-- カスタム期間設定 -->
                <div>
                    <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="calendar" class="w-4 h-4 text-indigo-600"></i>
                        カスタム期間
                    </h4>
                    <div class="space-y-2">
                        <div>
                            <label class="text-xs text-gray-600 block mb-1">開始日</label>
                            <input type="text" id="custom-start-panel" placeholder="開始日を選択" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                        </div>
                        <div>
                            <label class="text-xs text-gray-600 block mb-1">終了日</label>
                            <input type="text" id="custom-end-panel" placeholder="終了日を選択" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                        </div>
                        <button type="button" onclick="applyCustomPeriodFromPanel()" class="w-full px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition font-semibold text-sm">
                            適用
                        </button>
                    </div>
                </div>

                <!-- Y軸範囲設定 -->
                <div>
                    <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="sliders-horizontal" class="w-4 h-4 text-green-600"></i>
                        Y軸範囲
                    </h4>
                    <div class="space-y-2">
                        <div>
                            <label class="text-xs text-gray-600 block mb-1">最小値</label>
                            <input type="number" id="axis-min-panel" step="0.1" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent" onchange="updateAxisRangeFromPanel()">
                        </div>
                        <div>
                            <label class="text-xs text-gray-600 block mb-1">最大値</label>
                            <input type="number" id="axis-max-panel" step="0.1" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent" onchange="updateAxisRangeFromPanel()">
                        </div>
                        <button type="button" onclick="resetAxisRangeFromPanel()" class="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition font-semibold text-sm">
                            初期値に戻す
                        </button>
                    </div>
                </div>

                <!-- 表示オプション -->
                <div>
                    <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="eye" class="w-4 h-4 text-purple-600"></i>
                        表示オプション
                    </h4>
                    <div class="space-y-3">
                        <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                            <div class="flex items-center gap-2">
                                <i data-lucide="columns-2" class="w-4 h-4 text-blue-600"></i>
                                <label for="comparison-mode-panel" class="text-sm font-semibold text-gray-700">比較モード</label>
                            </div>
                            <input type="checkbox" id="comparison-mode-panel" class="w-4 h-4" onchange="toggleComparisonMode()">
                        </div>
                        <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                            <div class="flex items-center gap-2">
                                <i data-lucide="refresh-cw" class="w-4 h-4 text-purple-600"></i>
                                <label for="sync-axis-panel" class="text-sm font-semibold text-gray-700">Y軸連動</label>
                            </div>
                            <input type="checkbox" id="sync-axis-panel" class="w-4 h-4" checked onchange="toggleAxisSync()">
                        </div>
                        <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                            <div class="flex items-center gap-2">
                                <i data-lucide="trending-up" class="w-4 h-4 text-orange-600"></i>
                                <label for="moving-average-panel" class="text-sm font-semibold text-gray-700">移動平均線</label>
                            </div>
                            <input type="checkbox" id="moving-average-panel" class="w-4 h-4" onchange="toggleMovingAverage(1)">
                        </div>
                        <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                            <div class="flex items-center gap-2">
                                <i data-lucide="arrow-right" class="w-4 h-4 text-green-600"></i>
                                <label for="prediction-panel" class="text-sm font-semibold text-gray-700">予測線（7日先）</label>
                            </div>
                            <input type="checkbox" id="prediction-panel" class="w-4 h-4" onchange="togglePrediction(1)">
                        </div>
                    </div>
                </div>

                <!-- 移動平均期間 -->
                <div>
                    <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="calendar" class="w-4 h-4 text-indigo-600"></i>
                        移動平均期間
                    </h4>
                    <div class="space-y-2">
                        <select id="ma-period-panel" onchange="changeMovingAveragePeriod(1, this.value)" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                            <option value="3">3日</option>
                            <option value="5">5日</option>
                            <option value="7" selected>7日</option>
                            <option value="14">14日</option>
                            <option value="30">30日</option>
                        </select>
                    </div>
                </div>

                <!-- 下グラフのカテゴリ選択 -->
                <div>
                    <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="bar-chart-2" class="w-4 h-4 text-blue-600"></i>
                        下グラフのカテゴリ
                    </h4>
                    <div class="space-y-2">
                        <select id="chart2-category-panel" onchange="changeChart2Category(this.value)" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <option value="lbm" selected>LBM - 除脂肪体重</option>
                            <option value="directive">📋 指示書達成状況</option>
                            <option value="overall">🎯 総合分析スコア</option>
                        </select>
                        <p class="text-xs text-gray-500">比較モードON時、上グラフと異なる指標を表示できます</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 目標設定モーダル -->
        <div id="goal-setting-modal" class="modal">
            <div class="modal-content">
                <div class="sticky top-0 bg-gradient-to-r from-green-600 to-teal-600 text-white p-4 rounded-t-lg">
                    <div class="flex justify-between items-center">
                        <div class="flex items-center gap-2">
                            <i data-lucide="target" class="w-5 h-5"></i>
                            <h3 class="text-lg font-bold">目標設定</h3>
                        </div>
                        <button type="button" onclick="closeGoalSettingModal()" class="p-1 hover:bg-white/20 rounded">
                            <i data-lucide="x" class="w-5 h-5"></i>
                        </button>
                    </div>
                </div>
                <div class="p-6">
                    <div class="space-y-4">
                        <!-- 指標選択 -->
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">目標を設定する指標</label>
                            <select id="goal-metric" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent">
                                <option value="lbm">LBM - 除脂肪体重</option>
                                <option value="overall">🎯 総合分析スコア</option>
                            </select>
                        </div>

                        <!-- 目標値 -->
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">目標値</label>
                            <div class="flex items-center gap-2">
                                <input type="number" id="goal-value" step="0.1" placeholder="例: 65.0" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent">
                                <span id="goal-unit" class="text-gray-600 font-semibold">kg</span>
                            </div>
                        </div>

                        <!-- 達成予定日 -->
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">達成予定日（任意）</label>
                            <input type="date" id="goal-date" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent">
                        </div>

                        <!-- グラフに表示するか -->
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="goal-show-line" checked class="w-4 h-4">
                            <label for="goal-show-line" class="text-sm font-semibold text-gray-700">グラフに目標ラインを表示</label>
                        </div>

                        <!-- 現在の目標 -->
                        <div id="current-goal-info" class="bg-blue-50 p-4 rounded-lg border border-blue-200 hidden">
                            <h4 class="text-sm font-bold text-blue-700 mb-2">現在の目標</h4>
                            <div id="current-goal-text" class="text-sm text-gray-700"></div>
                        </div>

                        <!-- ボタン -->
                        <div class="flex gap-3">
                            <button type="button" onclick="saveGoal()" class="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition flex items-center justify-center gap-2 font-semibold">
                                <i data-lucide="check" class="w-4 h-4"></i>
                                目標を保存
                            </button>
                            <button type="button" onclick="clearGoal()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition font-semibold">
                                クリア
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- ドリルダウンモーダル -->
    <div id="drilldown-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden" onclick="closeDrillDownModal()">
        <div class="bg-white rounded-lg shadow-2xl w-11/12 max-w-2xl max-h-[90vh] overflow-y-auto" onclick="event.stopPropagation()">
            <!-- モーダルヘッダー -->
            <div class="sticky top-0 bg-gradient-to-r from-purple-600 to-blue-600 text-white p-4 rounded-t-lg flex items-center justify-between z-10">
                <div class="flex items-center gap-3">
                    <i data-lucide="calendar" class="w-6 h-6"></i>
                    <div>
                        <h3 class="text-xl font-bold" id="drilldown-title">詳細情報</h3>
                        <p class="text-sm opacity-90" id="drilldown-subtitle">日付と値</p>
                    </div>
                </div>
                <button type="button" onclick="closeDrillDownModal()" class="p-2 hover:bg-white hover:bg-opacity-20 rounded-full transition">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>

            <!-- モーダルコンテンツ -->
            <div class="p-6">
                <!-- メトリクス情報 -->
                <div class="bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg p-4 mb-4 border border-purple-200">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-sm text-gray-600 mb-1">指標</p>
                            <p class="text-2xl font-bold text-purple-700" id="drilldown-metric"></p>
                        </div>
                        <div class="text-right">
                            <p class="text-sm text-gray-600 mb-1">値</p>
                            <p class="text-3xl font-bold text-blue-700" id="drilldown-value"></p>
                        </div>
                    </div>
                </div>

                <!-- メモセクション -->
                <div class="bg-gray-50 rounded-lg p-4 mb-4">
                    <h4 class="font-semibold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="message-square" class="w-4 h-4 text-orange-600"></i>
                        メモ
                    </h4>
                    <div id="drilldown-memo-display" class="mb-3 hidden">
                        <div class="bg-white p-3 rounded border border-gray-200">
                            <p class="text-sm text-gray-700" id="drilldown-memo-text"></p>
                        </div>
                    </div>
                    <div id="drilldown-memo-empty" class="text-sm text-gray-500 italic mb-3">
                        このデータポイントにはメモがありません
                    </div>
                    <button type="button"
                        onclick="toggleMemoEdit()"
                        class="text-sm px-3 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition flex items-center gap-2">
                        <i data-lucide="edit" class="w-4 h-4"></i>
                        <span id="memo-edit-button-text">メモを追加</span>
                    </button>
                    <div id="drilldown-memo-edit" class="mt-3 hidden">
                        <textarea
                            id="drilldown-memo-input"
                            rows="3"
                            placeholder="メモを入力してください（例: チートデイ、体調不良など）"
                            class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-orange-500"></textarea>
                        <div class="flex gap-2 mt-2">
                            <button type="button"
                                onclick="saveMemo()"
                                class="flex-1 px-3 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition text-sm font-semibold">
                                保存
                            </button>
                            <button type="button"
                                onclick="deleteMemo()"
                                class="px-3 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition text-sm font-semibold">
                                削除
                            </button>
                            <button type="button"
                                onclick="toggleMemoEdit()"
                                class="px-3 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition text-sm font-semibold">
                                キャンセル
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 関連データ（将来の拡張用） -->
                <div class="bg-blue-50 rounded-lg p-4">
                    <h4 class="font-semibold text-gray-800 mb-3 flex items-center gap-2">
                        <i data-lucide="info" class="w-4 h-4 text-blue-600"></i>
                        この日の情報
                    </h4>
                    <p class="text-sm text-gray-600">
                        より詳細な情報（食事、トレーニングなど）は、メインアプリの「履歴」タブから確認できます。
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- 履歴分析ローディングモーダル -->
    <div id="history-analysis-loading-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[9999] flex items-center justify-center">
        <div class="bg-white rounded-2xl p-8 text-center max-w-sm mx-4">
            <div class="mb-4">
                <div class="inline-block animate-spin rounded-full h-16 w-16 border-4 border-purple-200 border-t-purple-600"></div>
            </div>
            <h3 class="text-xl font-bold text-gray-800 mb-2">分析中...</h3>
            <p class="text-sm text-gray-600">期間データを分析しています</p>
        </div>
    </div>

    <!-- 履歴分析レポートモーダル -->
    <div id="history-analysis-report-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[9999] flex items-center justify-center p-4">
        <div class="bg-white rounded-2xl w-full max-w-3xl max-h-[90vh] overflow-hidden flex flex-col">
            <!-- ヘッダー -->
            <div class="p-6 border-b bg-gradient-to-r from-purple-600 to-blue-600 text-white">
                <div class="flex justify-between items-start mb-2">
                    <h2 class="text-2xl font-bold">📊 期間分析レポート</h2>
                    <button onclick="closeHistoryAnalysisModal()" class="p-2 hover:bg-white/20 rounded-full transition">
                        <i data-lucide="x" class="w-6 h-6"></i>
                    </button>
                </div>
                <p class="text-sm opacity-90" id="history-analysis-period"></p>
            </div>

            <!-- レポート内容 -->
            <div class="flex-1 overflow-y-auto p-6">
                <div id="history-analysis-report-content" class="prose max-w-none">
                    <!-- AIレポートがここに表示される -->
                </div>
            </div>

            <!-- 質問入力エリア -->
            <div class="border-t bg-gray-50 p-4">
                <div class="flex items-center gap-2">
                    <input
                        type="text"
                        id="history-analysis-question-input"
                        placeholder="このデータについて質問する..."
                        class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
                        onkeypress="if(event.key==='Enter') askHistoryAnalysisQuestion()"
                    />
                    <button
                        onclick="askHistoryAnalysisQuestion()"
                        class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition"
                    >
                        <i data-lucide="send" class="w-5 h-5"></i>
                    </button>
                </div>
                <div id="history-analysis-answer" class="mt-3 hidden">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
                        <p class="text-sm font-semibold text-blue-900 mb-1">💬 回答</p>
                        <p id="history-analysis-answer-text" class="text-sm text-gray-700"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== Firebase初期化 =====
        let auth, db, storage, functions;
        if (!DEV_MODE) {
            if (!firebase.apps.length) {
                firebase.initializeApp(FIREBASE_CONFIG);
            }
            auth = firebase.auth();
            db = firebase.firestore();
            storage = firebase.storage();
            functions = firebase.functions();
        }

        // Lucideアイコン初期化
        lucide.createIcons();

        let currentMainCategory = 'performance';
        let currentSubCategory = 'lbm';
        let comparisonMode = false;
        let axisSync = true; // Y軸連動ON/OFF
        let charts = { 1: null, 2: null };
        let currentPeriods = { 1: 7, 2: 30 };
        let currentAxisRanges = { 1: { min: null, max: null }, 2: { min: null, max: null } };
        let globalMinMax = { min: 0, max: 100 }; // 全期間の最低値・最大値
        let currentData = { 1: [], 2: [] };
        let goals = {}; // 目標データ（LocalStorageから読み込み）
        let annotations = {}; // アノテーション（メモ）データ
        let showMovingAverage = { 1: false, 2: false }; // 移動平均線表示
        let selectedDataIndex = { 1: null, 2: null }; // 選択されたデータポイントのインデックス
        let movingAveragePeriod = { 1: 7, 2: 7 }; // 移動平均の期間
        let showPrediction = { 1: false, 2: false }; // 予測線表示
        let chart2Category = 'lbm'; // Chart2の表示カテゴリ

        // ドリルダウンモーダル用の変数
        let currentDrillDownData = {
            chartNum: null,
            index: null,
            label: null,
            value: null,
            metric: null,
            annotationKey: null
        };

        // クロスヘア用の変数
        let crosshairPosition = { x: null, y: null };
        let showCrosshair = false;

        // 閃きメモデータを保存する変数（日付 -> メモのマップ）
        let dailyNotes = {};

        // 指標の日本語名とメタ情報
        const metricInfo = {
            // パフォーマンス
            lbm: { name: 'LBM - 除脂肪体重', unit: 'kg', category: 'performance' },
            directive: { name: '指示書達成状況', unit: '', isBinary: true, category: 'performance' },

            // 食事
            nutrition_score: { name: '食事スコア', unit: '点', category: 'nutrition' },
            calories: { name: '摂取カロリー', unit: 'kcal', category: 'nutrition' },
            protein: { name: 'タンパク質', unit: 'g', category: 'nutrition' },
            fat: { name: '脂質', unit: 'g', category: 'nutrition' },
            carbs: { name: '炭水化物', unit: 'g', category: 'nutrition' },
            sugar: { name: '糖質', unit: 'g', category: 'nutrition' },
            fiber: { name: '食物繊維', unit: 'g', category: 'nutrition' },
            solubleFiber: { name: '水溶性食物繊維', unit: 'g', category: 'nutrition' },
            insolubleFiber: { name: '不溶性食物繊維', unit: 'g', category: 'nutrition' },
            gi: { name: '平均GI値', unit: '', category: 'nutrition' },
            vitamin_score: { name: 'ビタミン達成率', unit: '%', category: 'nutrition' },
            mineral_score: { name: 'ミネラル達成率', unit: '%', category: 'nutrition' },

            // 運動
            training_score: { name: '運動スコア', unit: '点', category: 'training' },
            total_time: { name: '総時間', unit: '分', category: 'training' },
            total_exercises: { name: '総種目数', unit: '種目', category: 'training' },
            total_weight: { name: '総重量', unit: 'kg', category: 'training' },

            // コンディション
            condition_score: { name: 'コンディションスコア', unit: '点', category: 'condition' },

            // コンディション
            sleep_duration: {
                name: '睡眠時間',
                unit: '',
                category: 'condition',
                getLabel: (value) => {
                    const labels = ['未記録', '5h以下', '6h', '7h', '8h', '9h以上'];
                    return labels[value] || `${value}点`;
                }
            },
            sleep_quality: {
                name: '睡眠の質',
                unit: '',
                category: 'condition',
                getLabel: (value) => {
                    const labels = ['未記録', '最悪', '悪', '普通', '良', '最高'];
                    return labels[value] || `${value}点`;
                }
            },
            appetite: {
                name: '食欲',
                unit: '',
                category: 'condition',
                getLabel: (value) => {
                    const labels = ['未記録', 'なし', '少', '普通', '良好', '最高'];
                    return labels[value] || `${value}点`;
                }
            },
            gut_health: {
                name: '腸内環境',
                unit: '',
                category: 'condition',
                getLabel: (value) => {
                    const labels = ['未記録', '不調', 'やや悪', '普通', '良好', '最高'];
                    return labels[value] || `${value}点`;
                }
            },
            focus: {
                name: '集中力',
                unit: '',
                category: 'condition',
                getLabel: (value) => {
                    const labels = ['未記録', '最低', '低', '普通', '高', '最高'];
                    return labels[value] || `${value}点`;
                }
            },
            stress: {
                name: 'ストレス',
                unit: '',
                category: 'condition',
                getLabel: (value) => {
                    const labels = ['未記録', '極大', '高', '普通', '低', 'なし'];
                    return labels[value] || `${value}点`;
                }
            }
        };

        // 実際のデータを読み込む関数
        async function loadRealData() {
            const userId = window.currentUser?.uid || 'demo_user';
            const allData = {
                // パフォーマンス
                lbm: [],
                directive: [],
                // 食事
                nutrition_score: [],
                calories: [],
                protein: [],
                fat: [],
                carbs: [],
                sugar: [],
                fiber: [],
                solubleFiber: [],
                insolubleFiber: [],
                gi: [],
                vitamin_score: [],
                mineral_score: [],
                // 運動
                training_score: [],
                total_time: [],
                total_exercises: [],
                total_weight: [],
                rm: {}, // 回数×種目別のRM記録
                // コンディション
                condition_score: [],
                sleep_duration: [],
                sleep_quality: [],
                appetite: [],
                gut_health: [],
                focus: [],
                stress: []
            };

            // ローカルタイムゾーンで日付を取得する関数
            const getLocalDateString = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            // 全期間のデータを取得（登録日から現在まで）
            const today = getLocalDateString(new Date());
            console.log('[履歴データ取得] 開始 - userId:', userId, 'today:', today);

            // ユーザープロフィールから登録日を取得
            const userProfileKey = typeof STORAGE_KEYS !== 'undefined' ? STORAGE_KEYS.USER_PROFILE : 'yourCoachBeta_userProfile';
            const userProfile = JSON.parse(localStorage.getItem(userProfileKey) || '{}');
            const registrationDate = userProfile.registrationDate || userProfile.createdAt || userProfile.joinDate;

            let startDate;
            if (registrationDate) {
                startDate = new Date(registrationDate);
                console.log('[履歴データ取得] 登録日から取得:', registrationDate);
            } else {
                // 登録日が取得できない場合は90日前をデフォルトとする
                startDate = new Date();
                startDate.setDate(startDate.getDate() - 89);
                console.log('[履歴データ取得] 登録日不明のため90日前から取得');
            }

            // 登録日から今日までの日数を計算
            const todayDate = new Date();
            const daysDiff = Math.floor((todayDate - startDate) / (1000 * 60 * 60 * 24));
            console.log('[履歴データ取得] 取得期間:', daysDiff + 1, '日間');

            // LocalStorageの内容を確認（DEV_MODE用）
            if (typeof DEV_MODE !== 'undefined' && DEV_MODE) {
                const storageKey = typeof STORAGE_KEYS !== 'undefined' ? STORAGE_KEYS.DAILY_RECORDS : 'yourCoachBeta_dailyRecords';
                const saved = localStorage.getItem(storageKey);
                if (saved) {
                    const records = JSON.parse(saved);
                    console.log('[履歴データ取得] LocalStorage内の日付一覧:', Object.keys(records));
                    console.log('[履歴データ取得] 今日のデータ:', records[today]);
                } else {
                    console.log('[履歴データ取得] LocalStorageにデータなし');
                }
            }

            for (let i = daysDiff; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                const dateStr = getLocalDateString(date);

                let record = null;
                if (typeof DataService !== 'undefined') {
                    record = await DataService.getDailyRecord(userId, dateStr);
                }

                if (record) {
                    console.log(`[履歴データ取得] ${dateStr} (${i}日前): meals=${record.meals?.length || 0}, workouts=${record.workouts?.length || 0}, conditions=${record.conditions ? 'あり' : 'なし'}`);
                } else if (i <= 7) {
                    // 過去7日分はログ出力（デバッグ用）
                    console.log(`[履歴データ取得] ${dateStr} (${i}日前): データなし`);
                }

                if (record) {
                    // 食事データ - mealsから集計
                    const meals = record.meals || [];
                    let totalCalories = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0, totalSugar = 0, totalFiber = 0;
                    let totalSolubleFiber = 0, totalInsolubleFiber = 0, totalGI = 0, totalCarbsForGI = 0;
                    meals.forEach(meal => {
                        totalCalories += meal.calories || 0;
                        // meal.itemsから詳細な栄養素を集計（ratioを考慮）
                        (meal.items || []).forEach(item => {
                            // 個数単位と重量単位でratio計算を分岐（ダッシュボードと同じロジック）
                            const isCountUnit = ['本', '個', '杯', '枚', '錠'].some(u => (item.unit || '').includes(u));
                            const ratio = isCountUnit ? (item.amount || 0) : (item.amount || 0) / 100;

                            totalProtein += (item.protein || 0) * ratio;
                            totalFat += (item.fat || 0) * ratio;
                            totalCarbs += (item.carbs || 0) * ratio;
                            totalSugar += (item.sugar || 0) * ratio;
                            totalFiber += (item.fiber || 0) * ratio;
                            totalSolubleFiber += (item.solubleFiber || 0) * ratio;
                            totalInsolubleFiber += (item.insolubleFiber || 0) * ratio;

                            // GI値の加重平均計算
                            if (item.gi && item.carbs) {
                                totalGI += (item.gi || 0) * (item.carbs || 0) * ratio;
                                totalCarbsForGI += (item.carbs || 0) * ratio;
                            }
                        });
                    });
                    allData.calories.push(totalCalories);
                    allData.protein.push(totalProtein);
                    allData.fat.push(totalFat);
                    allData.carbs.push(totalCarbs);
                    allData.sugar.push(totalSugar);
                    allData.fiber.push(totalFiber);
                    allData.solubleFiber.push(totalSolubleFiber);
                    allData.insolubleFiber.push(totalInsolubleFiber);
                    allData.gi.push(totalCarbsForGI > 0 ? totalGI / totalCarbsForGI : 0);

                    // ビタミン・ミネラル達成率を計算
                    let vitaminScore = 0;
                    let mineralScore = 0;

                    if (record.micronutrients) {
                        // ビタミン達成率（13種類のビタミンの平均）
                        const vitamins = ['A', 'D', 'E', 'K', 'B1', 'B2', 'B3', 'B5', 'B6', 'B7', 'B9', 'B12', 'C'];
                        let vitaminCount = 0;
                        let vitaminSum = 0;
                        vitamins.forEach(v => {
                            const key = `vitamin${v}`;
                            if (record.micronutrients[key] !== undefined) {
                                const target = record.micronutrients[`${key}Target`] || 1;
                                const achievement = (record.micronutrients[key] / target) * 100;
                                vitaminSum += Math.min(achievement, 100); // 100%を上限
                                vitaminCount++;
                            }
                        });
                        vitaminScore = vitaminCount > 0 ? vitaminSum / vitaminCount : 0;

                        // ミネラル達成率（13種類のミネラルの平均）
                        // ダッシュボードではフルネーム（sodium, potassium等）で保存されている
                        const minerals = ['sodium', 'potassium', 'calcium', 'magnesium', 'phosphorus', 'iron', 'zinc', 'copper', 'manganese', 'iodine', 'selenium', 'chromium', 'molybdenum'];
                        let mineralCount = 0;
                        let mineralSum = 0;
                        minerals.forEach(key => {
                            if (record.micronutrients[key] !== undefined) {
                                const target = record.micronutrients[`${key}Target`] || 1;
                                const achievement = (record.micronutrients[key] / target) * 100;
                                mineralSum += Math.min(achievement, 100); // 100%を上限
                                mineralCount++;
                            }
                        });
                        mineralScore = mineralCount > 0 ? mineralSum / mineralCount : 0;
                    }

                    allData.vitamin_score.push(Math.round(vitaminScore));
                    allData.mineral_score.push(Math.round(mineralScore));

                    // 運動データ - workoutsから集計
                    const workouts = record.workouts || [];
                    let totalTime = 0, totalExercises = workouts.length, totalWeight = 0;
                    const rmData = {}; // 回数×種目別のRMデータ

                    workouts.forEach(workout => {
                        totalTime += workout.duration || 0;

                        // exercisesプロパティがある場合（新形式）
                        if (workout.exercises) {
                            workout.exercises.forEach(exercise => {
                                const exerciseName = exercise.exercise?.name || exercise.name || 'unknown';

                                (exercise.sets || []).forEach(set => {
                                    const weight = set.weight || 0;
                                    const reps = set.reps || 0;
                                    totalWeight += weight * reps;

                                    // RM記録があればそちらを使用（優先）
                                    if (set.rm && set.rmWeight) {
                                        const key = `${set.rm}_${exerciseName}`;
                                        rmData[key] = Math.max(rmData[key] || 0, set.rmWeight);
                                    }
                                    // RM記録がない場合は通常のセットデータから推定
                                    else if (reps > 0 && weight > 0) {
                                        const key = `${reps}_${exerciseName}`;
                                        rmData[key] = Math.max(rmData[key] || 0, weight);
                                    }
                                });
                            });
                        }
                        // 旧形式（setsが直接workoutの下にある）
                        else {
                            const exerciseName = workout.name || 'unknown';

                            (workout.sets || []).forEach(set => {
                                const weight = set.weight || 0;
                                const reps = set.reps || 0;
                                totalWeight += weight * reps;

                                // RM記録があればそちらを使用（優先）
                                if (set.rm && set.rmWeight) {
                                    const key = `${set.rm}_${exerciseName}`;
                                    rmData[key] = Math.max(rmData[key] || 0, set.rmWeight);
                                }
                                // RM記録がない場合は通常のセットデータから推定
                                else if (reps > 0 && weight > 0) {
                                    const key = `${reps}_${exerciseName}`;
                                    rmData[key] = Math.max(rmData[key] || 0, weight);
                                }
                            });
                        }
                    });
                    allData.total_time.push(totalTime);
                    allData.total_exercises.push(totalExercises);
                    allData.total_weight.push(totalWeight);

                    // RM記録を保存（すべての回数×種目の組み合わせ）
                    for (const key in rmData) {
                        if (!allData.rm) allData.rm = {};
                        if (!allData.rm[key]) allData.rm[key] = [];
                        allData.rm[key].push(rmData[key]);
                    }
                    // この日に記録がないRM種目には0を追加
                    if (allData.rm) {
                        for (const key in allData.rm) {
                            if (!rmData[key]) {
                                allData.rm[key].push(0);
                            }
                        }
                    }

                    // コンディションデータ - conditionsから取得
                    const conditions = record.conditions || {};
                    allData.sleep_duration.push(conditions.sleepHours || 0);
                    allData.sleep_quality.push(conditions.sleepQuality || 0);
                    allData.appetite.push(conditions.appetite || 0);
                    allData.gut_health.push(conditions.digestion || 0);
                    allData.focus.push(conditions.focus || 0);
                    allData.stress.push(conditions.stress || 0);

                    // パフォーマンスデータ - 体組成から取得
                    // まずrecord.bodyCompositionを確認、なければuserProfileから取得
                    let weight = 0, bodyFat = 0;
                    if (record.bodyComposition) {
                        weight = record.bodyComposition.weight || 0;
                        bodyFat = record.bodyComposition.bodyFatPercentage || 0;
                        console.log(`[履歴グラフ] ${dateStr} 体組成: weight=${weight}, bodyFat=${bodyFat}`, record.bodyComposition);
                    } else if (window.currentUser) {
                        // userProfileから取得（フォールバック）
                        const userProfileKey = typeof STORAGE_KEYS !== 'undefined' ? STORAGE_KEYS.USER_PROFILE : 'yourCoachBeta_userProfile';
                        const userProfile = JSON.parse(localStorage.getItem(userProfileKey) || '{}');
                        weight = userProfile.weight || 0;
                        bodyFat = userProfile.bodyFatPercentage || 0;
                        console.log(`[履歴グラフ] ${dateStr} フォールバック体組成: weight=${weight}, bodyFat=${bodyFat}`);
                    }
                    const lbm = weight > 0 && bodyFat > 0 ? weight * (1 - bodyFat / 100) : 0;
                    console.log(`[履歴グラフ] ${dateStr} LBM計算: ${lbm.toFixed(2)}kg (weight=${weight}, bodyFat=${bodyFat}%)`);
                    allData.lbm.push(lbm);

                    allData.directive.push(record.directiveCompleted ? 1 : 0);

                    // スコアデータ（record.scoresから取得）
                    allData.nutrition_score.push(record.scores?.food || 0);
                    allData.training_score.push(record.scores?.exercise || 0);
                    allData.condition_score.push(record.scores?.condition || 0);

                    // 閃きメモを保存
                    if (record.notes && record.notes.trim()) {
                        dailyNotes[dateStr] = record.notes.trim();
                    }
                } else {
                    // データがない場合は0を追加
                    Object.keys(allData).forEach(key => {
                        if (key === 'rm') {
                            // rmは特殊処理（オブジェクト型）
                            for (const rmKey in allData.rm) {
                                allData.rm[rmKey].push(0);
                            }
                        } else if (Array.isArray(allData[key])) {
                            allData[key].push(0);
                        }
                    });
                }
            }

            // データ取得完了のログ
            console.log('[履歴データ取得] 完了 - カロリーデータ数:', allData.calories.length);
            console.log('[履歴データ取得] 最後の7日分のカロリー:', allData.calories.slice(-7));
            console.log('[履歴データ取得] 最後の7日分の運動時間:', allData.total_time.slice(-7));

            return allData;
        }

        // グローバルデータ（実データで上書きされる）
        let allData = {
            // パフォーマンス
            lbm: [],
            directive: [],
            // 食事
            nutrition_score: [],
            calories: [],
            protein: [],
            fat: [],
            carbs: [],
            sugar: [],
            fiber: [],
            solubleFiber: [],
            insolubleFiber: [],
            gi: [],
            vitamin_score: [],
            mineral_score: [],
            // 運動
            training_score: [],
            total_time: [],
            total_exercises: [],
            total_weight: [],
            rm: {}, // 回数×種目別のRM記録（動的に追加）
            // コンディション
            condition_score: [],
            sleep_duration: [],
            sleep_quality: [],
            appetite: [],
            gut_health: [],
            focus: [],
            stress: []
        };

        // 全期間の最低値・最大値を計算
        function calculateGlobalMinMax(metric) {
            const data = allData[metric];
            const info = metricInfo[metric];

            // データまたはメトリック情報がない場合はデフォルト値を返す
            if (!data || !info) {
                console.warn(`No data or metric info for: ${metric}`);
                return { min: 0, max: 10 };
            }

            // 配列チェック
            if (!Array.isArray(data)) {
                console.warn(`Data for ${metric} is not an array`);
                return { min: 0, max: 10 };
            }

            if (data.length === 0) {
                return { min: 0, max: 10 };
            }

            // 指示書（バイナリデータ）は0-1固定
            if (info.isBinary) {
                return { min: 0, max: 1 };
            }

            // 有効な数値のみをフィルタ
            const validData = data.filter(v => typeof v === 'number' && !isNaN(v) && v > 0);

            if (validData.length === 0) {
                return { min: 0, max: 10 };
            }

            const min = Math.min(...validData);
            const max = Math.max(...validData);
            const range = max - min;

            // マージンを大きめに設定（20%）して、数値が見切れないようにする
            const margin = Math.max(range * 0.2, 0.5); // 最低でも0.5のマージン

            return {
                min: Math.floor((min - margin) * 10) / 10,
                max: Math.ceil((max + margin) * 10) / 10
            };
        }

        // 指定期間のデータを取得
        function generateData(days) {
            const result = {};
            // すべての指標のデータを返す
            for (const key in allData) {
                if (key === 'rm') {
                    // rmは特殊処理（オブジェクト型）
                    result[key] = allData[key];
                } else if (Array.isArray(allData[key])) {
                    result[key] = allData[key].slice(-days);
                }
            }
            return result;
        }

        // 指定期間のデータを取得
        function getDataForPeriod(category, period) {
            if (!allData[category]) {
                return null;
            }
            return allData[category].slice(-period);
        }

        // ラベル生成
        function generateLabels(days) {
            if (days <= 7) {
                // 7日以内: 数字のみ（単位は表示時に追加）0=今日
                const labels = Array.from({ length: days }, (_, i) => `${days - 1 - i}`);
                return labels;
            } else if (days <= 30) {
                // 30日以内: 数字のみ（単位は表示時に追加）0=今日
                const labels = Array.from({ length: days }, (_, i) => `${days - 1 - i}`);
                return labels;
            } else {
                // 30日以上: 数字のみ（単位は表示時に追加）0=今日
                const labels = Array.from({ length: days }, (_, i) => `${days - 1 - i}`);
                return labels;
            }
        }

        // 移動平均を計算
        function calculateMovingAverage(data, period) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    result.push(null); // 最初の数日は計算できない
                } else {
                    const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                    result.push(sum / period);
                }
            }
            return result;
        }

        // 線形回帰で予測線を計算
        function calculatePrediction(data, futureDays = 7) {
            const validData = data.filter(v => v > 0);
            if (validData.length < 3) return [];

            // 線形回帰の計算
            const n = validData.length;
            const indices = Array.from({ length: n }, (_, i) => i);
            const sumX = indices.reduce((a, b) => a + b, 0);
            const sumY = validData.reduce((a, b) => a + b, 0);
            const sumXY = indices.reduce((sum, x, i) => sum + x * validData[i], 0);
            const sumX2 = indices.reduce((sum, x) => sum + x * x, 0);

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            // 予測値を計算
            const predictions = [];
            for (let i = 0; i < data.length + futureDays; i++) {
                predictions.push(slope * i + intercept);
            }

            return predictions;
        }

        // 移動平均線の表示切替
        function toggleMovingAverage(chartNum) {
            showMovingAverage[chartNum] = !showMovingAverage[chartNum];
            updateChart(chartNum);
        }

        // 移動平均の期間を変更
        function changeMovingAveragePeriod(chartNum, period) {
            movingAveragePeriod[chartNum] = parseInt(period);
            if (showMovingAverage[chartNum]) {
                updateChart(chartNum);
            }
        }

        // 予測線の表示切替
        function togglePrediction(chartNum) {
            showPrediction[chartNum] = !showPrediction[chartNum];
            updateChart(chartNum);
        }

        // Chart2のカテゴリを変更
        function changeChart2Category(category) {
            chart2Category = category;
            currentSubCategory = category;
            updateChart(2);
        }

        // Y軸連動のON/OFF切替
        function toggleAxisSync() {
            // パネルまたはメイン画面のチェックボックスから状態を取得
            const syncAxisPanelElement = document.getElementById('sync-axis-panel');
            const syncAxisElement = document.getElementById('sync-axis');

            // パネルの要素があればそちらを使用、なければメインの要素を使用
            const checkboxElement = syncAxisPanelElement || syncAxisElement;
            if (!checkboxElement) {
                console.warn('Y軸連動要素が見つかりません');
                return;
            }

            axisSync = checkboxElement.checked;

            // 両方のチェックボックスを同期
            if (syncAxisPanelElement) syncAxisPanelElement.checked = axisSync;
            if (syncAxisElement) syncAxisElement.checked = axisSync;

            const icon = document.querySelector('.sync-icon');

            if (axisSync) {
                // ONになったら、グラフ1の値をグラフ2に反映
                if (icon) {
                    icon.classList.add('syncing');
                    setTimeout(() => icon.classList.remove('syncing'), 1000);
                }

                if (comparisonMode && currentAxisRanges[1].min !== null) {
                    const axisMin2Element = document.getElementById('axis-min-2');
                    const axisMax2Element = document.getElementById('axis-max-2');

                    currentAxisRanges[2] = { ...currentAxisRanges[1] };
                    if (axisMin2Element) axisMin2Element.value = currentAxisRanges[1].min;
                    if (axisMax2Element) axisMax2Element.value = currentAxisRanges[1].max;
                    updateChart(2);
                }
            }

            lucide.createIcons();
        }

        // Gemini分析（親ウィンドウへメッセージ送信）
        // ローカル傾向調査（現在表示中の期間を使用）
        function showLocalTrendAnalysis() {
            const metric = metricInfo[currentSubCategory];
            const period = currentPeriods[1]; // 現在表示中の期間
            const data = currentData[1]; // 現在表示中のデータ

            if (!data || data.length === 0) {
                alert(`データがありません`);
                return;
            }

            // データの統計情報を計算
            const avg = (data.reduce((a, b) => a + b, 0) / data.length).toFixed(1);
            const max = Math.max(...data).toFixed(1);
            const min = Math.min(...data).toFixed(1);
            const trend = (data[data.length - 1] - data[0]).toFixed(1);
            const trendPercent = ((trend / data[0]) * 100).toFixed(1);
            const stdDev = calculateStdDev(data).toFixed(1);

            // トレンド判定
            let trendLabel = '横ばい';
            let trendIcon = '→';
            let trendColor = 'text-gray-600';
            if (Math.abs(parseFloat(trendPercent)) < 5) {
                trendLabel = '横ばい';
                trendIcon = '→';
                trendColor = 'text-gray-600';
            } else if (parseFloat(trend) > 0) {
                trendLabel = '増加傾向';
                trendIcon = '↑';
                trendColor = 'text-green-600';
            } else {
                trendLabel = '減少傾向';
                trendIcon = '↓';
                trendColor = 'text-red-600';
            }

            // モーダル表示
            const periodLabel = period === 365 ? '1年間' : `${period}日間`;
            const modalHTML = `
                <div class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4" onclick="this.remove()">
                    <div class="bg-white rounded-2xl w-full max-w-md p-6" onclick="event.stopPropagation()">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-bold flex items-center gap-2">
                                <i data-lucide="bar-chart-2" class="w-5 h-5 text-blue-600"></i>
                                傾向調査：${metric.name}
                            </h3>
                            <button onclick="this.closest('.fixed').remove()" class="p-2 hover:bg-gray-100 rounded-full">
                                <i data-lucide="x" class="w-5 h-5"></i>
                            </button>
                        </div>
                        <div class="space-y-4">
                            <div class="p-3 bg-blue-50 rounded-lg border border-blue-200">
                                <div class="text-sm font-semibold text-blue-900 mb-1">期間</div>
                                <div class="text-lg font-bold text-blue-700">過去${periodLabel}</div>
                            </div>
                            <div class="grid grid-cols-2 gap-3">
                                <div class="p-3 bg-gray-50 rounded-lg">
                                    <div class="text-xs text-gray-600 mb-1">平均値</div>
                                    <div class="text-lg font-bold">${avg}${metric.unit}</div>
                                </div>
                                <div class="p-3 bg-gray-50 rounded-lg">
                                    <div class="text-xs text-gray-600 mb-1">標準偏差</div>
                                    <div class="text-lg font-bold">${stdDev}${metric.unit}</div>
                                </div>
                                <div class="p-3 bg-green-50 rounded-lg border border-green-200">
                                    <div class="text-xs text-green-700 mb-1">最高値</div>
                                    <div class="text-lg font-bold text-green-800">${max}${metric.unit}</div>
                                </div>
                                <div class="p-3 bg-red-50 rounded-lg border border-red-200">
                                    <div class="text-xs text-red-700 mb-1">最低値</div>
                                    <div class="text-lg font-bold text-red-800">${min}${metric.unit}</div>
                                </div>
                            </div>
                            <div class="p-4 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200">
                                <div class="text-sm font-semibold text-purple-900 mb-2">トレンド</div>
                                <div class="flex items-center gap-3">
                                    <span class="text-3xl ${trendColor}">${trendIcon}</span>
                                    <div>
                                        <div class="text-lg font-bold ${trendColor}">${trendLabel}</div>
                                        <div class="text-sm text-gray-600">
                                            ${trend > 0 ? '+' : ''}${trend}${metric.unit} (${trendPercent}%)
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            lucide.createIcons();
        }

        // 標準偏差計算
        function calculateStdDev(values) {
            const avg = values.reduce((a, b) => a + b, 0) / values.length;
            const squareDiffs = values.map(value => Math.pow(value - avg, 2));
            const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
            return Math.sqrt(avgSquareDiff);
        }

        async function analyzeWithGemini() {
            console.log('[AI分析] ボタンクリック');
            console.log('currentSubCategory:', currentSubCategory);
            console.log('currentMainCategory:', currentMainCategory);

            // 現在のカテゴリとデータを取得
            const metric = metricInfo[currentSubCategory];
            const data1 = currentData[1];
            const period1 = currentPeriods[1];

            console.log('data1:', data1);
            console.log('data1 length:', data1 ? data1.length : 'undefined');

            // データの存在確認
            if (!data1 || data1.length === 0) {
                console.error('[AI分析] データが空です');
                alert('分析するデータがありません。記録を追加してから再度お試しください。');
                return;
            }

            // データの統計情報を計算
            const avg = (data1.reduce((a, b) => a + b, 0) / data1.length).toFixed(1);
            const max = Math.max(...data1).toFixed(1);
            const min = Math.min(...data1).toFixed(1);
            const trend = (data1[data1.length - 1] - data1[0]).toFixed(1);
            const trendPercent = data1[0] !== 0 ? ((trend / data1[0]) * 100).toFixed(1) : '0.0';

            console.log('[AI分析] 統計情報:', { avg, max, min, trend, trendPercent });

            // 親ウィンドウ（React）にメッセージを送信
            console.log('[AI分析] postMessage送信');
            window.parent.postMessage({
                type: 'REQUEST_AI_ANALYSIS',
                category: currentMainCategory,
                subCategory: currentSubCategory,
                metricInfo: metric,
                data: data1,
                period: period1,
                stats: {
                    avg: avg,
                    max: max,
                    min: min,
                    trend: trend,
                    trendPercent: trendPercent
                }
            }, '*');
        }

        // ヘルプモーダル
        function openHelpModal() {
            document.getElementById('help-modal').classList.add('show');
            lucide.createIcons();
        }

        function closeHelpModal() {
            document.getElementById('help-modal').classList.remove('show');
        }

        // ツールチップ
        const tooltipContent = {
            comparison: `
                <div class="text-sm">
                    <div class="font-bold text-blue-600 mb-2">比較モードとは？</div>
                    <p class="mb-2">2つのグラフを同時に表示し、異なる期間のデータを比較できます。</p>
                    <div class="font-semibold mb-1">使い方:</div>
                    <ul class="text-xs space-y-1 pl-4">
                        <li>• チェックをONにすると下にグラフが追加表示</li>
                        <li>• 上下で異なる期間を選択可能（例: 7日 vs 30日）</li>
                        <li>• 短期と長期のトレンド比較に最適</li>
                    </ul>
                </div>
            `,
            sync: `
                <div class="text-sm">
                    <div class="font-bold text-purple-600 mb-2">Y軸連動とは？</div>
                    <p class="mb-2">上のグラフのY軸範囲を変更すると、下のグラフも自動で同じ範囲に調整される機能です。</p>
                    <div class="font-semibold mb-1">メリット:</div>
                    <ul class="text-xs space-y-1 pl-4">
                        <li>• 同じスケールで比較できる</li>
                        <li>• 数値の大小を直感的に比較</li>
                        <li>• ワンクリックでON/OFF切替可能</li>
                    </ul>
                </div>
            `
        };

        let tooltipTimeout;
        function showTooltip(event, type) {
            clearTimeout(tooltipTimeout);
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = tooltipContent[type];
            tooltip.classList.add('show');

            // 位置調整
            const rect = event.target.getBoundingClientRect();
            tooltip.style.position = 'fixed';
            tooltip.style.left = rect.left + 'px';
            tooltip.style.top = (rect.bottom + 10) + 'px';
        }

        function hideTooltip() {
            tooltipTimeout = setTimeout(() => {
                document.getElementById('tooltip').classList.remove('show');
            }, 200);
        }

        // 比較モード切り替え
        function toggleComparisonMode() {
            // パネルまたはメイン画面のチェックボックスから状態を取得
            const comparisonModePanelElement = document.getElementById('comparison-mode-panel');
            const comparisonModeElement = document.getElementById('comparison-mode');
            const chart2Element = document.getElementById('chart-2');

            if (!chart2Element) {
                console.warn('Chart 2要素が見つかりません');
                return;
            }

            // パネルの要素があればそちらを使用、なければメインの要素を使用
            const checkboxElement = comparisonModePanelElement || comparisonModeElement;
            if (!checkboxElement) {
                console.warn('比較モード要素が見つかりません');
                return;
            }

            comparisonMode = checkboxElement.checked;

            // 両方のチェックボックスを同期
            if (comparisonModePanelElement) comparisonModePanelElement.checked = comparisonMode;
            if (comparisonModeElement) comparisonModeElement.checked = comparisonMode;

            chart2Element.classList.toggle('hidden', !comparisonMode);

            if (comparisonMode) {
                // 比較モードON時、Y軸連動がONなら同じ範囲を適用
                if (axisSync && currentAxisRanges[1].min !== null) {
                    const axisMin2Element = document.getElementById('axis-min-2');
                    const axisMax2Element = document.getElementById('axis-max-2');

                    currentAxisRanges[2] = { ...currentAxisRanges[1] };
                    if (axisMin2Element) axisMin2Element.value = currentAxisRanges[1].min;
                    if (axisMax2Element) axisMax2Element.value = currentAxisRanges[1].max;
                }
                updateChart(2);
                updateChart2PeriodButtons();
            }
        }

        // 大カテゴリ選択（デモ用 - 実際には各カテゴリのコンテンツを表示）
        function selectMainCategory(category, event) {
            currentMainCategory = category;

            // カテゴリごとの色設定（アプリと完全一致）
            const categoryColors = {
                nutrition: 'text-green-600',      // 食事: 緑
                training: 'text-orange-600',      // 運動: オレンジ
                condition: 'text-red-600',        // コンディション: 赤
                performance: 'text-purple-600',   // パフォーマンス: 紫
                insights: 'text-yellow-600'       // 閃き: 黄色
            };

            // タブのアクティブ状態を更新（色は維持）
            document.querySelectorAll('.tab-button').forEach(btn => {
                // 背景とボーダーのみを削除、色は維持
                btn.classList.remove('active', 'bg-white', 'border-b-0');
                // 各ボタンのカテゴリに応じた色を再設定
                const btnCategory = btn.getAttribute('data-category');
                if (btnCategory && categoryColors[btnCategory]) {
                    btn.classList.remove('text-green-600', 'text-orange-600', 'text-red-600', 'text-purple-600', 'text-yellow-600');
                    btn.classList.add(categoryColors[btnCategory]);
                }
            });

            const colorClass = categoryColors[category] || 'text-purple-600';
            // イベントが渡されている場合はevent.currentTargetを使用、それ以外は該当するボタンを検索
            const targetButton = event ? event.currentTarget : document.querySelector(`.tab-button[data-category="${category}"]`);
            if (targetButton) {
                targetButton.classList.add('active', colorClass, 'bg-white', 'border-b-0');
            }

            // すべてのサブタブを非表示
            document.querySelectorAll('.sub-tabs').forEach(tab => {
                tab.classList.add('hidden');
            });

            // 閃きカテゴリの場合は特別処理
            if (category === 'insights') {
                // グラフエリアを非表示
                document.getElementById('graph-area').classList.add('hidden');
                // 閃きコンテンツを表示
                document.getElementById('insights-content').classList.remove('hidden');
                // 閃きメモリストを生成
                renderInsightsList();
            } else {
                // グラフエリアを表示
                document.getElementById('graph-area').classList.remove('hidden');
                // 閃きコンテンツを非表示
                document.getElementById('insights-content').classList.add('hidden');

                // 選択されたカテゴリのサブタブを表示
                const subtabs = document.getElementById(`${category}-subtabs`);
                if (subtabs) {
                    subtabs.classList.remove('hidden');
                }

                // 各カテゴリの最初の指標を選択
                const firstMetrics = {
                    nutrition: 'nutrition_score',
                    training: 'training_score',
                    condition: 'condition_score',
                    performance: 'lbm'
                };

                // 最初のサブカテゴリを選択
                if (firstMetrics[category]) {
                    selectSubCategory(category, firstMetrics[category]);
                }
            }

            // 個別分析ボタンを更新
            updateTabSpecificAnalysisButton(category);

            // アイコンを再描画
            lucide.createIcons();
        }

        // 閃きメモリストを描画する関数
        function renderInsightsList() {
            const listContainer = document.getElementById('insights-list');
            listContainer.innerHTML = '';

            // dailyNotesを日付順にソート（新しい順）
            const sortedNotes = Object.entries(dailyNotes).sort((a, b) => {
                return new Date(b[0]) - new Date(a[0]);
            });

            if (sortedNotes.length === 0) {
                listContainer.innerHTML = `
                    <div class="text-center py-12">
                        <i data-lucide="lightbulb-off" class="w-16 h-16 text-gray-300 mx-auto mb-4"></i>
                        <p class="text-gray-500">閃きメモはまだありません</p>
                    </div>
                `;
                lucide.createIcons();
                return;
            }

            sortedNotes.forEach(([dateStr, note]) => {
                const date = new Date(dateStr);
                const dateDisplay = `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`;
                const dayOfWeek = ['日', '月', '火', '水', '木', '金', '土'][date.getDay()];

                const noteCard = document.createElement('div');
                noteCard.className = 'bg-yellow-50 border-l-4 border-yellow-500 rounded-lg p-4 hover:shadow-md transition';
                noteCard.innerHTML = `
                    <div class="flex items-start gap-3">
                        <i data-lucide="lightbulb" class="w-5 h-5 text-yellow-600 flex-shrink-0 mt-1"></i>
                        <div class="flex-1">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-sm font-bold text-gray-800">${dateDisplay} (${dayOfWeek})</span>
                            </div>
                            <p class="text-sm text-gray-700 whitespace-pre-wrap">${note}</p>
                        </div>
                    </div>
                `;
                listContainer.appendChild(noteCard);
            });

            lucide.createIcons();
        }

        // データを再読み込みする汎用関数
        async function refreshData(buttonId, callback) {
            const refreshButton = document.getElementById(buttonId);
            if (!refreshButton) {
                console.error(`[データ更新] ボタン ${buttonId} が見つかりません`);
                return;
            }

            // ボタンを無効化
            refreshButton.disabled = true;
            refreshButton.style.opacity = '0.5';

            try {
                console.log('[データ更新] データを再読み込み中...');

                // データを再読み込み
                if (typeof loadRealData === 'function') {
                    const data = await loadRealData();
                    allData = data;
                    console.log('[データ更新] データ再読み込み完了');

                    // コールバック実行
                    if (callback) {
                        callback();
                    }
                } else {
                    console.error('[データ更新] loadRealData関数が見つかりません');
                }
            } catch (error) {
                console.error('[データ更新] データ再読み込みエラー:', error);
            } finally {
                // ボタンを再度有効化
                setTimeout(() => {
                    if (refreshButton) {
                        refreshButton.disabled = false;
                        refreshButton.style.opacity = '1';
                    }
                    lucide.createIcons(); // アイコンを再描画
                }, 300);
            }
        }

        // 閃きメモリストを再読み込みする関数
        async function refreshInsightsList() {
            await refreshData('insights-refresh-button', () => {
                renderInsightsList();
            });
        }

        // グラフを再読み込みする関数
        async function refreshChart(chartNum) {
            await refreshData(`chart-refresh-button-${chartNum}`, () => {
                if (currentSubCategory) {
                    globalMinMax = calculateGlobalMinMax(currentSubCategory);
                } else {
                    globalMinMax = calculateGlobalMinMax('lbm');
                }
                updateChart(chartNum);
                if (chartNum === 1 && comparisonMode) {
                    updateChart(2);
                }
            });
        }

        // 期間選択
        function selectPeriod(chartNum, days) {
            currentPeriods[chartNum] = days;

            const container = chartNum === 1 ? document.getElementById('chart-1') : document.getElementById('chart-2');

            if (chartNum === 1) {
                // グラフ1: タブ式スタイル（透明背景＋アンダーライン）
                container.querySelectorAll('.period-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                if (event && event.currentTarget) {
                    event.currentTarget.classList.add('active');
                }
            } else {
                // グラフ2: ボタン式スタイル（背景色付き）
                container.querySelectorAll('.period-button').forEach(btn => {
                    btn.classList.remove('active', 'bg-purple-600', 'bg-blue-600', 'text-white', 'shadow-sm');
                    btn.classList.add('bg-white', 'text-gray-700', 'border', 'border-gray-300');
                });
                if (event && event.currentTarget) {
                    event.currentTarget.classList.add('active', 'bg-blue-600', 'text-white', 'shadow-sm');
                    event.currentTarget.classList.remove('bg-white', 'text-gray-700', 'border', 'border-gray-300');
                }
            }

            updateChart(chartNum);

            // グラフ1の期間が変更された場合、グラフ2の期間ボタンを更新
            if (chartNum === 1 && comparisonMode) {
                updateChart2PeriodButtons();
            }
        }

        // 期間範囲選択（今週、先週、今月、先月）
        function selectPeriodRange(chartNum, rangeType) {
            const today = new Date();
            let startDate, endDate, days;

            switch(rangeType) {
                case 'thisWeek':
                    // 今週（月曜日～日曜日）
                    const dayOfWeek = today.getDay();
                    const diffToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // 月曜を週の開始とする
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - diffToMonday);
                    endDate = today;
                    days = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
                    break;

                case 'lastWeek':
                    // 先週（先週の月曜日～日曜日）
                    const lastWeekEnd = new Date(today);
                    const daysToLastSunday = today.getDay() === 0 ? 0 : today.getDay();
                    lastWeekEnd.setDate(today.getDate() - daysToLastSunday);
                    startDate = new Date(lastWeekEnd);
                    startDate.setDate(lastWeekEnd.getDate() - 6);
                    days = 7;
                    break;

                case 'thisMonth':
                    // 今月（1日～今日）
                    startDate = new Date(today.getFullYear(), today.getMonth(), 1);
                    endDate = today;
                    days = today.getDate();
                    break;

                case 'lastMonth':
                    // 先月（先月の1日～末日）
                    const lastMonthDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    const lastMonthEnd = new Date(today.getFullYear(), today.getMonth(), 0);
                    days = lastMonthEnd.getDate();
                    break;
            }

            currentPeriods[chartNum] = days;

            // タブのアクティブ状態を更新（モバイル対応スタイル）
            const container = chartNum === 1 ? document.getElementById('chart-1') : document.getElementById('chart-2');
            const bgColor = chartNum === 1 ? 'bg-purple-600' : 'bg-blue-600';

            container.querySelectorAll('.period-button').forEach(btn => {
                btn.classList.remove('active', 'bg-purple-600', 'bg-blue-600', 'text-white', 'shadow-sm');
                btn.classList.add('bg-white', 'text-gray-700', 'border', 'border-gray-300');
            });
            if (event && event.currentTarget) {
                event.currentTarget.classList.add('active', bgColor, 'text-white', 'shadow-sm');
                event.currentTarget.classList.remove('bg-white', 'text-gray-700', 'border', 'border-gray-300');
            }

            updateChart(chartNum);

            // グラフ1の期間が変更された場合、グラフ2の期間ボタンを更新
            if (chartNum === 1 && comparisonMode) {
                updateChart2PeriodButtons();
            }
        }

        // グラフ2の期間ボタンを更新（グラフ1と同じ期間を無効化）
        function updateChart2PeriodButtons() {
            const chart2Container = document.getElementById('chart-2');
            const buttons = chart2Container.querySelectorAll('.period-button');

            buttons.forEach(btn => {
                const btnText = btn.textContent;
                const days = parseInt(btnText);

                if (days === currentPeriods[1]) {
                    btn.disabled = true;
                    btn.classList.add('opacity-50', 'cursor-not-allowed');
                    btn.onclick = null;
                } else {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50', 'cursor-not-allowed');
                    // onclick を復元
                    const dayValue = btnText === '7日間' ? 7 : btnText === '14日間' ? 14 : btnText === '30日間' ? 30 : 90;
                    btn.onclick = () => selectPeriod(2, dayValue);
                }
            });
        }

        // Y軸レンジをリセット
        function resetAxisRange(chartNum) {
            const axisMinElement = document.getElementById(`axis-min-${chartNum}`);
            const axisMaxElement = document.getElementById(`axis-max-${chartNum}`);

            if (axisMinElement && axisMaxElement) {
                axisMinElement.value = globalMinMax.min;
                axisMaxElement.value = globalMinMax.max;
                updateAxisRange(chartNum);
            }
        }

        // Y軸レンジを更新
        function updateAxisRange(chartNum) {
            const axisMinElement = document.getElementById(`axis-min-${chartNum}`);
            const axisMaxElement = document.getElementById(`axis-max-${chartNum}`);

            if (!axisMinElement || !axisMaxElement) {
                console.warn(`Y軸レンジ要素が見つかりません: chart ${chartNum}`);
                return;
            }

            const min = parseFloat(axisMinElement.value);
            const max = parseFloat(axisMaxElement.value);

            if (!isNaN(min) && !isNaN(max) && min < max) {
                currentAxisRanges[chartNum] = { min, max };

                // グラフを更新
                if (charts[chartNum]) {
                    charts[chartNum].options.scales.y.min = min;
                    charts[chartNum].options.scales.y.max = max;
                    charts[chartNum].update();
                }

                // Y軸連動がONで、グラフ1の変更なら、グラフ2も同期
                if (axisSync && chartNum === 1 && comparisonMode) {
                    const axisMin2Element = document.getElementById('axis-min-2');
                    const axisMax2Element = document.getElementById('axis-max-2');

                    currentAxisRanges[2] = { min, max };
                    if (axisMin2Element) axisMin2Element.value = min;
                    if (axisMax2Element) axisMax2Element.value = max;

                    if (charts[2]) {
                        charts[2].options.scales.y.min = min;
                        charts[2].options.scales.y.max = max;
                        charts[2].update();
                    }

                    // 同期アニメーション
                    const icon = document.querySelector('.sync-icon');
                    if (icon) {
                        icon.classList.add('syncing');
                        setTimeout(() => icon.classList.remove('syncing'), 1000);
                    }
                    lucide.createIcons();
                }
            }
        }

        // グラフ更新
        function updateChart(chartNum) {
            const days = currentPeriods[chartNum];

            // Chart2で比較モードの場合は、chart2Categoryを使用
            const categoryToUse = (chartNum === 2 && comparisonMode) ? chart2Category : currentSubCategory;

            const data = generateData(days)[categoryToUse];
            const labels = generateLabels(days);
            const metric = metricInfo[categoryToUse];

            // メトリック情報がない場合は処理を中断
            if (!metric) {
                console.error(`Metric info not found for: ${categoryToUse}`);
                return;
            }

            // データを保存
            currentData[chartNum] = data;

            // タイトル更新
            document.getElementById(`chart-title-${chartNum}`).textContent = `${metric.name}${chartNum === 2 ? ' - 比較' : ''}`;
            document.getElementById(`chart-period-${chartNum}`).textContent = `過去${days}日間の推移`;

            // カテゴリ別の最低値・最高値を計算して表示（全期間90日）
            const categoryMinElement = document.getElementById(`category-min-${chartNum}`);
            const categoryMaxElement = document.getElementById(`category-max-${chartNum}`);
            const categoryUnitElement = document.getElementById(`category-unit-${chartNum}`);

            if (categoryMinElement && categoryMaxElement && categoryUnitElement) {
                const fullData = generateData(90)[categoryToUse];
                const validFullData = fullData.filter(v => typeof v === 'number' && !isNaN(v) && v > 0);

                if (validFullData.length > 0) {
                    const categoryMin = Math.min(...validFullData);
                    const categoryMax = Math.max(...validFullData);

                    // Format numbers with comma separators (e.g., "2,264.10")
                    const formatNumber = (num) => {
                        return num.toFixed(1).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    };

                    categoryMinElement.textContent = formatNumber(categoryMin);
                    categoryMaxElement.textContent = formatNumber(categoryMax) + metric.unit;
                    categoryUnitElement.textContent = ''; // Hide separate unit, it's now in max value
                } else {
                    categoryMinElement.textContent = '-';
                    categoryMaxElement.textContent = '-';
                    categoryUnitElement.textContent = '';
                }
            }

            // 値の表示（バイナリの場合は完了/未完了）
            const currentValue = data[data.length - 1];
            if (metric.isBinary) {
                const valueText = (typeof currentValue === 'number' && currentValue === 1) ? '✓ 完了' : '✗ 未完了';
                document.getElementById(`chart-value-${chartNum}`).textContent = valueText;
                document.getElementById(`chart-unit-${chartNum}`).textContent = '';
            } else if (metric.getLabel && typeof currentValue === 'number') {
                // 段階説明がある場合
                const valueText = metric.getLabel(currentValue);
                document.getElementById(`chart-value-${chartNum}`).textContent = valueText;
                document.getElementById(`chart-unit-${chartNum}`).textContent = '';
            } else {
                const valueText = (typeof currentValue === 'number' && !isNaN(currentValue))
                    ? `${currentValue.toFixed(1)}${metric.unit}`
                    : '-';
                document.getElementById(`chart-value-${chartNum}`).textContent = valueText;
                document.getElementById(`chart-unit-${chartNum}`).textContent = '';
            }

            // 統計計算
            if (metric.isBinary) {
                // バイナリデータ（指示書）の場合は完了率を表示
                const completionRate = ((data.reduce((a, b) => a + b, 0) / data.length) * 100).toFixed(0);
                document.getElementById(`stat-avg-${chartNum}`).textContent = `${completionRate}%`;
                document.getElementById(`stat-avg-unit-${chartNum}`).textContent = '';
                document.getElementById(`stat-max-${chartNum}`).textContent = `${data.filter(v => v === 1).length}日`;
                document.getElementById(`stat-max-unit-${chartNum}`).textContent = '';
                document.getElementById(`stat-min-${chartNum}`).textContent = `${data.filter(v => v === 0).length}日`;
                document.getElementById(`stat-min-unit-${chartNum}`).textContent = '';
            } else {
                const avg = (data.reduce((a, b) => a + b, 0) / data.length).toFixed(1);
                const max = Math.max(...data).toFixed(1);
                const min = Math.min(...data).toFixed(1);

                const avgText = `${avg}${metric.unit}`;
                const maxText = `${max}${metric.unit}`;
                const minText = `${min}${metric.unit}`;

                console.log(`Chart ${chartNum} stats:`, { avgText, maxText, minText, metric: metric.name });

                document.getElementById(`stat-avg-${chartNum}`).textContent = avgText;
                document.getElementById(`stat-max-${chartNum}`).textContent = maxText;
                document.getElementById(`stat-min-${chartNum}`).textContent = minText;
                document.getElementById(`stat-avg-unit-${chartNum}`).textContent = '';
                document.getElementById(`stat-max-unit-${chartNum}`).textContent = '';
                document.getElementById(`stat-min-unit-${chartNum}`).textContent = '';

                // 標準偏差を計算
                const stdDev = calculateStdDev(data).toFixed(1);
                const stddevElement = document.getElementById(`stat-stddev-${chartNum}`);
                if (stddevElement) {
                    stddevElement.textContent = `${stdDev}${metric.unit}`;
                }

                // トレンドを計算
                const trend = (data[data.length - 1] - data[0]).toFixed(1);
                const trendPercent = ((trend / data[0]) * 100).toFixed(1);

                let trendLabel = '横ばい';
                let trendIcon = '→';
                let trendColor = 'text-gray-600';
                if (Math.abs(parseFloat(trendPercent)) < 5) {
                    trendLabel = '横ばい';
                    trendIcon = '→';
                    trendColor = 'text-gray-600';
                } else if (parseFloat(trend) > 0) {
                    trendLabel = '増加傾向';
                    trendIcon = '↑';
                    trendColor = 'text-green-600';
                } else {
                    trendLabel = '減少傾向';
                    trendIcon = '↓';
                    trendColor = 'text-red-600';
                }

                const trendIconElement = document.getElementById(`stat-trend-icon-${chartNum}`);
                const trendLabelElement = document.getElementById(`stat-trend-label-${chartNum}`);
                const trendValueElement = document.getElementById(`stat-trend-value-${chartNum}`);

                if (trendIconElement) {
                    trendIconElement.textContent = trendIcon;
                    trendIconElement.className = `text-2xl ${trendColor}`;
                }
                if (trendLabelElement) {
                    trendLabelElement.textContent = trendLabel;
                    trendLabelElement.className = `text-sm font-bold ${trendColor}`;
                }
                if (trendValueElement) {
                    trendValueElement.textContent = `${trend > 0 ? '+' : ''}${trend}${metric.unit} (${trendPercent}%)`;
                }
            }

            // Y軸レンジ設定（データに基づいて自動調整）
            // Chart2で異なるカテゴリを使用する場合は、そのカテゴリのglobalMinMaxを計算
            const currentGlobalMinMax = (chartNum === 2 && comparisonMode && categoryToUse !== currentSubCategory)
                ? calculateGlobalMinMax(categoryToUse)
                : globalMinMax;

            // Y軸を選択期間のデータに基づいて自動調整
            // 現在表示しているデータの範囲を取得
            const validData = data.filter(v => v !== null && v !== undefined && !isNaN(v));
            if (validData.length > 0 && !metric.isBinary) {
                const dataMin = Math.min(...validData);
                const dataMax = Math.max(...validData);
                const dataRange = dataMax - dataMin;

                // 適切なマージンを設定（データ範囲の15%、最低0.5）
                const margin = Math.max(dataRange * 0.15, 0.5);

                currentAxisRanges[chartNum] = {
                    min: Math.floor((dataMin - margin) * 10) / 10,
                    max: Math.ceil((dataMax + margin) * 10) / 10
                };
            } else if (metric.isBinary) {
                // バイナリデータの場合は固定範囲
                currentAxisRanges[chartNum] = { min: -0.2, max: 1.2 };
            } else {
                // データがない場合は全期間の範囲を使用
                currentAxisRanges[chartNum] = { ...currentGlobalMinMax };
            }

            // 軸入力フィールドが存在する場合のみ値を設定
            const axisMinElement = document.getElementById(`axis-min-${chartNum}`);
            const axisMaxElement = document.getElementById(`axis-max-${chartNum}`);
            if (axisMinElement) axisMinElement.value = currentAxisRanges[chartNum].min;
            if (axisMaxElement) axisMaxElement.value = currentAxisRanges[chartNum].max;

            // グラフ描画
            if (charts[chartNum]) charts[chartNum].destroy();

            const chartType = metric.isBinary ? 'bar' : 'line';

            // 目標ラインとメモマーカーのアノテーション設定
            const chartAnnotations = {};

            // 目標ライン
            const goal = goals[categoryToUse];
            if (goal && goal.showLine && !metric.isBinary) {
                chartAnnotations.goalLine = {
                    type: 'line',
                    yMin: goal.value,
                    yMax: goal.value,
                    borderColor: 'rgb(34, 197, 94)', // green-500
                    borderWidth: 2,
                    borderDash: [6, 6],
                    label: {
                        display: true,
                        content: `目標: ${goal.value}${metric.unit}`,
                        position: 'end',
                        backgroundColor: 'rgba(34, 197, 94, 0.8)',
                        color: 'white',
                        font: {
                            size: 11,
                            weight: 'bold'
                        },
                        padding: 4
                    }
                };
            }

            // メモマーカー
            const markers = getAnnotationMarkers(chartNum, categoryToUse);
            Object.assign(chartAnnotations, markers);

            // データセットの配列を構築
            const datasets = [{
                label: metric.name,
                data: data,
                borderColor: chartNum === 1 ? 'rgb(168, 85, 247)' : 'rgb(59, 130, 246)',
                backgroundColor: chartNum === 1 ? 'rgba(168, 85, 247, 0.6)' : 'rgba(59, 130, 246, 0.6)',
                fill: !metric.isBinary,
                tension: 0.4,
                yAxisID: 'y'
            }];

            // 移動平均線を追加
            if (showMovingAverage[chartNum] && !metric.isBinary) {
                const maData = calculateMovingAverage(data, movingAveragePeriod[chartNum]);
                datasets.push({
                    label: `${metric.name}（${movingAveragePeriod[chartNum]}日移動平均）`,
                    data: maData,
                    borderColor: chartNum === 1 ? 'rgb(251, 146, 60)' : 'rgb(14, 165, 233)',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    tension: 0.4,
                    pointRadius: 0,
                    yAxisID: 'y'
                });
            }

            // 予測線を追加
            if (showPrediction[chartNum] && !metric.isBinary && data.length >= 3) {
                const predictionData = calculatePrediction(data, 7);
                const predictionLabels = [...labels];
                for (let i = 1; i <= 7; i++) {
                    predictionLabels.push(`+${i}日`);
                }

                datasets.push({
                    label: `${metric.name}（予測）`,
                    data: predictionData,
                    borderColor: 'rgb(34, 197, 94)',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    borderDash: [10, 5],
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'y'
                });

                // ラベルを更新
                labels = predictionLabels;
            }

            // クロスヘアプラグイン
            const crosshairPlugin = {
                id: 'crosshair',
                afterDatasetsDraw: (chart) => {
                    if (chart.crosshair && chart.crosshair.draw) {
                        const ctx = chart.ctx;
                        const x = chart.crosshair.x;
                        const y = chart.crosshair.y;
                        const chartArea = chart.chartArea;

                        ctx.save();
                        ctx.strokeStyle = 'rgba(147, 51, 234, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]);

                        // 縦線
                        ctx.beginPath();
                        ctx.moveTo(x, chartArea.top);
                        ctx.lineTo(x, chartArea.bottom);
                        ctx.stroke();

                        // 横線
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, y);
                        ctx.lineTo(chartArea.right, y);
                        ctx.stroke();

                        ctx.restore();
                    }
                }
            };

            // 固定ツールチッププラグイン（カスタムツールチップとリード線を描画）
            const fixedTooltipPlugin = {
                id: 'fixedTooltip',
                afterDraw: (chart) => {
                    // ツールチップが有効で、選択されたポイントがある場合
                    if (tooltipEnabled[chartNum] && lastClickedIndex[chartNum] !== null) {
                        const ctx = chart.ctx;
                        const meta = chart.getDatasetMeta(0);
                        const dataPoint = meta.data[lastClickedIndex[chartNum]];

                        if (!dataPoint) return;

                        // データポイントの座標
                        const pointX = dataPoint.x;
                        const pointY = dataPoint.y;
                        const chartArea = chart.chartArea;

                        // カスタムツールチップの位置（全期間セクションとグラフの間の拡張スペース）
                        const tooltipWidth = 200;
                        const tooltipHeight = 55;
                        const tooltipX = (chartArea.left + chartArea.right) / 2;
                        const tooltipY = chartArea.top - 65; // グラフにかぶらないように更に上に配置

                        // データポイントに強調円を描画
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(pointX, pointY, 6, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(147, 51, 234, 0.3)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(147, 51, 234, 1)';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // リード線を描画
                        ctx.beginPath();
                        ctx.moveTo(pointX, pointY);
                        ctx.lineTo(tooltipX, tooltipY + tooltipHeight);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = 'rgba(147, 51, 234, 0.8)';
                        ctx.setLineDash([5, 3]);
                        ctx.stroke();

                        // カスタムツールチップを描画
                        ctx.setLineDash([]);

                        // 影を追加
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                        ctx.shadowBlur = 8;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 2;

                        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                        ctx.strokeStyle = 'rgba(147, 51, 234, 1)';
                        ctx.lineWidth = 2;

                        // 角丸矩形
                        const radius = 8;
                        ctx.beginPath();
                        ctx.moveTo(tooltipX - tooltipWidth/2 + radius, tooltipY);
                        ctx.lineTo(tooltipX + tooltipWidth/2 - radius, tooltipY);
                        ctx.quadraticCurveTo(tooltipX + tooltipWidth/2, tooltipY, tooltipX + tooltipWidth/2, tooltipY + radius);
                        ctx.lineTo(tooltipX + tooltipWidth/2, tooltipY + tooltipHeight - radius);
                        ctx.quadraticCurveTo(tooltipX + tooltipWidth/2, tooltipY + tooltipHeight, tooltipX + tooltipWidth/2 - radius, tooltipY + tooltipHeight);
                        ctx.lineTo(tooltipX - tooltipWidth/2 + radius, tooltipY + tooltipHeight);
                        ctx.quadraticCurveTo(tooltipX - tooltipWidth/2, tooltipY + tooltipHeight, tooltipX - tooltipWidth/2, tooltipY + tooltipHeight - radius);
                        ctx.lineTo(tooltipX - tooltipWidth/2, tooltipY + radius);
                        ctx.quadraticCurveTo(tooltipX - tooltipWidth/2, tooltipY, tooltipX - tooltipWidth/2 + radius, tooltipY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        // 影をリセット
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;

                        // ツールチップのテキストを描画
                        const value = chart.data.datasets[0].data[lastClickedIndex[chartNum]];
                        const label = chart.data.labels[lastClickedIndex[chartNum]];
                        const categoryToUse = chartNum === 1 ? currentSubCategory : chart2Category;
                        const unit = metricInfo[categoryToUse]?.unit || '';

                        // 日付情報
                        const today = new Date();
                        const totalDays = chart.data.labels.length;
                        const daysAgo = totalDays - 1 - lastClickedIndex[chartNum];
                        const targetDate = new Date(today);
                        targetDate.setDate(today.getDate() - daysAgo);
                        const dateStr = `${targetDate.getMonth() + 1}/${targetDate.getDate()}`;
                        let dateLabel;
                        if (daysAgo === 0) dateLabel = `${dateStr} (今日)`;
                        else if (daysAgo === 1) dateLabel = `${dateStr} (1日前)`;
                        else dateLabel = `${dateStr} (${daysAgo}日前)`;

                        // 値のフォーマット
                        let displayValue;
                        if (metric.getLabel && typeof value === 'number') {
                            // 段階説明がある場合
                            displayValue = metric.getLabel(value);
                        } else if (typeof value === 'number') {
                            displayValue = value % 1 === 0 ? value.toString() : value.toFixed(1);
                        } else {
                            displayValue = value || '-';
                        }

                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '11px sans-serif';
                        ctx.fillText(dateLabel, tooltipX, tooltipY + 15);
                        ctx.font = 'bold 18px sans-serif';
                        ctx.fillStyle = '#7c3aed';
                        ctx.fillText(`${displayValue}${unit}`, tooltipX, tooltipY + 35);

                        ctx.restore();
                    }
                }
            };

            const chartConfig = {
                type: chartType,
                data: {
                    labels: labels,
                    datasets: datasets
                },
                plugins: [crosshairPlugin, fixedTooltipPlugin],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, activeElements) => {
                        if (activeElements.length > 0) {
                            const datasetIndex = activeElements[0].datasetIndex;
                            const index = activeElements[0].index;

                            // メインデータセットの場合、選択パネルを表示し、ツールチップを有効化
                            if (datasetIndex === 0 && index < data.length) {
                                // 最後にクリックした位置を記録（selectDataPointより先に）
                                lastClickedChart = chartNum;
                                lastClickedIndex[chartNum] = index;

                                // ツールチップが無効な場合、自動的に有効化
                                if (!tooltipEnabled[chartNum]) {
                                    toggleTooltip(chartNum);
                                }

                                // 選択パネルを更新
                                selectDataPoint(chartNum, index);
                            }
                        } else {
                            // グラフ外をクリックした場合、ツールチップを無効化
                            if (tooltipEnabled[chartNum] && lastClickedChart === chartNum) {
                                toggleTooltip(chartNum);
                                lastClickedChart = null;
                                lastClickedIndex[chartNum] = null;
                            }
                        }
                    },
                    layout: {
                        padding: {
                            left: 10,
                            right: 20,
                            top: 90,  // 上部のパディングを拡大してツールチップ用のスペースを確保
                            bottom: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: datasets.length > 1,
                            position: 'top',
                            labels: {
                                boxWidth: 12,
                                font: { size: 10 },
                                padding: 8
                            }
                        },
                        tooltip: {
                            enabled: false
                        },
                        annotation: {
                            annotations: chartAnnotations
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    onHover: (event, activeElements, chart) => {
                        // マウスホバー時にクロスヘアを表示
                        const canvasPosition = Chart.helpers.getRelativePosition(event, chart);

                        if (canvasPosition.x >= chart.chartArea.left &&
                            canvasPosition.x <= chart.chartArea.right &&
                            canvasPosition.y >= chart.chartArea.top &&
                            canvasPosition.y <= chart.chartArea.bottom) {

                            chart.crosshair = {
                                x: canvasPosition.x,
                                y: canvasPosition.y,
                                draw: true
                            };
                        } else {
                            chart.crosshair = { draw: false };
                        }

                        chart.draw();
                    },
                    scales: (() => {
                        const scales = {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                beginAtZero: false,
                                min: currentAxisRanges[chartNum].min,
                                max: currentAxisRanges[chartNum].max,
                                ticks: metric.isBinary ? {
                                    stepSize: 1,
                                    callback: function(value) {
                                        return value === 1 ? '完了' : value === 0 ? '未完了' : '';
                                    }
                                } : {
                                    padding: 10,
                                    font: {
                                        size: 11
                                    }
                                },
                                grid: {
                                    drawBorder: true,
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            x: {
                                ticks: {
                                    padding: 5,
                                    font: {
                                        size: 10
                                    },
                                    autoSkip: false,
                                    maxRotation: 0,
                                    callback: function(value, index, ticks) {
                                        const label = this.getLabelForValue(value);
                                        const totalDays = ticks.length;

                                        // 必ず7ポイントに限定して均等に配分
                                        const maxLabels = 7;
                                        const step = Math.floor((totalDays - 1) / (maxLabels - 1));

                                        // 表示するインデックスを計算
                                        let shouldDisplay = false;

                                        if (totalDays <= maxLabels) {
                                            // データが7個以下の場合はすべて表示
                                            shouldDisplay = true;
                                        } else {
                                            // 最初と最後は必ず表示
                                            if (index === 0 || index === totalDays - 1) {
                                                shouldDisplay = true;
                                            } else {
                                                // 均等に配分された位置に表示
                                                for (let i = 1; i < maxLabels - 1; i++) {
                                                    if (index === i * step) {
                                                        shouldDisplay = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        if (!shouldDisplay) {
                                            return '';
                                        }

                                        // 最後のラベル（右端）にのみ単位を追加
                                        if (index === totalDays - 1) {
                                            return label === '0' ? '今日' : label + '日前';
                                        }

                                        return label;
                                    }
                                },
                                grid: {
                                    display: false
                                }
                            }
                        };

                        return scales;
                    })()
                }
            };

            charts[chartNum] = new Chart(document.getElementById(`main-chart-${chartNum}`), chartConfig);

            // グラフ作成後、自動的に最新のデータポイント（今日）を選択してツールチップを表示
            if (data.length > 0) {
                const latestIndex = data.length - 1;
                lastClickedIndex[chartNum] = latestIndex;

                // ツールチップを自動的に有効化
                if (!tooltipEnabled[chartNum]) {
                    tooltipEnabled[chartNum] = true;
                    console.log(`[updateChart] チャート${chartNum}のツールチップを自動有効化 (index: ${latestIndex})`);
                }

                // 選択パネルも更新
                selectDataPoint(chartNum, latestIndex);

                // グラフを更新してツールチッププラグインを描画
                charts[chartNum].update();
            }
        }

        // RM用の変数
        let currentRMReps = null;
        let currentRMExercise = null;

        // 小カテゴリ選択
        function selectSubCategory(category, subCategory) {
            currentSubCategory = subCategory;

            // RM選択時は調整パネルを表示
            const rmPanel = document.getElementById('rm-control-panel');
            if (subCategory === 'rm') {
                if (rmPanel) {
                    rmPanel.classList.remove('hidden');
                    initializeRMPanel();
                }
                return; // パネル表示のみで、グラフは表示しない
            } else {
                if (rmPanel) rmPanel.classList.add('hidden');
                currentRMReps = null;
                currentRMExercise = null;
            }

            // 全期間の最低値・最大値を再計算
            globalMinMax = calculateGlobalMinMax(subCategory);

            // Y軸レンジをリセット
            currentAxisRanges = { 1: { min: null, max: null }, 2: { min: null, max: null } };

            // カテゴリ別の色設定（アプリと完全一致）
            const categoryColors = {
                nutrition: { border: 'border-green-500', text: 'text-green-700' },   // 食事: 緑
                training: { border: 'border-orange-500', text: 'text-orange-700' },  // 運動: オレンジ
                condition: { border: 'border-red-500', text: 'text-red-700' },       // コンディション: 赤
                performance: { border: 'border-purple-500', text: 'text-purple-700' }// パフォーマンス: 紫
            };

            const colors = categoryColors[category] || categoryColors.performance;

            // 現在のカテゴリのサブタブボタンのみを更新
            const subtabContainer = document.getElementById(`${category}-subtabs`);
            if (subtabContainer) {
                subtabContainer.querySelectorAll('.sub-tab-button').forEach(btn => {
                    btn.classList.remove('active', 'border-orange-500', 'text-orange-700', 'border-green-500', 'text-green-700', 'border-red-500', 'text-red-700', 'border-purple-500', 'text-purple-700');
                    btn.classList.add('border-transparent', 'text-gray-700');
                });

                if (event && event.currentTarget) {
                    event.currentTarget.classList.add('active', colors.border, colors.text);
                    event.currentTarget.classList.remove('border-transparent', 'text-gray-700');
                }
            }

            updateChart(1);
            if (comparisonMode) {
                updateChart(2);
            }

            // ツールチップが有効な場合、最新のデータポイントを自動選択
            console.log('[selectSubCategory] ツールチップ状態:', {
                tooltipEnabled: tooltipEnabled[1],
                hasChart: !!charts[1],
                hasDataset: !!(charts[1] && charts[1].data.datasets[0]),
                currentSubCategory: currentSubCategory
            });

            if (tooltipEnabled[1] && charts[1] && charts[1].data.datasets[0]) {
                const dataLength = charts[1].data.datasets[0].data.length;
                console.log('[selectSubCategory] 最新データポイントを自動選択:', {
                    dataLength,
                    newIndex: dataLength - 1,
                    oldIndex: lastClickedIndex[1]
                });
                if (dataLength > 0) {
                    lastClickedIndex[1] = dataLength - 1;
                    // 選択パネルも更新
                    selectDataPoint(1, dataLength - 1);
                    charts[1].update();
                }
            }
            if (comparisonMode && tooltipEnabled[2] && charts[2] && charts[2].data.datasets[0]) {
                const dataLength = charts[2].data.datasets[0].data.length;
                if (dataLength > 0) {
                    lastClickedIndex[2] = dataLength - 1;
                    // 選択パネルも更新
                    selectDataPoint(2, dataLength - 1);
                    charts[2].update();
                }
            }
        }

        // RMパネルの初期化
        function initializeRMPanel() {
            if (!allData.rm || Object.keys(allData.rm).length === 0) {
                document.getElementById('rm-reps-buttons').innerHTML = '<span class="text-xs text-gray-500">RM記録がありません</span>';
                document.getElementById('rm-exercise-buttons').innerHTML = '';
                return;
            }

            // 利用可能な回数を抽出
            const repsSet = new Set();
            Object.keys(allData.rm).forEach(key => {
                const [reps, exercise] = key.split('_');
                repsSet.add(parseInt(reps));
            });
            const repsList = Array.from(repsSet).sort((a, b) => a - b);

            // 回数ボタンを生成
            const repsContainer = document.getElementById('rm-reps-buttons');
            repsContainer.innerHTML = repsList.map((reps, index) =>
                `<button type="button"
                    class="px-2 py-1 text-xs font-semibold rounded border ${index === 0 ? 'bg-orange-600 text-white border-orange-600' : 'bg-white text-gray-700 border-gray-300 hover:border-orange-400'}"
                    onclick="selectRMReps(${reps})">
                    ${reps}RM
                </button>`
            ).join('');

            // 最初の回数を自動選択
            if (repsList.length > 0) {
                selectRMReps(repsList[0]);
            }
        }

        // RM回数を選択
        function selectRMReps(reps) {
            currentRMReps = reps;

            // ボタンのアクティブ状態を更新
            document.querySelectorAll('#rm-reps-buttons button').forEach(btn => {
                btn.classList.remove('bg-orange-600', 'text-white', 'border-orange-600');
                btn.classList.add('bg-white', 'text-gray-700', 'border-gray-300');
            });
            event.currentTarget.classList.add('bg-orange-600', 'text-white', 'border-orange-600');
            event.currentTarget.classList.remove('bg-white', 'text-gray-700', 'border-gray-300');

            // この回数で利用可能な種目を抽出
            const exercises = [];
            Object.keys(allData.rm).forEach(key => {
                const [keyReps, exercise] = key.split('_');
                if (parseInt(keyReps) === reps) {
                    exercises.push(exercise);
                }
            });

            // 種目ボタンを生成
            const exerciseContainer = document.getElementById('rm-exercise-buttons');
            exerciseContainer.innerHTML = exercises.map((exercise, index) =>
                `<button type="button"
                    class="px-2 py-1 text-xs font-semibold rounded border ${index === 0 ? 'bg-orange-600 text-white border-orange-600' : 'bg-white text-gray-700 border-gray-300 hover:border-orange-400'}"
                    onclick="selectRMExercise('${exercise}')">
                    ${exercise}
                </button>`
            ).join('');

            // 最初の種目を自動選択
            if (exercises.length > 0) {
                currentRMExercise = exercises[0];
                updateRMChart();
            }
        }

        // RM種目を選択
        function selectRMExercise(exercise) {
            currentRMExercise = exercise;

            // ボタンのアクティブ状態を更新
            document.querySelectorAll('#rm-exercise-buttons button').forEach(btn => {
                btn.classList.remove('bg-orange-600', 'text-white', 'border-orange-600');
                btn.classList.add('bg-white', 'text-gray-700', 'border-gray-300');
            });
            event.currentTarget.classList.add('bg-orange-600', 'text-white', 'border-orange-600');
            event.currentTarget.classList.remove('bg-white', 'text-gray-700', 'border-gray-300');

            updateRMChart();
        }

        // RMグラフを更新
        function updateRMChart() {
            const key = `${currentRMReps}_${currentRMExercise}`;
            currentSubCategory = `rm_${key}`;

            // metricInfoに動的に追加
            if (!metricInfo[currentSubCategory]) {
                metricInfo[currentSubCategory] = {
                    name: `${currentRMExercise} ${currentRMReps}RM`,
                    unit: 'kg',
                    isBinary: false
                };
            }

            // allDataにマッピング
            if (!allData[currentSubCategory]) {
                allData[currentSubCategory] = allData.rm[key] || [];
            }

            globalMinMax = calculateGlobalMinMax(currentSubCategory);
            currentAxisRanges = { 1: { min: null, max: null }, 2: { min: null, max: null } };

            updateChart(1);
            if (comparisonMode) {
                updateChart(2);
            }
        }

        // 目標データの読み込み
        function loadGoals() {
            try {
                const stored = localStorage.getItem('fitness_goals');
                if (stored) {
                    goals = JSON.parse(stored);
                }
            } catch (error) {
                console.error('目標データの読み込みエラー:', error);
                goals = {};
            }
        }

        // 目標データの保存
        function saveGoalsToStorage() {
            try {
                localStorage.setItem('fitness_goals', JSON.stringify(goals));
            } catch (error) {
                console.error('目標データの保存エラー:', error);
            }
        }

        // 目標設定モーダルを開く
        function openGoalSettingModal() {
            const modal = document.getElementById('goal-setting-modal');
            const metricSelect = document.getElementById('goal-metric');

            // 現在の指標を選択状態にする
            metricSelect.value = currentSubCategory;
            updateGoalUnit();

            // 既存の目標をロード
            loadCurrentGoal();

            modal.classList.add('show');
            lucide.createIcons();
        }

        function closeGoalSettingModal() {
            document.getElementById('goal-setting-modal').classList.remove('show');
        }

        // 指標に応じて単位を更新
        document.getElementById('goal-metric')?.addEventListener('change', updateGoalUnit);

        function updateGoalUnit() {
            const metricSelect = document.getElementById('goal-metric');
            const selectedMetric = metricSelect.value;
            const metric = metricInfo[selectedMetric];
            document.getElementById('goal-unit').textContent = metric.unit;
            loadCurrentGoal();
        }

        // 現在の目標を表示
        function loadCurrentGoal() {
            const metricSelect = document.getElementById('goal-metric');
            const selectedMetric = metricSelect.value;
            const goal = goals[selectedMetric];
            const infoDiv = document.getElementById('current-goal-info');
            const textDiv = document.getElementById('current-goal-text');

            if (goal) {
                const metric = metricInfo[selectedMetric];
                let text = `目標値: ${goal.value}${metric.unit}`;
                if (goal.date) {
                    text += `<br>達成予定日: ${goal.date}`;
                }
                text += `<br>グラフ表示: ${goal.showLine ? 'ON' : 'OFF'}`;

                textDiv.innerHTML = text;
                infoDiv.classList.remove('hidden');

                // フォームに値を設定
                document.getElementById('goal-value').value = goal.value;
                document.getElementById('goal-date').value = goal.date || '';
                document.getElementById('goal-show-line').checked = goal.showLine;
            } else {
                infoDiv.classList.add('hidden');
                // フォームをクリア
                document.getElementById('goal-value').value = '';
                document.getElementById('goal-date').value = '';
                document.getElementById('goal-show-line').checked = true;
            }
        }

        // 目標を保存
        function saveGoal() {
            const metricSelect = document.getElementById('goal-metric');
            const selectedMetric = metricSelect.value;
            const value = parseFloat(document.getElementById('goal-value').value);
            const date = document.getElementById('goal-date').value;
            const showLine = document.getElementById('goal-show-line').checked;

            if (isNaN(value) || value <= 0) {
                alert('有効な目標値を入力してください');
                return;
            }

            // 目標を保存
            goals[selectedMetric] = {
                value: value,
                date: date || null,
                showLine: showLine,
                createdAt: new Date().toISOString()
            };

            saveGoalsToStorage();

            // グラフを更新（目標ラインを表示）
            updateChart(1);
            if (comparisonMode) {
                updateChart(2);
            }

            alert('目標を保存しました！');
            closeGoalSettingModal();
        }

        // 目標をクリア
        function clearGoal() {
            const metricSelect = document.getElementById('goal-metric');
            const selectedMetric = metricSelect.value;

            if (goals[selectedMetric]) {
                if (confirm('この指標の目標をクリアしますか？')) {
                    delete goals[selectedMetric];
                    saveGoalsToStorage();
                    loadCurrentGoal();

                    // グラフを更新
                    updateChart(1);
                    if (comparisonMode) {
                        updateChart(2);
                    }

                    alert('目標をクリアしました');
                }
            } else {
                alert('設定された目標がありません');
            }
        }

        // アノテーション（メモ）機能
        function loadAnnotations() {
            try {
                const stored = localStorage.getItem('fitness_annotations');
                if (stored) {
                    annotations = JSON.parse(stored);
                }
            } catch (error) {
                console.error('アノテーションの読み込みエラー:', error);
                annotations = {};
            }
        }

        function saveAnnotations() {
            try {
                localStorage.setItem('fitness_annotations', JSON.stringify(annotations));
            } catch (error) {
                console.error('アノテーションの保存エラー:', error);
            }
        }

        // グラフのクリックイベントでメモを追加
        function addAnnotationOnClick(chartNum, event) {
            const chart = charts[chartNum];
            if (!chart) return;

            const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true);

            if (points.length > 0) {
                const point = points[0];
                const dataIndex = point.index;
                const label = chart.data.labels[dataIndex];
                const metric = metricInfo[currentSubCategory];

                // メモを入力
                const note = prompt(`${label}のメモを入力してください:\n（例: 風邪で休養、チートデイ、体調良好）`);

                if (note && note.trim() !== '') {
                    const key = `${currentSubCategory}_${label}`;
                    annotations[key] = {
                        date: label,
                        note: note.trim(),
                        metric: currentSubCategory,
                        createdAt: new Date().toISOString()
                    };

                    saveAnnotations();
                    updateChart(chartNum);
                    alert('メモを保存しました！');
                }
            }
        }

        // アノテーションマーカーをグラフに追加
        function getAnnotationMarkers(chartNum, category) {
            const labels = charts[chartNum]?.data.labels || [];
            const markers = {};

            labels.forEach((label, index) => {
                const key = `${category}_${label}`;
                if (annotations[key]) {
                    markers[`note_${index}`] = {
                        type: 'point',
                        xValue: index,
                        yValue: currentData[chartNum][index],
                        backgroundColor: 'rgba(255, 193, 7, 0.8)', // amber-400
                        borderColor: 'rgb(245, 158, 11)',
                        borderWidth: 2,
                        radius: 8,
                        label: {
                            display: true,
                            content: '📝',
                            position: 'top',
                            font: {
                                size: 14
                            }
                        }
                    };
                }
            });

            return markers;
        }

        // グラフホバー時にメモを表示
        function showAnnotationTooltip(chartNum, tooltipItems) {
            if (!tooltipItems || tooltipItems.length === 0) return;

            const index = tooltipItems[0].dataIndex;
            const label = charts[chartNum].data.labels[index];
            const key = `${currentSubCategory}_${label}`;

            if (annotations[key]) {
                return [
                    tooltipItems[0].formattedValue,
                    '',
                    `📝 メモ: ${annotations[key].note}`
                ];
            }

            return tooltipItems[0].formattedValue;
        }

        // フローティング設定パネル
        let currentPanelChart = 1; // どのグラフの設定を開いているか

        function toggleSettingsPanel(chartNum) {
            const panel = document.getElementById('settings-panel');
            const isHidden = panel.classList.contains('hidden');

            if (isHidden) {
                currentPanelChart = chartNum;
                openSettingsPanel();
            } else {
                closeSettingsPanel();
            }
        }

        function openSettingsPanel() {
            const panel = document.getElementById('settings-panel');
            panel.classList.remove('hidden');

            // パネルの状態を現在のグラフ設定に同期
            syncPanelToCurrentSettings();

            // Flatpickrを初期化（パネル用）
            initPanelFlatpickr();

            lucide.createIcons();
        }

        function closeSettingsPanel() {
            document.getElementById('settings-panel').classList.add('hidden');
        }

        function syncPanelToCurrentSettings() {
            // Y軸範囲を同期
            const axisMinPanel = document.getElementById('axis-min-panel');
            const axisMaxPanel = document.getElementById('axis-max-panel');
            const comparisonModePanel = document.getElementById('comparison-mode-panel');
            const syncAxisPanel = document.getElementById('sync-axis-panel');

            if (axisMinPanel) axisMinPanel.value = currentAxisRanges[currentPanelChart].min || '';
            if (axisMaxPanel) axisMaxPanel.value = currentAxisRanges[currentPanelChart].max || '';

            // 比較モードとY軸連動を同期
            if (comparisonModePanel) comparisonModePanel.checked = comparisonMode;
            if (syncAxisPanel) syncAxisPanel.checked = axisSync;

            // Chart2カテゴリドロップダウンを更新
            updateChart2CategoryDropdown();
        }

        function updateChart2CategoryDropdown() {
            const select = document.getElementById('chart2-category-panel');
            if (!select) return;

            // 現在選択されている値を保存
            const currentValue = chart2Category;

            // すべてのオプションをクリア
            select.innerHTML = '';

            // カテゴリ別にグループ化してオプションを追加
            const categories = {
                'パフォーマンス': ['lbm', 'directive', 'overall'],
                '食事': ['calories', 'protein', 'carbs', 'fat', 'water'],
                '運動': ['workout_duration', 'workout_volume', 'steps', 'cardio'],
                'コンディション': ['weight', 'body_fat', 'sleep', 'mood', 'energy']
            };

            for (const [categoryName, metrics] of Object.entries(categories)) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = categoryName;

                for (const metric of metrics) {
                    if (metricInfo[metric]) {
                        const option = document.createElement('option');
                        option.value = metric;
                        option.textContent = `${metricInfo[metric].icon} ${metricInfo[metric].name}`;
                        if (metric === currentValue) {
                            option.selected = true;
                        }
                        optgroup.appendChild(option);
                    }
                }

                select.appendChild(optgroup);
            }
        }

        function initPanelFlatpickr() {
            if (!flatpickrInstances['panel']) {
                flatpickrInstances['panel'] = {
                    start: flatpickr('#custom-start-panel', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today',
                        onChange: function(selectedDates) {
                            if (flatpickrInstances['panel']?.end) {
                                flatpickrInstances['panel'].end.set('minDate', selectedDates[0]);
                            }
                        }
                    }),
                    end: flatpickr('#custom-end-panel', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today'
                    })
                };
            }
        }

        function applyCustomPeriodFromPanel() {
            const startDate = document.getElementById('custom-start-panel').value;
            const endDate = document.getElementById('custom-end-panel').value;

            if (!startDate || !endDate) {
                alert('開始日と終了日を選択してください');
                return;
            }

            const start = new Date(startDate);
            const end = new Date(endDate);

            if (start > end) {
                alert('開始日は終了日より前である必要があります');
                return;
            }

            const days = Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;

            if (days > 90) {
                alert('最大90日間まで選択できます');
                return;
            }

            currentPeriods[currentPanelChart] = days;

            // 期間ボタンの選択状態をリセット
            const container = currentPanelChart === 1 ? document.getElementById('chart-1') : document.getElementById('chart-2');
            container.querySelectorAll('.period-button').forEach(btn => {
                btn.classList.remove('active');
                btn.classList.remove('border-purple-500', 'border-blue-500', 'font-semibold');
                btn.classList.add('border-gray-300');
            });

            updateChart(currentPanelChart);
            alert(`カスタム期間（${days}日間）を適用しました`);
        }

        function updateAxisRangeFromPanel() {
            const min = parseFloat(document.getElementById('axis-min-panel').value);
            const max = parseFloat(document.getElementById('axis-max-panel').value);

            if (!isNaN(min) && !isNaN(max) && min < max) {
                currentAxisRanges[currentPanelChart] = { min, max };

                // グラフを更新
                if (charts[currentPanelChart]) {
                    charts[currentPanelChart].options.scales.y.min = min;
                    charts[currentPanelChart].options.scales.y.max = max;
                    charts[currentPanelChart].update();
                }

                // Y軸連動がONで、グラフ1の変更なら、グラフ2も同期
                if (axisSync && currentPanelChart === 1 && comparisonMode) {
                    currentAxisRanges[2] = { min, max };
                    if (charts[2]) {
                        charts[2].options.scales.y.min = min;
                        charts[2].options.scales.y.max = max;
                        charts[2].update();
                    }
                }
            }
        }

        function resetAxisRangeFromPanel() {
            document.getElementById('axis-min-panel').value = globalMinMax.min;
            document.getElementById('axis-max-panel').value = globalMinMax.max;
            updateAxisRangeFromPanel();
        }

        // カスタム期間選択機能
        let flatpickrInstances = {};

        function initFlatpickr() {
            // Flatpickrを日本語に設定
            if (typeof flatpickr !== 'undefined') {
                flatpickr.localize(flatpickr.l10ns.ja);
            }

            // Chart 1のFlatpickr初期化
            if (!flatpickrInstances[1]) {
                flatpickrInstances[1] = {
                    start: flatpickr('#custom-start-1', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today',
                        onChange: function(selectedDates) {
                            if (flatpickrInstances[1]?.end) {
                                flatpickrInstances[1].end.set('minDate', selectedDates[0]);
                            }
                        }
                    }),
                    end: flatpickr('#custom-end-1', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today'
                    })
                };
            }

            // Chart 2のFlatpickr初期化
            if (!flatpickrInstances[2]) {
                flatpickrInstances[2] = {
                    start: flatpickr('#custom-start-2', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today',
                        onChange: function(selectedDates) {
                            if (flatpickrInstances[2]?.end) {
                                flatpickrInstances[2].end.set('minDate', selectedDates[0]);
                            }
                        }
                    }),
                    end: flatpickr('#custom-end-2', {
                        locale: 'ja',
                        dateFormat: 'Y-m-d',
                        maxDate: 'today'
                    })
                };
            }
        }

        function toggleCustomPeriod(chartNum) {
            const customPeriodDiv = document.getElementById(`custom-period-${chartNum}`);
            customPeriodDiv.classList.toggle('hidden');

            // 初回表示時にFlatpickrを初期化
            if (!customPeriodDiv.classList.contains('hidden')) {
                initFlatpickr();
            }

            lucide.createIcons();
        }

        function applyCustomPeriod(chartNum) {
            const startDate = document.getElementById(`custom-start-${chartNum}`).value;
            const endDate = document.getElementById(`custom-end-${chartNum}`).value;

            if (!startDate || !endDate) {
                alert('開始日と終了日を選択してください');
                return;
            }

            const start = new Date(startDate);
            const end = new Date(endDate);

            if (start > end) {
                alert('開始日は終了日より前である必要があります');
                return;
            }

            // 日数を計算
            const days = Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;

            if (days > 90) {
                alert('最大90日間まで選択できます');
                return;
            }

            // カスタム期間を適用
            currentPeriods[chartNum] = days;

            // 期間ボタンの選択状態をリセット
            const container = chartNum === 1 ? document.getElementById('chart-1') : document.getElementById('chart-2');
            container.querySelectorAll('.period-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // カスタム期間のUIを閉じる
            document.getElementById(`custom-period-${chartNum}`).classList.add('hidden');

            // グラフを更新
            updateChart(chartNum);

            alert(`カスタム期間（${days}日間）を適用しました`);
        }

        // ===== ドリルダウンモーダル機能 =====

        function showDrillDownModal(chartNum, index, label, value, metric) {
            // Chart2で比較モードの場合は、chart2Categoryを使用
            const categoryToUse = (chartNum === 2 && comparisonMode) ? chart2Category : currentSubCategory;

            // データを保存
            const annotationKey = `${categoryToUse}_${label}`;
            currentDrillDownData = {
                chartNum,
                index,
                label,
                value,
                metric,
                annotationKey
            };

            // ラベルから実際の日付を計算
            const daysAgo = parseInt(label.replace(/[^\d]/g, '')) || 0;
            const today = new Date();
            const targetDate = new Date(today);
            targetDate.setDate(today.getDate() - daysAgo);

            // 日付をフォーマット (10/15形式 と YYYY-MM-DD形式)
            const dateString = `${targetDate.getMonth() + 1}/${targetDate.getDate()}`;
            const daysAgoString = daysAgo === 0 ? '今日' : `${daysAgo}日前`;
            // ローカルタイムゾーンで日付を取得
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const day = String(targetDate.getDate()).padStart(2, '0');
            const dateKey = `${year}-${month}-${day}`; // YYYY-MM-DD形式

            // モーダルの内容を更新
            document.getElementById('drilldown-title').textContent = `${dateString} (${daysAgoString})`;
            document.getElementById('drilldown-subtitle').textContent = `${metric.name}のデータ`;
            document.getElementById('drilldown-metric').textContent = metric.name;

            // 値の表示（バイナリデータの場合は完了/未完了に変換）
            if (metric.isBinary) {
                document.getElementById('drilldown-value').textContent = value === 1 ? '✅ 完了' : '❌ 未完了';
            } else if (metric.getLabel && typeof value === 'number') {
                // 段階説明がある場合
                document.getElementById('drilldown-value').textContent = metric.getLabel(value);
            } else {
                document.getElementById('drilldown-value').textContent = `${value.toFixed(1)} ${metric.unit}`;
            }

            // メモの表示
            if (annotations[annotationKey]) {
                document.getElementById('drilldown-memo-text').textContent = annotations[annotationKey].note;
                document.getElementById('drilldown-memo-display').classList.remove('hidden');
                document.getElementById('drilldown-memo-empty').classList.add('hidden');
                document.getElementById('memo-edit-button-text').textContent = 'メモを編集';
            } else {
                document.getElementById('drilldown-memo-display').classList.add('hidden');
                document.getElementById('drilldown-memo-empty').classList.remove('hidden');
                document.getElementById('memo-edit-button-text').textContent = 'メモを追加';
            }

            // 編集UIをリセット
            document.getElementById('drilldown-memo-edit').classList.add('hidden');
            document.getElementById('drilldown-memo-input').value = annotations[annotationKey]?.note || '';

            // モーダルを表示
            const modal = document.getElementById('drilldown-modal');
            modal.classList.remove('hidden');

            // アイコンを再描画
            lucide.createIcons();
        }

        function closeDrillDownModal() {
            const modal = document.getElementById('drilldown-modal');
            modal.classList.add('hidden');

            // 編集UIをリセット
            document.getElementById('drilldown-memo-edit').classList.add('hidden');
        }

        function toggleMemoEdit() {
            const editDiv = document.getElementById('drilldown-memo-edit');
            editDiv.classList.toggle('hidden');

            // アイコンを再描画
            lucide.createIcons();
        }

        function saveMemo() {
            const noteText = document.getElementById('drilldown-memo-input').value.trim();

            if (!noteText) {
                alert('メモを入力してください');
                return;
            }

            // アノテーションを保存
            annotations[currentDrillDownData.annotationKey] = {
                note: noteText,
                value: currentDrillDownData.value,
                metric: currentDrillDownData.metric.name
            };

            // LocalStorageに保存
            localStorage.setItem('history_v10_annotations', JSON.stringify(annotations));

            // UIを更新
            document.getElementById('drilldown-memo-text').textContent = noteText;
            document.getElementById('drilldown-memo-display').classList.remove('hidden');
            document.getElementById('drilldown-memo-empty').classList.add('hidden');
            document.getElementById('memo-edit-button-text').textContent = 'メモを編集';
            document.getElementById('drilldown-memo-edit').classList.add('hidden');

            // グラフを更新（ツールチップにメモが表示されるように）
            updateChart(currentDrillDownData.chartNum);

            alert('メモを保存しました');
        }

        function deleteMemo() {
            if (!confirm('このメモを削除してもよろしいですか?')) {
                return;
            }

            // アノテーションを削除
            delete annotations[currentDrillDownData.annotationKey];

            // LocalStorageを更新
            localStorage.setItem('history_v10_annotations', JSON.stringify(annotations));

            // UIを更新
            document.getElementById('drilldown-memo-display').classList.add('hidden');
            document.getElementById('drilldown-memo-empty').classList.remove('hidden');
            document.getElementById('memo-edit-button-text').textContent = 'メモを追加';
            document.getElementById('drilldown-memo-edit').classList.add('hidden');
            document.getElementById('drilldown-memo-input').value = '';

            // グラフを更新
            updateChart(currentDrillDownData.chartNum);

            alert('メモを削除しました');
        }

        // 初期表示
        // 親ウィンドウからのユーザー情報を受け取る
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'SET_USER_INFO') {
                console.log('[履歴グラフ] 親ウィンドウからユーザー情報を受信:', event.data.userId);
                window.currentUser = {
                    uid: event.data.userId,
                    profile: event.data.userProfile
                };
                // ユーザー情報を受け取ったらデータを再読み込み
                if (typeof loadRealData === 'function') {
                    loadRealData().then(data => {
                        allData = data;
                        console.log('[履歴グラフ] ユーザーデータ再読み込み完了');
                        globalMinMax = calculateGlobalMinMax('lbm');
                        updateChart(1);
                    });
                }
            } else if (event.data && event.data.type === 'RELOAD_DATA') {
                // データ再読み込みメッセージを受信
                console.log('[履歴グラフ] データ再読み込み要求を受信');
                if (typeof loadRealData === 'function') {
                    loadRealData().then(data => {
                        allData = data;
                        console.log('[履歴グラフ] データ再読み込み完了');

                        // 現在のカテゴリに応じて適切に更新
                        if (currentMainCategory === 'insights') {
                            // 閃きタブの場合はリストを更新
                            renderInsightsList();
                        } else {
                            // グラフタブの場合は現在のサブカテゴリのグラフを更新
                            if (currentSubCategory) {
                                globalMinMax = calculateGlobalMinMax(currentSubCategory);
                            } else {
                                globalMinMax = calculateGlobalMinMax('lbm');
                            }

                            // グラフ1を更新
                            updateChart(1);

                            // 比較モードの場合はグラフ2も更新
                            if (comparisonMode) {
                                updateChart(2);
                            }
                        }
                    });
                }
            }
        });

        async function init() {
            // DEV_MODEの確認
            const isDevMode = typeof DEV_MODE !== 'undefined' && DEV_MODE;

            // 現在のユーザー情報を取得（親ウィンドウから受信する可能性があるので初期値のみ設定）
            if (isDevMode) {
                // DEV_MODE: LocalStorageを使用
                window.currentUser = { uid: DEV_USER_ID || 'demo_user' };
            } else if (typeof firebase !== 'undefined' && firebase.auth) {
                // 本番モード: Firebaseを使用
                const user = firebase.auth().currentUser;
                if (user) {
                    window.currentUser = { uid: user.uid };
                } else {
                    // ログインユーザーが取得できない場合は仮の値を設定
                    // （親ウィンドウからpostMessageで上書きされる）
                    window.currentUser = { uid: 'demo_user' };
                }
            }

            loadGoals(); // 目標データを読み込み
            loadAnnotations(); // メモデータを読み込み

            // 実データの読み込みを試行
            if (typeof DataService !== 'undefined') {
                try {
                    allData = await loadRealData();
                    console.log('Real data loaded successfully');
                } catch (error) {
                    console.error('Failed to load real data:', error);
                }
            } else {
                console.warn('DataService is not available');
            }

            globalMinMax = calculateGlobalMinMax('lbm');
            updateChart(1);

            // 初期表示で一番右（最新）のデータポイントを選択
            setTimeout(() => {
                const chart = charts[1];
                if (chart && chart.data.labels.length > 0) {
                    const lastIndex = chart.data.labels.length - 1;
                    selectDataPoint(1, lastIndex);
                }
            }, 100);
        }

        // データポイント選択機能
        function selectDataPoint(chartNum, index) {
            const chart = charts[chartNum];
            if (!chart || index < 0 || index >= chart.data.labels.length) return;

            selectedDataIndex[chartNum] = index;
            const categoryToUse = chartNum === 1 ? currentSubCategory : chart2Category;
            const unit = metricInfo[categoryToUse]?.unit || '';
            const value = chart.data.datasets[0].data[index];

            // 日付情報を取得
            const today = new Date();
            const totalDays = chart.data.labels.length;
            const daysAgo = totalDays - 1 - index;
            const targetDate = new Date(today);
            targetDate.setDate(today.getDate() - daysAgo);
            const dateStr = `${targetDate.getMonth() + 1}/${targetDate.getDate()}`;

            let dateLabel;
            if (daysAgo === 0) {
                dateLabel = `${dateStr} (今日)`;
            } else if (daysAgo === 1) {
                dateLabel = `${dateStr} (1日前)`;
            } else {
                dateLabel = `${dateStr} (${daysAgo}日前)`;
            }

            // 値のフォーマット
            let displayValue;
            const metric = metricInfo[categoryToUse];
            if (metric && metric.getLabel && typeof value === 'number') {
                // 段階説明がある場合
                displayValue = metric.getLabel(value);
            } else if (typeof value === 'number') {
                displayValue = value % 1 === 0 ? value.toString() : value.toFixed(1);
            } else {
                displayValue = value || '-';
            }

            // UIを更新
            document.getElementById(`selected-date-${chartNum}`).textContent = dateLabel;
            document.getElementById(`selected-value-${chartNum}`).innerHTML =
                `${displayValue}<span class="text-lg opacity-70 ml-1">${unit}</span>`;
            document.getElementById(`selected-point-${chartNum}`).classList.remove('hidden');

            // ツールチップを表示
            if (tooltipEnabled[chartNum]) {
                const meta = chart.getDatasetMeta(0);
                if (meta.data[index]) {
                    const element = meta.data[index];
                    chart.tooltip.setActiveElements([
                        {datasetIndex: 0, index: index}
                    ], {x: element.x, y: element.y});

                    // グラフを再描画してリード線を更新
                    requestAnimationFrame(() => {
                        chart.draw();
                    });
                }
            }

            // アイコンを再描画
            lucide.createIcons();
        }

        // データポイントナビゲーション
        function navigateDataPoint(chartNum, direction) {
            const chart = charts[chartNum];
            if (!chart) return;

            const currentIndex = selectedDataIndex[chartNum];
            if (currentIndex === null) return;

            const newIndex = currentIndex + direction;
            if (newIndex >= 0 && newIndex < chart.data.labels.length) {
                selectDataPoint(chartNum, newIndex);

                // 最後にクリックした位置を更新（ツールチップ表示用）
                lastClickedIndex[chartNum] = newIndex;
                lastClickedChart = chartNum;
            }
        }

        // ツールチップの表示/非表示を切り替え
        let tooltipEnabled = { 1: false, 2: false };
        let lastClickedChart = null;
        let lastClickedIndex = { 1: null, 2: null };

        function toggleTooltip(chartNum) {
            const chart = charts[chartNum];
            if (!chart) return;

            // 状態を切り替え
            tooltipEnabled[chartNum] = !tooltipEnabled[chartNum];

            // Chart.jsのツールチップ設定を更新
            chart.options.plugins.tooltip.enabled = tooltipEnabled[chartNum];

            // ツールチップを有効化した場合、最後にクリックした位置に表示
            if (tooltipEnabled[chartNum] && lastClickedIndex[chartNum] !== null) {
                const meta = chart.getDatasetMeta(0);
                if (meta.data[lastClickedIndex[chartNum]]) {
                    const element = meta.data[lastClickedIndex[chartNum]];
                    chart.tooltip.setActiveElements([
                        {datasetIndex: 0, index: lastClickedIndex[chartNum]}
                    ], {x: element.x, y: element.y});
                }
            }

            // グラフを再描画
            requestAnimationFrame(() => {
                chart.draw();
            });

            // ボタンのテキストとスタイルを更新
            const button = document.getElementById(`tooltip-toggle-${chartNum}`);
            if (tooltipEnabled[chartNum]) {
                button.innerHTML = '<i data-lucide="eye-off" class="w-3 h-3 inline-block mr-1"></i>ツールチップを非表示';
                button.classList.remove('bg-gray-100', 'text-gray-700');
                button.classList.add('bg-purple-600', 'text-white');
            } else {
                button.innerHTML = '<i data-lucide="info" class="w-3 h-3 inline-block mr-1"></i>ツールチップを表示';
                button.classList.remove('bg-purple-600', 'text-white');
                button.classList.add('bg-gray-100', 'text-gray-700');
            }

            // アイコンを再描画
            lucide.createIcons();
        }

        // ========== 履歴分析機能 ==========

        // 個別分析ボタンの更新
        function updateTabSpecificAnalysisButton(category) {
            const btn = document.getElementById('tab-specific-analysis-btn');
            const icon = document.getElementById('tab-analysis-icon');
            const label = document.getElementById('tab-analysis-label');

            const tabConfig = {
                nutrition: {
                    icon: 'utensils',
                    label: '個別分析',
                    bgColor: 'bg-green-500 hover:bg-green-600',
                    textColor: 'text-white'
                },
                training: {
                    icon: 'dumbbell',
                    label: '個別分析',
                    bgColor: 'bg-orange-500 hover:bg-orange-600',
                    textColor: 'text-white'
                },
                condition: {
                    icon: 'heart-pulse',
                    label: '個別分析',
                    bgColor: 'bg-red-500 hover:bg-red-600',
                    textColor: 'text-white'
                },
                performance: {
                    icon: 'trending-up',
                    label: '個別分析',
                    bgColor: 'bg-purple-500 hover:bg-purple-600',
                    textColor: 'text-white'
                }
            };

            const config = tabConfig[category] || tabConfig.nutrition;

            // アイコンとラベルを更新
            icon.setAttribute('data-lucide', config.icon);
            label.textContent = config.label;

            // 色を更新
            btn.className = `px-3 py-2 rounded-lg flex items-center gap-2 text-sm font-semibold shadow-sm transition ${config.bgColor} ${config.textColor}`;

            // アイコンを再描画
            lucide.createIcons();
        }

        // 個別分析の実行
        async function performTabSpecificAnalysis() {
            const category = currentMainCategory;

            // 各タブ専用の分析を実行
            const analysisMap = {
                nutrition: generateNutritionAnalysis,
                training: generateTrainingAnalysis,
                condition: generateConditionAnalysis,
                performance: generatePerformanceAnalysis
            };

            const analysisFn = analysisMap[category];
            if (analysisFn) {
                await analysisFn();
            } else {
                alert('このタブの個別分析は未実装です');
            }
        }

        // 食事タブの個別分析
        async function generateNutritionAnalysis() {
            // ローディングモーダルを表示
            document.getElementById('history-analysis-loading-modal').classList.remove('hidden');

            try {
                // 現在表示中の期間データを取得
                const days = currentPeriods[1];
                const periodData = generateData(days);

                // 栄養データの統計計算
                const nutritionStats = {};
                const nutritionKeys = ['calories', 'protein', 'fat', 'carbs', 'fiber', 'sodium', 'sugar'];

                for (const key of nutritionKeys) {
                    if (Array.isArray(periodData[key]) && periodData[key].length > 0) {
                        const validData = periodData[key].filter(v => typeof v === 'number' && !isNaN(v) && v > 0);
                        if (validData.length > 0) {
                            const sum = validData.reduce((a, b) => a + b, 0);
                            const avg = sum / validData.length;
                            const max = Math.max(...validData);
                            const min = Math.min(...validData);

                            nutritionStats[key] = {
                                avg: avg.toFixed(1),
                                max: max.toFixed(1),
                                min: min.toFixed(1),
                                count: validData.length
                            };
                        }
                    }
                }

                // ユーザー情報の取得
                const userProfileKey = typeof STORAGE_KEYS !== 'undefined' ? STORAGE_KEYS.USER_PROFILE : 'yourCoachBeta_userProfile';
                const userProfile = JSON.parse(localStorage.getItem(userProfileKey) || '{}');
                const currentPurpose = userProfile.purpose || 'メンテナンス';
                const userStyle = userProfile.style || '一般';
                const targetCalories = userProfile.targetCalories || 2000;
                const targetProtein = userProfile.targetProtein || 100;
                const targetFat = userProfile.targetFat || 50;
                const targetCarbs = userProfile.targetCarbs || 250;

                // プロンプト生成
                const prompt = `## 役割

トップアスリート指導のエリートパーソナルコーチとして、ユーザーの過去${days}日間の栄養摂取データを分析し、簡潔で実践的なフィードバックを提供します。

## 評価の基本原則

**最重要**: ユーザーの目的（${currentPurpose}）とスタイル（${userStyle}）の達成に必要な栄養摂取を評価してください。

**目的: ${currentPurpose}**
- 期間: 過去${days}日間
- 目標カロリー: ${targetCalories}kcal/日
- 目標PFC: P${targetProtein}g / F${targetFat}g / C${targetCarbs}g

## 栄養データ（過去${days}日間）

### カロリー・PFC
${nutritionStats.calories ? `- カロリー平均: ${nutritionStats.calories.avg}kcal（目標: ${targetCalories}kcal）\n  最低${nutritionStats.calories.min}～最高${nutritionStats.calories.max}kcal、記録日数: ${nutritionStats.calories.count}日` : '- カロリーデータなし'}
${nutritionStats.protein ? `- タンパク質平均: ${nutritionStats.protein.avg}g（目標: ${targetProtein}g）\n  最低${nutritionStats.protein.min}～最高${nutritionStats.protein.max}g` : '- タンパク質データなし'}
${nutritionStats.fat ? `- 脂質平均: ${nutritionStats.fat.avg}g（目標: ${targetFat}g）\n  最低${nutritionStats.fat.min}～最高${nutritionStats.fat.max}g` : '- 脂質データなし'}
${nutritionStats.carbs ? `- 炭水化物平均: ${nutritionStats.carbs.avg}g（目標: ${targetCarbs}g）\n  最低${nutritionStats.carbs.min}～最高${nutritionStats.carbs.max}g` : '- 炭水化物データなし'}

### 微量栄養素
${nutritionStats.fiber ? `- 食物繊維平均: ${nutritionStats.fiber.avg}g（最低${nutritionStats.fiber.min}～最高${nutritionStats.fiber.max}g）` : '- 食物繊維データなし'}
${nutritionStats.sodium ? `- 塩分平均: ${nutritionStats.sodium.avg}g（最低${nutritionStats.sodium.min}～最高${nutritionStats.sodium.max}g）` : '- 塩分データなし'}
${nutritionStats.sugar ? `- 糖質平均: ${nutritionStats.sugar.avg}g（最低${nutritionStats.sugar.min}～最高${nutritionStats.sugar.max}g）` : '- 糖質データなし'}

## 出力形式（厳守）

過去${days}日間の栄養データ、お疲れ様でした！

---

① 評価

[過去${days}日間の栄養摂取全体を2-3文で評価]

---

② 傾向と特徴

**カロリー**: [カロリー摂取の傾向を1文で]
**PFC**: [タンパク質・脂質・炭水化物の傾向を1-2文で]
**微量栄養素**: [食物繊維・塩分・糖質の傾向を1文で]

---

③ 全体の相関関係

[栄養摂取と体組成変化やパフォーマンスとの相関を2-3文で分析]

---

④ 改善点

[${currentPurpose}の目的達成のための具体的な改善アクションを2-3文で提示]

ナイストライ！

ルール:
- 冒頭は必ず「過去${days}日間の栄養データ、お疲れ様でした！」から開始
- 最後は必ず「ナイストライ！」で終了
- ${currentPurpose}の目的を意識した評価を行う
- 数値は具体的に示す`;

                // Cloud Functions経由でAI分析を実行
                const response = await GeminiAPI.sendMessage(prompt, [], userProfile, 'gemini-2.5-pro');

                // レスポンスの検証（デイリー分析と同じ形式）
                if (!response || !response.success) {
                    throw new Error('AI分析からの応答が不正です');
                }

                const report = response.text.replace(/\n/g, '<br>');

                // ローディングモーダルを非表示
                document.getElementById('history-analysis-loading-modal').classList.add('hidden');

                // レポートモーダルを表示
                document.getElementById('history-analysis-period').textContent = `食事タブ 個別分析（過去${days}日間）`;
                document.getElementById('history-analysis-report-content').innerHTML = report;
                document.getElementById('history-analysis-report-modal').classList.remove('hidden');

                // アイコンを再描画
                lucide.createIcons();
            } catch (error) {
                console.error('[食事個別分析] エラー:', error);
                document.getElementById('history-analysis-loading-modal').classList.add('hidden');
                alert('分析中にエラーが発生しました。もう一度お試しください。');
            }
        }

        // 運動タブの個別分析
        async function generateTrainingAnalysis() {
            // ローディングモーダルを表示
            document.getElementById('history-analysis-loading-modal').classList.remove('hidden');

            try {
                // 現在表示中の期間データを取得
                const days = currentPeriods[1];
                const periodData = generateData(days);

                // 運動データの統計計算
                const trainingStats = {};
                const trainingKeys = ['training_time', 'calorie_consumption', 'rm_max', 'cardio_duration'];

                for (const key of trainingKeys) {
                    if (Array.isArray(periodData[key]) && periodData[key].length > 0) {
                        const validData = periodData[key].filter(v => typeof v === 'number' && !isNaN(v) && v > 0);
                        if (validData.length > 0) {
                            const sum = validData.reduce((a, b) => a + b, 0);
                            const avg = sum / validData.length;
                            const max = Math.max(...validData);
                            const min = Math.min(...validData);

                            trainingStats[key] = {
                                avg: avg.toFixed(1),
                                max: max.toFixed(1),
                                min: min.toFixed(1),
                                count: validData.length
                            };
                        }
                    }
                }

                // ユーザー情報の取得
                const userProfileKey = typeof STORAGE_KEYS !== 'undefined' ? STORAGE_KEYS.USER_PROFILE : 'yourCoachBeta_userProfile';
                const userProfile = JSON.parse(localStorage.getItem(userProfileKey) || '{}');
                const currentPurpose = userProfile.purpose || 'メンテナンス';
                const userStyle = userProfile.style || '一般';

                // プロンプト生成
                const prompt = `## 役割

トップアスリート指導のエリートパーソナルコーチとして、ユーザーの過去${days}日間の運動データを分析し、簡潔で実践的なフィードバックを提供します。

## 評価の基本原則

**最重要**: ユーザーの目的（${currentPurpose}）とスタイル（${userStyle}）の達成に必要なトレーニングを評価してください。

**目的: ${currentPurpose}**
- 期間: 過去${days}日間
- 重点: 継続性、強度、バリエーション

**スタイル: ${userStyle}**
- 評価指針: ${userStyle === '筋肥大' ? '高重量・高ボリューム・筋肥大種目を重視' : userStyle === '筋力' ? '最大筋力・パワー向上・低レップ高重量を重視' : userStyle === '持久力' ? '有酸素運動・持久系種目・軽重量高レップを重視' : userStyle === 'バランス' ? '全面的な身体能力向上・多様な種目を重視' : '健康維持・日常フィットネスを重視'}

## 運動データ（過去${days}日間）

### トレーニング時間・消費カロリー
${trainingStats.training_time ? `- トレーニング時間平均: ${trainingStats.training_time.avg}分（最低${trainingStats.training_time.min}～最高${trainingStats.training_time.max}分、記録日数: ${trainingStats.training_time.count}日）` : '- トレーニング時間データなし'}
${trainingStats.calorie_consumption ? `- 消費カロリー平均: ${trainingStats.calorie_consumption.avg}kcal（最低${trainingStats.calorie_consumption.min}～最高${trainingStats.calorie_consumption.max}kcal）` : '- 消費カロリーデータなし'}

### RM・有酸素運動
${trainingStats.rm_max ? `- RM最大値平均: ${trainingStats.rm_max.avg}kg（最低${trainingStats.rm_max.min}～最高${trainingStats.rm_max.max}kg）` : '- RMデータなし'}
${trainingStats.cardio_duration ? `- 有酸素運動時間平均: ${trainingStats.cardio_duration.avg}分（最低${trainingStats.cardio_duration.min}～最高${trainingStats.cardio_duration.max}分）` : '- 有酸素運動データなし'}

## 出力形式（厳守）

過去${days}日間の運動データ、お疲れ様でした！

---

① 評価

[過去${days}日間の運動実施全体を2-3文で評価]

---

② 傾向と特徴

**トレーニング時間**: [トレーニング時間の傾向を1文で]
**消費カロリー**: [消費カロリーの傾向を1文で]
**RM・有酸素**: [RM・有酸素運動の傾向を1-2文で]

---

③ 全体の相関関係

[運動実施と体組成変化やパフォーマンスとの相関を2-3文で分析]

---

④ 改善点

[${currentPurpose}の目的達成のための具体的な改善アクションを2-3文で提示]

ナイストライ！

ルール:
- 冒頭は必ず「過去${days}日間の運動データ、お疲れ様でした！」から開始
- 最後は必ず「ナイストライ！」で終了
- ${currentPurpose}の目的を意識した評価を行う
- 数値は具体的に示す`;

                // Cloud Functions経由でAI分析を実行
                const response = await GeminiAPI.sendMessage(prompt, [], userProfile, 'gemini-2.5-pro');

                // レスポンスの検証（デイリー分析と同じ形式）
                if (!response || !response.success) {
                    throw new Error('AI分析からの応答が不正です');
                }

                const report = response.text.replace(/\n/g, '<br>');

                // ローディングモーダルを非表示
                document.getElementById('history-analysis-loading-modal').classList.add('hidden');

                // レポートモーダルを表示
                document.getElementById('history-analysis-period').textContent = `運動タブ 個別分析（過去${days}日間）`;
                document.getElementById('history-analysis-report-content').innerHTML = report;
                document.getElementById('history-analysis-report-modal').classList.remove('hidden');

                // アイコンを再描画
                lucide.createIcons();
            } catch (error) {
                console.error('[運動個別分析] エラー:', error);
                document.getElementById('history-analysis-loading-modal').classList.add('hidden');
                alert('分析中にエラーが発生しました。もう一度お試しください。');
            }
        }

        // コンディションタブの個別分析
        async function generateConditionAnalysis() {
            // ローディングモーダルを表示
            document.getElementById('history-analysis-loading-modal').classList.remove('hidden');

            try {
                // 現在表示中の期間データを取得
                const days = currentPeriods[1];
                const periodData = generateData(days);

                // コンディションデータの統計計算
                const conditionStats = {};
                const conditionKeys = ['sleep_duration', 'sleep_quality', 'appetite', 'gut_health', 'focus', 'stress'];
                const conditionLabels = {
                    sleep_duration: ['', '5h以下', '6h', '7h', '8h', '9h以上'],
                    sleep_quality: ['', '最悪', '悪', '普通', '良', '最高'],
                    appetite: ['', 'なし', '少', '普通', '良好', '最高'],
                    gut_health: ['', '不調', 'やや悪', '普通', '良好', '最高'],
                    focus: ['', '最低', '低', '普通', '高', '最高'],
                    stress: ['', '極大', '高', '普通', '低', 'なし']
                };

                for (const key of conditionKeys) {
                    if (Array.isArray(periodData[key]) && periodData[key].length > 0) {
                        const validData = periodData[key].filter(v => typeof v === 'number' && !isNaN(v) && v > 0);
                        if (validData.length > 0) {
                            const sum = validData.reduce((a, b) => a + b, 0);
                            const avg = sum / validData.length;
                            const max = Math.max(...validData);
                            const min = Math.min(...validData);

                            conditionStats[key] = {
                                avg: avg.toFixed(1),
                                max: max.toFixed(1),
                                min: min.toFixed(1),
                                count: validData.length,
                                avgLabel: conditionLabels[key][Math.round(avg)]
                            };
                        }
                    }
                }

                // ユーザー情報の取得
                const userProfileKey = typeof STORAGE_KEYS !== 'undefined' ? STORAGE_KEYS.USER_PROFILE : 'yourCoachBeta_userProfile';
                const userProfile = JSON.parse(localStorage.getItem(userProfileKey) || '{}');
                const currentPurpose = userProfile.purpose || 'メンテナンス';
                const userStyle = userProfile.style || '一般';

                // プロンプト生成
                const prompt = `## 役割

トップアスリート指導のエリートパーソナルコーチとして、ユーザーの過去${days}日間のコンディションデータを分析し、簡潔で実践的なフィードバックを提供します。

## 評価の基本原則

**最重要**: ユーザーの目的（${currentPurpose}）とスタイル（${userStyle}）の達成に必要なコンディション管理を評価してください。

**目的: ${currentPurpose}**
- 期間: 過去${days}日間
- 重点: 睡眠・メンタル・消化の安定性

## コンディションデータ（過去${days}日間）

### 睡眠
${conditionStats.sleep_duration ? `- 睡眠時間平均: ${conditionStats.sleep_duration.avgLabel}（最低${conditionStats.sleep_duration.min}～最高${conditionStats.sleep_duration.max}、記録日数: ${conditionStats.sleep_duration.count}日）` : '- 睡眠時間データなし'}
${conditionStats.sleep_quality ? `- 睡眠の質平均: ${conditionStats.sleep_quality.avgLabel}（最低${conditionStats.sleep_quality.min}～最高${conditionStats.sleep_quality.max}）` : '- 睡眠の質データなし'}

### 消化・食欲
${conditionStats.appetite ? `- 食欲平均: ${conditionStats.appetite.avgLabel}（最低${conditionStats.appetite.min}～最高${conditionStats.appetite.max}）` : '- 食欲データなし'}
${conditionStats.gut_health ? `- 腸内環境平均: ${conditionStats.gut_health.avgLabel}（最低${conditionStats.gut_health.min}～最高${conditionStats.gut_health.max}）` : '- 腸内環境データなし'}

### メンタル
${conditionStats.focus ? `- 集中力平均: ${conditionStats.focus.avgLabel}（最低${conditionStats.focus.min}～最高${conditionStats.focus.max}）` : '- 集中力データなし'}
${conditionStats.stress ? `- ストレス平均: ${conditionStats.stress.avgLabel}（最低${conditionStats.stress.min}～最高${conditionStats.stress.max}）` : '- ストレスデータなし'}

## 出力形式（厳守）

過去${days}日間のコンディションデータ、お疲れ様でした！

---

① 評価

[過去${days}日間のコンディション全体を2-3文で評価]

---

② 傾向と特徴

**睡眠**: [睡眠時間・質の傾向を1文で]
**消化・食欲**: [食欲・腸内環境の傾向を1文で]
**メンタル**: [集中力・ストレスの傾向を1文で]

---

③ 全体の相関関係

[コンディションと栄養・運動・パフォーマンスとの相関を2-3文で分析]

---

④ 改善点

[${currentPurpose}の目的達成のための具体的な改善アクションを2-3文で提示]

ナイストライ！

ルール:
- 冒頭は必ず「過去${days}日間のコンディションデータ、お疲れ様でした！」から開始
- 最後は必ず「ナイストライ！」で終了
- ${currentPurpose}の目的を意識した評価を行う
- 数値は具体的に示す（ラベル表示を活用）`;

                // Cloud Functions経由でAI分析を実行
                const response = await GeminiAPI.sendMessage(prompt, [], userProfile, 'gemini-2.5-pro');

                // レスポンスの検証（デイリー分析と同じ形式）
                if (!response || !response.success) {
                    throw new Error('AI分析からの応答が不正です');
                }

                const report = response.text.replace(/\n/g, '<br>');

                // ローディングモーダルを非表示
                document.getElementById('history-analysis-loading-modal').classList.add('hidden');

                // レポートモーダルを表示
                document.getElementById('history-analysis-period').textContent = `コンディションタブ 個別分析（過去${days}日間）`;
                document.getElementById('history-analysis-report-content').innerHTML = report;
                document.getElementById('history-analysis-report-modal').classList.remove('hidden');

                // アイコンを再描画
                lucide.createIcons();
            } catch (error) {
                console.error('[コンディション個別分析] エラー:', error);
                document.getElementById('history-analysis-loading-modal').classList.add('hidden');
                alert('分析中にエラーが発生しました。もう一度お試しください。');
            }
        }

        // パフォーマンスタブの個別分析
        async function generatePerformanceAnalysis() {
            // ローディングモーダルを表示
            document.getElementById('history-analysis-loading-modal').classList.remove('hidden');

            try {
                // 現在表示中の期間データを取得
                const days = currentPeriods[1];
                const periodData = generateData(days);

                // パフォーマンスデータの統計計算
                const performanceStats = {};
                const performanceKeys = ['weight', 'body_fat_percentage', 'lbm'];

                for (const key of performanceKeys) {
                    if (Array.isArray(periodData[key]) && periodData[key].length > 0) {
                        const validData = periodData[key].filter(v => typeof v === 'number' && !isNaN(v) && v > 0);
                        if (validData.length > 0) {
                            const sum = validData.reduce((a, b) => a + b, 0);
                            const avg = sum / validData.length;
                            const max = Math.max(...validData);
                            const min = Math.min(...validData);
                            const change = validData[validData.length - 1] - validData[0];

                            performanceStats[key] = {
                                avg: avg.toFixed(1),
                                max: max.toFixed(1),
                                min: min.toFixed(1),
                                count: validData.length,
                                change: change.toFixed(1),
                                first: validData[0].toFixed(1),
                                last: validData[validData.length - 1].toFixed(1)
                            };
                        }
                    }
                }

                // ユーザー情報の取得
                const userProfileKey = typeof STORAGE_KEYS !== 'undefined' ? STORAGE_KEYS.USER_PROFILE : 'yourCoachBeta_userProfile';
                const userProfile = JSON.parse(localStorage.getItem(userProfileKey) || '{}');
                const currentPurpose = userProfile.purpose || 'メンテナンス';
                const userStyle = userProfile.style || '一般';

                // 指示書データの取得（達成率計算用）
                const directivesKey = typeof STORAGE_KEYS !== 'undefined' ? STORAGE_KEYS.DIRECTIVES : 'yourCoachBeta_directives';
                const directives = JSON.parse(localStorage.getItem(directivesKey) || '{}');
                const recentDirectives = Object.entries(directives)
                    .filter(([date]) => {
                        const directiveDate = new Date(date);
                        const cutoffDate = new Date();
                        cutoffDate.setDate(cutoffDate.getDate() - days);
                        return directiveDate >= cutoffDate;
                    })
                    .map(([date, data]) => ({ date, ...data }));

                const directiveSummary = recentDirectives.length > 0
                    ? `過去${days}日間の指示書: ${recentDirectives.length}件生成`
                    : '指示書データなし';

                // プロンプト生成
                const prompt = `## 役割

トップアスリート指導のエリートパーソナルコーチとして、ユーザーの過去${days}日間のパフォーマンスデータを分析し、簡潔で実践的なフィードバックを提供します。

## 評価の基本原則

**最重要**: ユーザーの目的（${currentPurpose}）とスタイル（${userStyle}）の達成度を評価してください。

**目的: ${currentPurpose}**
- 期間: 過去${days}日間
- 重点: LBM・体重・体脂肪率の変化と指示書達成状況

## パフォーマンスデータ（過去${days}日間）

### 体組成の変化
${performanceStats.lbm ? `- LBM: ${performanceStats.lbm.first}kg → ${performanceStats.lbm.last}kg（変化: ${performanceStats.lbm.change > 0 ? '+' : ''}${performanceStats.lbm.change}kg）\n  平均${performanceStats.lbm.avg}kg、最低${performanceStats.lbm.min}～最高${performanceStats.lbm.max}kg、記録日数: ${performanceStats.lbm.count}日` : '- LBMデータなし'}
${performanceStats.weight ? `- 体重: ${performanceStats.weight.first}kg → ${performanceStats.weight.last}kg（変化: ${performanceStats.weight.change > 0 ? '+' : ''}${performanceStats.weight.change}kg）\n  平均${performanceStats.weight.avg}kg、最低${performanceStats.weight.min}～最高${performanceStats.weight.max}kg` : '- 体重データなし'}
${performanceStats.body_fat_percentage ? `- 体脂肪率: ${performanceStats.body_fat_percentage.first}% → ${performanceStats.body_fat_percentage.last}%（変化: ${performanceStats.body_fat_percentage.change > 0 ? '+' : ''}${performanceStats.body_fat_percentage.change}%）\n  平均${performanceStats.body_fat_percentage.avg}%、最低${performanceStats.body_fat_percentage.min}～最高${performanceStats.body_fat_percentage.max}%` : '- 体脂肪率データなし'}

### 指示書データ
${directiveSummary}

## 出力形式（厳守）

過去${days}日間のパフォーマンスデータ、お疲れ様でした！

---

① 評価

[過去${days}日間のパフォーマンス全体を2-3文で評価]

---

② 傾向と特徴

**LBM**: [LBMの変化傾向を1-2文で分析]
**体重・体脂肪率**: [体重・体脂肪率の変化傾向を1-2文で分析]

---

③ 指示書達成率

[指示書の実施状況と達成度を2-3文で評価]

---

④ 改善点

[${currentPurpose}の目的達成のための具体的な改善アクションを2-3文で提示]

ナイストライ！

ルール:
- 冒頭は必ず「過去${days}日間のパフォーマンスデータ、お疲れ様でした！」から開始
- 最後は必ず「ナイストライ！」で終了
- ${currentPurpose}の目的を意識した評価を行う
- 数値は具体的に示す（変化量を明示）`;

                // Cloud Functions経由でAI分析を実行
                const response = await GeminiAPI.sendMessage(prompt, [], userProfile, 'gemini-2.5-pro');

                // レスポンスの検証（デイリー分析と同じ形式）
                if (!response || !response.success) {
                    throw new Error('AI分析からの応答が不正です');
                }

                const report = response.text.replace(/\n/g, '<br>');

                // ローディングモーダルを非表示
                document.getElementById('history-analysis-loading-modal').classList.add('hidden');

                // レポートモーダルを表示
                document.getElementById('history-analysis-period').textContent = `パフォーマンスタブ 個別分析（過去${days}日間）`;
                document.getElementById('history-analysis-report-content').innerHTML = report;
                document.getElementById('history-analysis-report-modal').classList.remove('hidden');

                // アイコンを再描画
                lucide.createIcons();
            } catch (error) {
                console.error('[パフォーマンス個別分析] エラー:', error);
                document.getElementById('history-analysis-loading-modal').classList.add('hidden');
                alert('分析中にエラーが発生しました。もう一度お試しください。');
            }
        }

        // 履歴分析の実行
        async function performHistoryAnalysis() {
            // ローディングモーダルを表示
            document.getElementById('history-analysis-loading-modal').classList.remove('hidden');

            try {
                // 現在表示中の期間データを取得
                const days = currentPeriods[1];
                const report = await generateHistoryAnalysisReport(days);

                // ローディングモーダルを非表示
                document.getElementById('history-analysis-loading-modal').classList.add('hidden');

                // レポートモーダルを表示
                document.getElementById('history-analysis-period').textContent = `過去${days}日間の分析`;
                document.getElementById('history-analysis-report-content').innerHTML = report;
                document.getElementById('history-analysis-report-modal').classList.remove('hidden');

                // アイコンを再描画
                lucide.createIcons();
            } catch (error) {
                console.error('[履歴分析] エラー:', error);
                document.getElementById('history-analysis-loading-modal').classList.add('hidden');
                alert('分析中にエラーが発生しました。もう一度お試しください。');
            }
        }

        // 履歴分析レポートの生成
        async function generateHistoryAnalysisReport(days) {
            // 期間データの集計
            const periodData = generateData(days);

            // 各項目の統計計算
            const stats = {};
            const conditionLabels = {
                sleep_duration: ['', '5h以下', '6h', '7h', '8h', '9h以上'],
                sleep_quality: ['', '最悪', '悪', '普通', '良', '最高'],
                appetite: ['', 'なし', '少', '普通', '良好', '最高'],
                gut_health: ['', '不調', 'やや悪', '普通', '良好', '最高'],
                focus: ['', '最低', '低', '普通', '高', '最高'],
                stress: ['', '極大', '高', '普通', '低', 'なし']
            };

            for (const key in periodData) {
                if (Array.isArray(periodData[key]) && periodData[key].length > 0) {
                    const validData = periodData[key].filter(v => typeof v === 'number' && !isNaN(v) && v > 0);
                    if (validData.length > 0) {
                        const sum = validData.reduce((a, b) => a + b, 0);
                        const avg = sum / validData.length;
                        const max = Math.max(...validData);
                        const min = Math.min(...validData);

                        stats[key] = {
                            avg: avg.toFixed(1),
                            max: max.toFixed(1),
                            min: min.toFixed(1),
                            count: validData.length,
                            avgLabel: conditionLabels[key] ? conditionLabels[key][Math.round(avg)] : null
                        };
                    }
                }
            }

            // ユーザー情報の取得（localStorage経由）
            const userProfileKey = typeof STORAGE_KEYS !== 'undefined' ? STORAGE_KEYS.USER_PROFILE : 'yourCoachBeta_userProfile';
            const userProfile = JSON.parse(localStorage.getItem(userProfileKey) || '{}');
            const currentPurpose = userProfile.purpose || 'メンテナンス';
            const userStyle = userProfile.style || '一般';

            // プロンプト生成（デイリー分析と同じ形式に統一）
            const prompt = `## 役割

トップアスリート指導のエリートパーソナルコーチとして、ユーザーの過去${days}日間のデータを分析し、簡潔で実践的なフィードバックを提供します。

## 評価の基本原則

**最重要**: ユーザーの目的（${currentPurpose}）とスタイル（${userStyle}）の達成に必要な「食事・運動・睡眠」の3要素の推移を評価してください。

**目的: ${currentPurpose}**
- 期間: 過去${days}日間
- 重点: 継続性、安定性、目標達成度

**スタイル: ${userStyle}**
- 評価指針: ${userStyle === '筋肥大' ? '高重量・高ボリューム・筋肥大種目を重視' : userStyle === '筋力' ? '最大筋力・パワー向上・低レップ高重量を重視' : userStyle === '持久力' ? '有酸素運動・持久系種目・軽重量高レップを重視' : userStyle === 'バランス' ? '全面的な身体能力向上・多様な種目を重視' : '健康維持・日常フィットネスを重視'}

## 期間データ（過去${days}日間）

### 栄養の推移
${stats.calories ? `- カロリー平均: ${stats.calories.avg}kcal（最低${stats.calories.min}～最高${stats.calories.max}kcal、記録日数: ${stats.calories.count}日）` : '- データなし'}
${stats.protein ? `- タンパク質平均: ${stats.protein.avg}g（最低${stats.protein.min}～最高${stats.protein.max}g、記録日数: ${stats.protein.count}日）` : '- データなし'}
${stats.fat ? `- 脂質平均: ${stats.fat.avg}g（最低${stats.fat.min}～最高${stats.fat.max}g、記録日数: ${stats.fat.count}日）` : '- データなし'}
${stats.carbs ? `- 炭水化物平均: ${stats.carbs.avg}g（最低${stats.carbs.min}～最高${stats.carbs.max}g、記録日数: ${stats.carbs.count}日）` : '- データなし'}

### 運動の推移
${stats.total_time ? `- 総時間平均: ${stats.total_time.avg}分（最低${stats.total_time.min}～最高${stats.total_time.max}分、記録日数: ${stats.total_time.count}日）` : '- データなし'}
${stats.total_exercises ? `- 実施種目数平均: ${stats.total_exercises.avg}種目（記録日数: ${stats.total_exercises.count}日）` : '- データなし'}
${stats.total_weight ? `- 総重量平均: ${stats.total_weight.avg}kg（記録日数: ${stats.total_weight.count}日）` : '- データなし'}

### コンディションの推移
${stats.sleep_duration ? `- 睡眠時間平均: ${stats.sleep_duration.avgLabel || stats.sleep_duration.avg}（記録日数: ${stats.sleep_duration.count}日）` : '- データなし'}
${stats.sleep_quality ? `- 睡眠の質平均: ${stats.sleep_quality.avgLabel || stats.sleep_quality.avg}（記録日数: ${stats.sleep_quality.count}日）` : '- データなし'}
${stats.appetite ? `- 食欲平均: ${stats.appetite.avgLabel || stats.appetite.avg}（記録日数: ${stats.appetite.count}日）` : '- データなし'}
${stats.gut_health ? `- 腸内環境平均: ${stats.gut_health.avgLabel || stats.gut_health.avg}（記録日数: ${stats.gut_health.count}日）` : '- データなし'}
${stats.focus ? `- 集中力平均: ${stats.focus.avgLabel || stats.focus.avg}（記録日数: ${stats.focus.count}日）` : '- データなし'}
${stats.stress ? `- ストレス平均: ${stats.stress.avgLabel || stats.stress.avg}（記録日数: ${stats.stress.count}日）` : '- データなし'}

## 出力形式（厳守）

過去${days}日間の記録、お疲れ様でした！

---

① 結論

**栄養**
[過去${days}日間の栄養摂取の評価を1-2文で]

**運動**
[過去${days}日間の運動実施の評価を1-2文で]

**コンディション**
[過去${days}日間のコンディションの評価を1-2文で]

---

② 根拠

[上記3項目の評価理由を具体的な数値を示して2-3文で説明]

---

③ 気づき

[${currentPurpose}の目的達成のために重要な発見や傾向を1-2文で提示]

ルール:
- 冒頭は必ず「過去${days}日間の記録、お疲れ様でした！」から開始
- 栄養・運動・コンディションの3項目を必ず評価
- 数値必須（g、kg、回数、時間、記録日数）
- 各項目1-2文で完結
- 「良い」「悪い」等の抽象表現禁止
- データに基づいた事実のみ記載
- 改善指示は不要（気づきの提供のみ）
- **書式統一**: リスト表記は必ず「-」を使用（他の記号は使わない）
- **参考文献禁止**: 参考文献、注釈、アスタリスク（*）による補足説明は一切記載しない
- **太字**: **太字**は継続使用可能（見出しや強調のため）
- ${currentPurpose}の目的を意識した評価を行う`;

            // GeminiAPI（Cloud Functions経由）にリクエスト
            const response = await GeminiAPI.sendMessage(prompt, [], userProfile, 'gemini-2.5-pro');

            // レスポンスの検証
            if (!response.success) {
                console.error('[履歴分析] APIエラー:', response);
                throw new Error(response.error || 'AI分析の生成中にエラーが発生しました。');
            }

            const reportText = response.text;

            // Markdownを簡易HTML変換
            let html = reportText
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/^---$/gm, '<hr class="my-4">')
                .replace(/^① (.+)$/gm, '<h3 class="text-xl font-bold text-purple-700 mt-6 mb-3">① $1</h3>')
                .replace(/^② (.+)$/gm, '<h3 class="text-xl font-bold text-purple-700 mt-6 mb-3">② $1</h3>')
                .replace(/^③ (.+)$/gm, '<h3 class="text-xl font-bold text-purple-700 mt-6 mb-3">③ $1</h3>')
                .replace(/^④ (.+)$/gm, '<h3 class="text-xl font-bold text-purple-700 mt-6 mb-3">④ $1</h3>')
                .replace(/^- (.+)$/gm, '<li class="ml-4">$1</li>')
                .replace(/\n\n/g, '</p><p class="mb-3">')
                .replace(/^(.+)$/gm, '<p class="mb-3">$1</p>');

            return html;
        }

        // 履歴分析モーダルを閉じる
        function closeHistoryAnalysisModal() {
            document.getElementById('history-analysis-report-modal').classList.add('hidden');
            document.getElementById('history-analysis-answer').classList.add('hidden');
            document.getElementById('history-analysis-question-input').value = '';
        }

        // 履歴分析への質問
        async function askHistoryAnalysisQuestion() {
            const questionInput = document.getElementById('history-analysis-question-input');
            const question = questionInput.value.trim();

            if (!question) {
                alert('質問を入力してください');
                return;
            }

            // ローディング表示
            const answerDiv = document.getElementById('history-analysis-answer');
            const answerText = document.getElementById('history-analysis-answer-text');
            answerDiv.classList.remove('hidden');
            answerText.textContent = '回答を生成中...';

            try {
                const days = currentPeriods[1];
                const periodData = generateData(days);

                // 統計データを簡潔にまとめる
                const summaryStats = {};
                for (const key in periodData) {
                    if (Array.isArray(periodData[key]) && periodData[key].length > 0) {
                        const validData = periodData[key].filter(v => typeof v === 'number' && !isNaN(v) && v > 0);
                        if (validData.length > 0) {
                            const sum = validData.reduce((a, b) => a + b, 0);
                            const avg = sum / validData.length;
                            summaryStats[key] = avg.toFixed(1);
                        }
                    }
                }

                // ユーザー情報の取得
                const userProfileKey = typeof STORAGE_KEYS !== 'undefined' ? STORAGE_KEYS.USER_PROFILE : 'yourCoachBeta_userProfile';
                const userProfile = JSON.parse(localStorage.getItem(userProfileKey) || '{}');

                // 分析レポートを取得（モーダルに表示されている内容）
                const reportContent = document.getElementById('history-analysis-report-content')?.innerHTML || '';
                const reportText = reportContent.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();

                const prompt = `## 役割
あなたは、ユーザーの質問に答える、親身で優秀なAIパフォーマンスコーチです。

## 重要な前提
あなたは既に以下の履歴分析レポートを生成しています。このレポートの内容を**絶対的な前提**として、ユーザーの質問に回答してください。
レポートに書かれている情報と矛盾する回答や、独自に再計算・再評価した回答は絶対にしないでください。

### あなたが生成した履歴分析レポート全文
${reportText || '（レポート生成中または未生成）'}

### 期間データ（平均値）
${JSON.stringify(summaryStats, null, 2)}

## ユーザーからの質問
「${question}」

## タスク
**必ず上記のレポート内容を前提として**、ユーザーの質問に回答してください。

- ✅ レポートに書かれている評価や数値をそのまま引用する
- ✅ レポートの分析結果を基に、質問に対する補足説明や深堀りをする
- ✅ レポートで言及されていない内容は「レポートには記載がありませんが...」と前置きする
- ❌ レポートと異なる評価や数値を提示しない
- ❌ レポートを無視して独自に分析しない

専門用語を避け、高校生にも理解できるような言葉で、簡潔かつ丁寧に回答してください（1-3文程度）。`;

                // GeminiAPI（Cloud Functions経由）にリクエスト
                const response = await GeminiAPI.sendMessage(prompt, [], userProfile, 'gemini-2.5-pro');

                // レスポンスの検証
                if (!response.success) {
                    console.error('[履歴分析質問] APIエラー:', response);
                    throw new Error(response.error || 'AI回答の生成中にエラーが発生しました。');
                }

                const answer = response.text;

                answerText.textContent = answer;
                questionInput.value = '';
            } catch (error) {
                console.error('[履歴分析質問] エラー:', error);
                answerText.textContent = 'エラーが発生しました。もう一度お試しください。';
            }
        }

        // 履歴ページを閉じる（親ウィンドウにメッセージを送信）
        function closeHistoryPage() {
            window.parent.postMessage({ type: 'CLOSE_HISTORY' }, '*');
        }

        init();
    </script>
</body>
</html>
